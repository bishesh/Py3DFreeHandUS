<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Py3DFreeHandUS.process &mdash; Py3DFreeHandUS 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Py3DFreeHandUS 1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Py3DFreeHandUS 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for Py3DFreeHandUS.process</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: process</span>
<span class="sd">   :synopsis: Module for performing: US probe calibration; calibration quality assessment; voxel-array reconstruction.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="c"># Modules importation</span>
<span class="kn">from</span> <span class="nn">kine</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">voxel_array_utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">image_utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">segment</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">calib</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">array_helpers</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">math_utils</span> <span class="kn">import</span> <span class="n">lcmm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">nd</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">vtk</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>



<span class="k">def</span> <span class="nf">checkOdd</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
    
<span class="k">def</span> <span class="nf">checkInt</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">checkFreq</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Acquisition frequency was not defined&#39;</span><span class="p">)</span>
<span class="c">#    if not checkInt(f) or f &lt;= 0:</span>
<span class="c">#        raise Exception(&#39;Acquisition frequency must be integer and positive&#39;)</span>

<span class="k">def</span> <span class="nf">checkFreqRatio</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">checkInt</span><span class="p">(</span><span class="n">f2</span><span class="o">/</span><span class="n">f1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">checkInt</span><span class="p">(</span><span class="n">f2</span><span class="o">/</span><span class="n">f1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Frequencies ratio must be integer&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkMkrList</span><span class="p">(</span><span class="n">mkrList</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mkrList</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;There must be at least 3 markers&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkKineFiles</span><span class="p">(</span><span class="n">kineFiles</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">kineFiles</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Kinematics files were not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;&gt;</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kineFiles</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">L</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Number of kinematics files must be {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">checkUsFiles</span><span class="p">(</span><span class="n">usFiles</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">usFiles</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;US files were not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;&gt;</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">usFiles</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">L</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Number of US files must be {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">checkIm2PrPose</span><span class="p">(</span><span class="n">prRim</span><span class="p">,</span> <span class="n">Tim</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">prRim</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">Tim</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;US probe calibration was not performed&#39;</span><span class="p">)</span>        
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prRim</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">prRim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">prRim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;US image-to-probe rotation matrix must be a 3 x 3 matrix&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Tim</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">Tim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;US image-to-probe position vector must be a 3 elements vector&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkPr2GlPose</span><span class="p">(</span><span class="n">Rpr</span><span class="p">,</span> <span class="n">Tpr</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">Rpr</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">Tpr</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;US probe pose computation was not performed&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Rpr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">Rpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">Rpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Probe-to-global rotation matrix must be a N x 3 x 3 matrix&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Tpr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">Tpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Probe-to-global position vector must be a N x 3 matrix&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkIm2GlPose</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">R</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Pose for US images was not calculated&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Image-to-global roto-translation matrix must be a N x 4 x 4 matrix&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkGl2ConvPose</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">R</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Pose from global to convenient reference frame to was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;auto_PCA&#39;</span><span class="p">,</span><span class="s">&#39;first_last_frames_centroid&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39; global-to-convenient roto-translation matrix calculation method not supported&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;If matrix, global-to-convenient roto-translation matrix must be 4 x 4 matrix&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkFeature</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">feature</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;2_points_on_line&#39;</span><span class="p">,</span> <span class="s">&#39;2_points&#39;</span><span class="p">,</span> <span class="s">&#39;1_point&#39;</span><span class="p">,</span> <span class="s">&#39;mask&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Feature not supported&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkSegmentation</span><span class="p">(</span><span class="n">segmentation</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">segmentation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;manual&#39;</span><span class="p">,</span><span class="s">&#39;auto_hough&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Segmentation not supported&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkPhantom</span><span class="p">(</span><span class="n">phantom</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">phantom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;single_wall&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Phantom not supported&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkFeatures</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">features</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Features from US images were not extracted&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkImDim</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;At least one US image dimensions was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">checkInt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;US image dimensions must be integer and positive&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkPixel2mm</span><span class="p">(</span><span class="n">pixel2mm</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pixel2mm</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;US image pixel-to-mm ratio was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pixel2mm</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;US image pixel-to-mm ratio must be positive&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkFxyz</span><span class="p">(</span><span class="n">fxyz</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">fxyz</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Voxel array scaling factors were not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fxyz</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fxyz</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;auto_bounded_parallel_scans&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Voxel array scaling factors calculation method not supported&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fxyz</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Voxel array scaling factors must be exactly 3&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;All voxel array scaling factors must be positive&#39;</span><span class="p">)</span>  

<span class="k">def</span> <span class="nf">checkWrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">wrapper</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Wrapping method was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wrapper</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;parallelepipedon&#39;</span><span class="p">,</span> <span class="s">&#39;convex_hull&#39;</span><span class="p">,</span><span class="s">&#39;none&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Wrapping method not supported&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkStep</span><span class="p">(</span><span class="n">step</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Wrapping creation step was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">checkInt</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="ow">or</span> <span class="n">step</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Wrapping creation step must be integer and positive&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkV</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">V</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Voxel array initialization was not performed&#39;</span><span class="p">)</span>
        
<span class="k">def</span> <span class="nf">checkPathForSuppFiles</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">fp</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Path for support files was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Path for support files is not valid&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkMethod</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Gaps filling method was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;VNN&#39;</span><span class="p">,</span> <span class="s">&#39;AVG_CUBE&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Gaps filling method not supported&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkBlocksN</span><span class="p">(</span><span class="n">blocksN</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">blocksN</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Blocks number was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">checkInt</span><span class="p">(</span><span class="n">blocksN</span><span class="p">)</span> <span class="ow">or</span> <span class="n">blocksN</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Blocks number must be integer and positive or zero&#39;</span><span class="p">)</span>
        
<span class="k">def</span> <span class="nf">checkBlockDir</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Blocks direction was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="s">&#39;Y&#39;</span><span class="p">,</span> <span class="s">&#39;Z&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Blocks direction not supported&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkMaxS</span><span class="p">(</span><span class="n">maxS</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">maxS</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Max search cube side was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">checkInt</span><span class="p">(</span><span class="n">maxS</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">checkOdd</span><span class="p">(</span><span class="n">maxS</span><span class="p">)</span> <span class="ow">or</span> <span class="n">maxS</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Max search cube side must be integer, positive and odd&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkDistTh</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;&gt;</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Distance threshold must be greater or equal than 1&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkMinPct</span><span class="p">(</span><span class="n">minPct</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">minPct</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Acceptability percentage was not set&#39;</span><span class="p">)</span>            
    <span class="k">if</span> <span class="n">minPct</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Acceptability percentage must be positive or zero&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkSxyz</span><span class="p">(</span><span class="n">sxyz</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sxyz</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;vtkImageData spacing factors were not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sxyz</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sxyz</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;auto&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;vtkImageData spacing factors calculation method not supported&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sxyz</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;vtkImageData spacing factors must be exactly 3&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;All vtkImageData spacing factors must be positive&#39;</span><span class="p">)</span>
            
<span class="k">def</span> <span class="nf">checkFilePath</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;File path was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;File path cannot be empty&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkPrecType</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Precision type was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;RP&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Precision type not supported&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkAccType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Accuracy type was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;DA&#39;</span><span class="p">,</span> <span class="s">&#39;RA&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Accuracy type not supported&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkDist</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Distance was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">checkInt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Distance must be integer and positive&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">checkTimeVector</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Time vector was not set&#39;</span><span class="p">)</span>  
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Time vector cannot be empty&#39;</span><span class="p">)</span> 
<span class="c">#    if t[0] &lt;&gt; 0:</span>
<span class="c">#        raise Exception(&#39;First time element must be 0&#39;)</span>
        
<span class="k">def</span> <span class="nf">checkTimeDelay</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Time delay was not set&#39;</span><span class="p">)</span>     


<span class="k">def</span> <span class="nf">setInsideRange</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">stepBase</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">bound</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">bound</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">stepBase</span>
        <span class="n">v</span> <span class="o">+=</span> <span class="n">step</span>
    <span class="k">return</span> <span class="n">v</span>
    

<span class="k">def</span> <span class="nf">checkCalibMethod</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Calibation method was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;eq_based&#39;</span><span class="p">,</span> <span class="s">&#39;maximize_NCCint&#39;</span><span class="p">,</span> <span class="s">&#39;maximize_NCC&#39;</span><span class="p">,</span> <span class="s">&#39;maximize_NCCfast&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Calibration method not supported&#39;</span><span class="p">)</span>

        
<span class="k">def</span> <span class="nf">checkAlignFrames</span><span class="p">(</span><span class="n">alignFrames</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">alignFrames</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Frames for alignment were not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">alignFrames</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">alignFrames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Some frame for alignment out of bounds&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">checkFillVoxMethod</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Voxel filling method was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;last&#39;</span><span class="p">,</span> <span class="s">&#39;avg&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Voxel filling method not supported&#39;</span><span class="p">)</span>

        
<span class="k">def</span> <span class="nf">checkVoxFrames</span><span class="p">(</span><span class="n">voxFrames</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">voxFrames</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Frames for voxel array reconstruction were not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">voxFrames</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">voxFrames</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="s">&#39;auto&#39;</span><span class="p">]:</span>
            <span class="k">pass</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">voxFrames</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">voxFrames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;One frame for voxel array reconstruction out of bounds&#39;</span><span class="p">)</span>
        
  
<span class="k">def</span> <span class="nf">checkVoxFramesBounds</span><span class="p">(</span><span class="n">voxFramesBounds</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">voxFramesBounds</span> <span class="o">&lt;&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">voxFramesBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">voxFramesBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Frame bounds for voxel array reconstruction lesser than 0 or bigger than </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">N</span><span class="p">)</span>
      
        
<span class="k">def</span> <span class="nf">checkTemporalCalibMethod</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Temporal calibration method was not set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;vert_motion_sync&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Temporal calibration method not supported&#39;</span><span class="p">)</span>

<span class="c"># Process class</span>


<div class="viewcode-block" id="Process"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process">[docs]</a><span class="k">class</span> <span class="nc">Process</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for performing: US probe calibration; calibration quality assessment; voxel-array reconstruction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Data source files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kineFiles</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># US images parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usFreq</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVectorAdj</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># Kinematics file properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kineFreq</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># US probe-to-lab attitube</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># Image-to-US probe attitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prRim</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tim</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># Calibration results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calib</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># Image-to-lab attitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># Lab-to-conv attitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="c"># Frames for voxel array reconstruction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span> <span class="o">=</span> <span class="s">&#39;auto&#39;</span>
        
        <span class="c"># Voxel array parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xl</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yl</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zl</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xo</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zo</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fx</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fy</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fz</span> <span class="o">=</span> <span class="mf">1.</span>
        
        <span class="c"># US images alignment parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapper</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alignFrames</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validKineFrames</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillVoxMethod</span> <span class="o">=</span> <span class="s">&#39;avg&#39;</span>
        
        <span class="c"># Voxel array data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contV</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usedV</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internalV</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># vtkImageData properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sx</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sy</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sz</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># Gaps filling parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksN</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blockDir</span> <span class="o">=</span> <span class="s">&#39;X&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxS</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distTh</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minPct</span> <span class="o">=</span> <span class="mf">0.</span>
        
        <span class="c"># Features extracted from US images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># Precisions container</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acc</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c"># Precisions container</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c"># Time delay between devices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeDelay</span> <span class="o">=</span> <span class="mf">0.</span>
        
        
    
<div class="viewcode-block" id="Process.setKineFiles"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setKineFiles">[docs]</a>    <span class="k">def</span> <span class="nf">setKineFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kineFiles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set kinematics files list.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kineFiles : list</span>
<span class="sd">            List of kinematics files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">checkKineFiles</span><span class="p">(</span><span class="n">kineFiles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kineFiles</span> <span class="o">=</span> <span class="n">kineFiles</span>
        
    </div>
<div class="viewcode-block" id="Process.getKineFiles"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getKineFiles">[docs]</a>    <span class="k">def</span> <span class="nf">getKineFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get kinematics files list.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of kinematics files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kineFiles</span>
    
</div>
<div class="viewcode-block" id="Process.setUSFiles"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setUSFiles">[docs]</a>    <span class="k">def</span> <span class="nf">setUSFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usFiles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set US files list.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        usFiles : list</span>
<span class="sd">            List of US files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">checkUsFiles</span><span class="p">(</span><span class="n">usFiles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span> <span class="o">=</span> <span class="n">usFiles</span>
        
    </div>
<div class="viewcode-block" id="Process.getUSFiles"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getUSFiles">[docs]</a>    <span class="k">def</span> <span class="nf">getUSFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get US files list.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of US files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span>
        
        </div>
<div class="viewcode-block" id="Process.setDataSourceProperties"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setDataSourceProperties">[docs]</a>    <span class="k">def</span> <span class="nf">setDataSourceProperties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set data source properties (for US and/or optoelectronic system).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kineFreq : int, optional</span>
<span class="sd">            Optoelectronic system frequency (in *Hz*).</span>
<span class="sd">        </span>
<span class="sd">        USFreq : int, optional</span>
<span class="sd">            US system frequency (in *Hz*).</span>
<span class="sd">        </span>
<span class="sd">        w : int, optional</span>
<span class="sd">            US image width (in *pixels*).</span>
<span class="sd">        </span>
<span class="sd">        h : int, optional</span>
<span class="sd">            US image height (in *pixels*).</span>
<span class="sd">        </span>
<span class="sd">        USTimeVector : list, optional</span>
<span class="sd">            List of time instants (in *s*) in which US frame were recorded.</span>
<span class="sd">            If multiple US files are provided in ``setUSFiles()``, the length </span>
<span class="sd">            of this parameter must be equal to the sum of the frame numbers for</span>
<span class="sd">            each US file.</span>
<span class="sd">        </span>
<span class="sd">        fromUSFiles : list, optional</span>
<span class="sd">            List DICOM file paths from which to extract US data properties.</span>
<span class="sd">            If specified, w, h, USTimeVector, USFreq provided as input will be </span>
<span class="sd">            ignored and will be parsed from these files</span>
<span class="sd">        </span>
<span class="sd">        pixel2mmX, pixel2mmY : float; optional</span>
<span class="sd">            Number of mm for each pixel in US image, for horizontal and </span>
<span class="sd">            vertical axis (in *mm/pixel*).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check kineFreq</span>
        <span class="k">if</span> <span class="s">&#39;kineFreq&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kineFreq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;kineFreq&#39;</span><span class="p">]</span>
            <span class="n">checkFreq</span><span class="p">(</span><span class="n">kineFreq</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kineFreq</span> <span class="o">=</span> <span class="n">kineFreq</span>
        
        <span class="c"># Check reading method</span>
        <span class="k">if</span> <span class="s">&#39;fromUSFiles&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            
            <span class="c"># Read US files</span>
            <span class="n">filePaths</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;fromUSFiles&#39;</span><span class="p">]</span>
            <span class="n">checkUsFiles</span><span class="p">(</span><span class="n">filePaths</span><span class="p">)</span>
            <span class="n">usTimeVector</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">usFreqPrev</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">filePaths</span><span class="p">)):</span>
                <span class="n">filePath</span> <span class="o">=</span> <span class="n">filePaths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">print</span> <span class="s">&#39;Getting US image properties from file {0}...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span>
                <span class="n">checkFilePath</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">readDICOM</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span>
                
                <span class="c"># Get w</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">Columns</span>
                <span class="n">checkImDim</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">wPrev</span> <span class="o">=</span> <span class="n">w</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;&gt;</span> <span class="n">wPrev</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;w changes across files&#39;</span><span class="p">)</span>
                
                <span class="c"># Get h</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">Rows</span>
                <span class="n">checkImDim</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">hPrev</span> <span class="o">=</span> <span class="n">h</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;&gt;</span> <span class="n">hPrev</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;h changes across files&#39;</span><span class="p">)</span>
                
                <span class="c"># Get USFreq</span>
                <span class="k">if</span> <span class="s">&#39;FrameTimeVector&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s">&#39;CineRate&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;If FrameTimeVector is not found, CineRate must be present&#39;</span><span class="p">)</span>
                    <span class="n">usFreq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">CineRate</span><span class="p">)</span>
                    <span class="n">checkFreq</span><span class="p">(</span><span class="n">usFreq</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">usFreqPrev</span> <span class="o">=</span> <span class="n">usFreq</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">usFreq</span> <span class="o">&lt;&gt;</span> <span class="n">usFreqPrev</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;USFreq changes across files&#39;</span><span class="p">)</span>
                
                <span class="c"># Get USTimeVector</span>
                <span class="k">if</span> <span class="s">&#39;FrameTimeVector&#39;</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                    <span class="n">usTimeVectorTemp</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">FrameTimeVector</span>
                    <span class="n">checkTimeVector</span><span class="p">(</span><span class="n">usTimeVectorTemp</span><span class="p">)</span>
                    <span class="k">print</span> <span class="s">&#39;FrameTimeVector found in file {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span>
                    <span class="n">usTimeVector</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">usTimeVectorTemp</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s">&#39;NumberOfFrames&#39;</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">NumberOfFrames</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">N</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">usFreq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">CineRate</span><span class="p">)</span>
                    <span class="n">usTimeVectorTemp</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">usFreq</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">print</span> <span class="s">&#39;FrameTimeVector not found in file {0}. It will be generate by using CineRate and the number of frames.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span>
                    <span class="n">usTimeVector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">usTimeVectorTemp</span><span class="p">)</span>
                
            
                <span class="k">del</span> <span class="n">D</span><span class="p">,</span> <span class="n">ds</span>
            
            <span class="c"># Get properties</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">wPrev</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">hPrev</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">usFreq</span> <span class="o">=</span> <span class="n">usFreqPrev</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span> <span class="o">=</span> <span class="n">usTimeVector</span>
            <span class="k">print</span> <span class="s">&#39;US image properties got from files&#39;</span>
        
        <span class="k">else</span><span class="p">:</span>
        
            <span class="c"># Check w</span>
            <span class="k">if</span> <span class="s">&#39;w&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;w&#39;</span><span class="p">]</span>
                <span class="n">checkImDim</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span>
                    
            <span class="c"># Check h</span>
            <span class="k">if</span> <span class="s">&#39;h&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
                <span class="n">checkImDim</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span>
            
            <span class="c"># Check USFreq</span>
            <span class="k">if</span> <span class="s">&#39;USFreq&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">usFreq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;USFreq&#39;</span><span class="p">]</span>
                <span class="n">checkFreq</span><span class="p">(</span><span class="n">usFreq</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">usFreq</span> <span class="o">=</span> <span class="n">usFreq</span>
            
            <span class="c"># Check USTimeVector</span>
            <span class="k">if</span> <span class="s">&#39;USTimeVector&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">usTimeVector</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;USTimeVector&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">usTimeVector</span><span class="p">:</span>
                    <span class="n">checkTimeVector</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span> <span class="o">=</span> <span class="n">usTimeVector</span>
        
        
        <span class="c"># Check pixel2mmX</span>
        <span class="k">if</span> <span class="s">&#39;pixel2mmX&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">pixel2mmX</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;pixel2mmX&#39;</span><span class="p">]</span>
            <span class="n">checkPixel2mm</span><span class="p">(</span><span class="n">pixel2mmX</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span> <span class="o">=</span> <span class="n">pixel2mmX</span>

        <span class="c"># Check pixel2mmY</span>
        <span class="k">if</span> <span class="s">&#39;pixel2mmY&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">pixel2mmY</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;pixel2mmY&#39;</span><span class="p">]</span>
            <span class="n">checkPixel2mm</span><span class="p">(</span><span class="n">pixel2mmY</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span> <span class="o">=</span> <span class="n">pixel2mmY</span>
            
        <span class="c"># Adjust USTimeVector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjustUSTimeVector</span><span class="p">()</span>
         
    </div>
<div class="viewcode-block" id="Process.calculatePoseForUSProbe"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.calculatePoseForUSProbe">[docs]</a>    <span class="k">def</span> <span class="nf">calculatePoseForUSProbe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mkrList</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;M1&#39;</span><span class="p">,</span><span class="s">&#39;M2&#39;</span><span class="p">,</span><span class="s">&#39;M3&#39;</span><span class="p">,</span><span class="s">&#39;M4&#39;</span><span class="p">],</span> <span class="n">USProbePoseFun</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="n">USProbePoseFunArgs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">globPoseFun</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">globPoseFunArgs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">showMarkers</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the attitude (or pose) of the marker-based US probe reference frame with respect to the global reference frame.</span>

<span class="sd">        .. note::</span>
<span class="sd">        </span>
<span class="sd">            In [Ref2]_, this is named :math:`^{T}T_{R}`.</span>
<span class="sd">        </span>
<span class="sd">        After extracting markers data from the kinematics files set with method ``setKineFiles()``, this data will</span>
<span class="sd">        be concatenated and resampled using ``USTimeVector``, if this one is available. Otherwise, kinematics data</span>
<span class="sd">        will be resampled based on optoelectronic system frequency and US system frequency. Only after kinematics and</span>
<span class="sd">        US data have a common time line, US probe attitude will be calculated.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mkrList : list</span>
<span class="sd">            List of marker names to be extracted from kinematics files. These will be used for</span>
<span class="sd">            creating the probe reference frame, and the global reference frame, if requested.</span>
<span class="sd">        </span>
<span class="sd">        USProbePoseFun : mixed</span>
<span class="sd">            Function defining the US probe reference frame. </span>
<span class="sd">            If function, it takes two input parameters. The first one is ``mkrList``, while the second one being</span>
<span class="sd">            a dictionary where the keys are marker names defined in ``mkrList``, and value are N x 3 Numpy arrays of </span>
<span class="sd">            3D coordinates (N is the number of time frames). The function must return a 2-elements list; the first one </span>
<span class="sd">            is a Numpy N x 3 x 3 rotation matrix from probe reference frame to laboratory reference frame; the second</span>
<span class="sd">            one is a N x 3 Numpy array representing 3D coordinates of US probe reference frame origin in laboratory </span>
<span class="sd">            reference frame. </span>
<span class="sd">            If string, it must be ``&#39;default&#39;``. In this case, the reference frame is defined as in the function </span>
<span class="sd">            ``kine.markersClusterFun()``.</span>
<span class="sd">        </span>
<span class="sd">        USProbePoseFunArgs : mixed</span>
<span class="sd">            Additional parameters passed to ``USProbePoseFun``.</span>
<span class="sd">        </span>
<span class="sd">        globPoseFunArgs : mixed</span>
<span class="sd">            Additional parameters passed to ``globPoseFunArgs``.</span>
<span class="sd">        </span>
<span class="sd">        globPoseFun : mixed</span>
<span class="sd">            Function defining the global reference frame.</span>
<span class="sd">            This function takes the same input arguments as the function ``USProbePoseFun``. It must return a 2-elements</span>
<span class="sd">            list; the first one is a Numpy N x 3 x 3 rotation matrix from global reference frame to laboratory reference </span>
<span class="sd">            frame; the second one is a N x 3 Numpy array representing 3D coordinates of the global reference frame origin</span>
<span class="sd">            in laboratory reference frame. </span>
<span class="sd">        </span>
<span class="sd">        showMarkers : bool</span>
<span class="sd">            If ``True``, show the marker data after resampling to US time line.    </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkMkrList</span><span class="p">(</span><span class="n">mkrList</span><span class="p">)</span>
        <span class="n">checkKineFiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kineFiles</span><span class="p">)</span>
        
        <span class="c"># Read kinematic files</span>
        <span class="n">fileNames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kineFiles</span>
        <span class="n">mkrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mkrList</span><span class="p">:</span>
            <span class="n">mkrs</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">Nf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fileNames</span><span class="p">)</span>
        <span class="n">timeLine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validKineFrames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fileNames</span><span class="p">)):</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="n">fileNames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">print</span> <span class="s">&#39;Reading C3D file {0} ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="n">markersData</span> <span class="o">=</span> <span class="n">readC3D</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;markers&#39;</span><span class="p">])[</span><span class="s">&#39;markers&#39;</span><span class="p">]</span>
            <span class="n">Nf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">markersData</span><span class="p">[</span><span class="n">mkrList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">newMkrs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mkrList</span><span class="p">:</span>
                <span class="n">newMkrs</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">markersData</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="k">print</span> <span class="s">&#39;{0} frames found&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Nf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            
            <span class="c"># Resample markers data</span>
            <span class="k">print</span> <span class="s">&#39;Resampling markers data to US time frame...&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span> <span class="o">&lt;&gt;</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kineFiles</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Number of kinematic files must be the same as the number of US time vectors&#39;</span><span class="p">)</span>
                <span class="n">checkTimeVector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">checkFreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kineFreq</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&#39;Kinematics data resampling will be based on US data time vector&#39;</span>
                <span class="n">resampleStep</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">currTimeVector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="n">currTimeVector</span><span class="p">:</span>
                    <span class="n">currTimeVector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">Nf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">currTimeVector</span><span class="p">))</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Impossible to resample kinematics data&#39;</span><span class="p">)</span>
            <span class="n">currUSTimeVector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usTimeVectorAdj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            
            <span class="n">newMkrsResampled</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mkrList</span><span class="p">:</span>
                <span class="n">newMkrsResampled</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">xInterpInd</span> <span class="o">=</span> <span class="n">resampleMarker</span><span class="p">(</span><span class="n">newMkrs</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">step</span><span class="o">=</span><span class="n">resampleStep</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">currUSTimeVector</span><span class="p">,</span> <span class="n">origFreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kineFreq</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&#39;Markers data resampled&#39;</span>
            
            <span class="c"># Get frame numbers for not extrapolated kine frames </span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Nprev</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Nprev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Nf</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validKineFrames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validKineFrames</span><span class="p">,</span> <span class="n">Nprev</span> <span class="o">+</span> <span class="n">xInterpInd</span><span class="p">)</span>
            
            <span class="c"># Append marker data</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mkrList</span><span class="p">:</span>
                <span class="n">mkrs</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">mkrs</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">newMkrsResampled</span><span class="p">[</span><span class="n">m</span><span class="p">]))</span>
                
            <span class="k">print</span> <span class="s">&#39;C3D file read&#39;</span>
        
        <span class="c"># Resampling markers data to US frequency</span>
        <span class="k">print</span> <span class="s">&#39;Frames number before resampling: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">Nf</span><span class="p">))</span>
        <span class="k">print</span> <span class="s">&#39;Frames number after resampling: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mkrs</span><span class="p">[</span><span class="n">mkrList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c"># Show markers on request        </span>
        <span class="k">if</span> <span class="n">showMarkers</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            
            <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="s">&#39;Y&#39;</span><span class="p">,</span> <span class="s">&#39;Z&#39;</span><span class="p">]</span>
            
            <span class="c"># Loop for each marker</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mkrList</span><span class="p">)):</span>
                
                <span class="n">mkrName</span> <span class="o">=</span> <span class="n">mkrList</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                <span class="n">mkrData</span> <span class="o">=</span> <span class="n">mkrs</span><span class="p">[</span><span class="n">mkrName</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">validKineFrames</span><span class="p">,:]</span>
                
                <span class="c"># Loop for each coordinate </span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)):</span>
                    
                    <span class="n">p</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mkrList</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>
                    <span class="n">timeLine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mkrData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">timeLine</span><span class="p">,</span> <span class="n">mkrData</span><span class="p">[:,</span><span class="n">c</span><span class="p">])</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> (</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mkrName</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;[mm]&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mkrList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Frames&#39;</span><span class="p">)</span>
                    
            <span class="c"># Show data</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c"># Calculate affine matrix from probe to laboratory reference frame</span>
        <span class="k">print</span> <span class="s">&#39;Calculating US probe roto-translation matrix for all time frames ...&#39;</span>
        <span class="k">if</span> <span class="n">USProbePoseFun</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">_USProbePoseFun</span> <span class="o">=</span> <span class="n">markersClusterFun</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_USProbePoseFun</span> <span class="o">=</span> <span class="n">USProbePoseFun</span>
        <span class="k">if</span> <span class="n">USProbePoseFunArgs</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">USProbePoseFun</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">Rpr</span><span class="p">,</span> <span class="n">Tpr</span> <span class="o">=</span> <span class="n">_USProbePoseFun</span><span class="p">(</span><span class="n">mkrs</span><span class="p">,</span> <span class="n">mkrList</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Rpr</span><span class="p">,</span> <span class="n">Tpr</span> <span class="o">=</span> <span class="n">_USProbePoseFun</span><span class="p">(</span><span class="n">mkrs</span><span class="p">,</span> <span class="n">mkrList</span><span class="p">,</span> <span class="n">USProbePoseFunArgs</span><span class="p">)</span>
        <span class="n">RprFull</span> <span class="o">=</span> <span class="n">composeRotoTranslMatrix</span><span class="p">(</span><span class="n">Rpr</span><span class="p">,</span> <span class="n">Tpr</span><span class="p">)</span>
               
        <span class="k">if</span> <span class="n">globPoseFun</span> <span class="o">&lt;&gt;</span> <span class="bp">None</span><span class="p">:</span>
            
            <span class="c"># Calculate affine matrix from global reference frame to laboratory reference frame</span>
            <span class="k">if</span> <span class="n">globPoseFunArgs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">Rgl</span><span class="p">,</span> <span class="n">Tgl</span> <span class="o">=</span> <span class="n">globPoseFun</span><span class="p">(</span><span class="n">mkrs</span><span class="p">,</span> <span class="n">mkrList</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Rgl</span><span class="p">,</span> <span class="n">Tgl</span> <span class="o">=</span> <span class="n">globPoseFun</span><span class="p">(</span><span class="n">mkrs</span><span class="p">,</span> <span class="n">mkrList</span><span class="p">,</span> <span class="n">globPoseFunArgs</span><span class="p">)</span>
            <span class="n">RglFull</span> <span class="o">=</span> <span class="n">composeRotoTranslMatrix</span><span class="p">(</span><span class="n">Rgl</span><span class="p">,</span> <span class="n">Tgl</span><span class="p">)</span>
            
            <span class="c"># Calculate affine matrix from probe reference frame to global reference frame</span>
            <span class="n">glRprFull</span> <span class="o">=</span> <span class="n">dot3</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">RglFull</span><span class="p">),</span> <span class="n">RprFull</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            
            <span class="n">glRprFull</span> <span class="o">=</span> <span class="n">RprFull</span>
        
        <span class="c"># Get back rotation matrix and translation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span> <span class="o">=</span> <span class="n">decomposeRotoTranslMatrix</span><span class="p">(</span><span class="n">glRprFull</span><span class="p">)</span>
        
        <span class="k">print</span> <span class="s">&#39;US probe roto-translation matrix calculated&#39;</span>
        
        
        </div>
<div class="viewcode-block" id="Process.calculatePoseForUSImages"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.calculatePoseForUSImages">[docs]</a>    <span class="k">def</span> <span class="nf">calculatePoseForUSImages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the pose of the US images with respect to the global reference frame.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">        </span>
<span class="sd">            In [Ref2]_, this is the product :math:`^{T}T_{R}\ ^{R}T_{P}`.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkIm2PrPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prRim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tim</span><span class="p">)</span>
        <span class="n">checkPr2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span><span class="p">)</span>
        
        <span class="k">print</span> <span class="s">&#39;Calculating US images roto-translation matrix for all time frames ...&#39;</span>        
        
        <span class="c"># Calculate rotation matrix for pixel to world</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prRim</span><span class="p">)</span> <span class="c"># N x 3 x 3</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tim</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span>
        
        <span class="c"># Create affine transformation matrix (N x 4 x 4)</span>
        <span class="n">Rfull</span> <span class="o">=</span> <span class="n">composeRotoTranslMatrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
        
        <span class="k">print</span> <span class="s">&#39;US images roto-translation matrix calculated&#39;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">Rfull</span>
        
        </div>
<div class="viewcode-block" id="Process.getPoseForUSImages"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getPoseForUSImages">[docs]</a>    <span class="k">def</span> <span class="nf">getPoseForUSImages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the pose of the US images with respect to the global reference frame.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            N x 4 x 4 pose, for N time frames.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>  
        
        <span class="c"># Check input validity</span>
        <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span>
        
        </div>
<div class="viewcode-block" id="Process.getImageCornersAs3DPoints"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getImageCornersAs3DPoints">[docs]</a>    <span class="k">def</span> <span class="nf">getImageCornersAs3DPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create virtual 3D points for US images corners with respect to the global reference frame.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary where keys are 4 marker names and values are np.ndarray</span>
<span class="sd">            N x 3 matrices, representing point coordinates, for N time frames.</span>
<span class="sd">            The following are the points created:</span>
<span class="sd">            </span>
<span class="sd">            - im_TR: top-right corner</span>
<span class="sd">            </span>
<span class="sd">            - im_BR: bottom-right corner</span>
<span class="sd">            </span>
<span class="sd">            - im_TL: top-left corner</span>
<span class="sd">            </span>
<span class="sd">            - im_BL: bottom-left corner</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>  
        
        <span class="c"># Check input validity</span>
        <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>    
    
        <span class="c"># Create virtual points for corners</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">createImageCorners</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
        <span class="n">pcg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span><span class="n">pc</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,:]</span>    <span class="c"># N x 3 x 4</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">points</span><span class="p">[</span><span class="s">&#39;im_TR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcg</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">points</span><span class="p">[</span><span class="s">&#39;im_BR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcg</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">points</span><span class="p">[</span><span class="s">&#39;im_TL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcg</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">points</span><span class="p">[</span><span class="s">&#39;im_BL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcg</span><span class="p">[:,:,</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">points</span>
        
    </div>
<div class="viewcode-block" id="Process.extractFeatureFromUSImages"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.extractFeatureFromUSImages">[docs]</a>    <span class="k">def</span> <span class="nf">extractFeatureFromUSImages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature</span><span class="o">=</span><span class="s">&#39;2_points_on_line&#39;</span><span class="p">,</span> <span class="n">segmentation</span><span class="o">=</span><span class="s">&#39;manual&#39;</span><span class="p">,</span> <span class="n">segParams</span><span class="o">=</span><span class="p">{},</span> <span class="n">showViewer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">featuresFile</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract features (points, lines, ...) from US images.</span>
<span class="sd">        </span>
<span class="sd">        The used file will be the one indicated in method ``setUSFiles()``.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        feature : str</span>
<span class="sd">            target feature type.</span>
<span class="sd">            If &#39;2_points_on_line&#39;, the features under consideration are 2 points on the longest edge line in the image.</span>
<span class="sd">            If &#39;2_points&#39;, the features under consideration are 2 manually defined points.</span>
<span class="sd">            If &#39;1_point&#39;, the feature under consideration is 1 manually defined point.</span>
<span class="sd">            If &#39;mask&#39;, the feature under consideration is a suset of pixels of the image.</span>
<span class="sd">        </span>
<span class="sd">        segmentation : str</span>
<span class="sd">            Segmentation method.</span>
<span class="sd">            If &#39;manual&#39;, an interactive window will be popped up and the user will be able to select manually the features image per image. </span>
<span class="sd">            If &#39;auto_hough&#39; (only for ``feature=&#39;2_points_on_line&#39;``), the longest line will be automatically detected by the Hough transform and 2 points will be place on that line according to ``segParams``.</span>
<span class="sd">        </span>
<span class="sd">        segParams : dict</span>
<span class="sd">            Parameters for features extraction.</span>
<span class="sd">            If ``segmentation=&#39;auto_hough&#39;``:</span>
<span class="sd">            - &#39;par_seg&#39;: see ``parSeg`` in ``SegmentPointsHoughUI.__init__()``.</span>
<span class="sd">            - &#39;data_constr&#39;: see ``dataConstr`` in ``SegmentPointsHoughUI.__init__()``.</span>
<span class="sd">            - &#39;save_data_path&#39;: see ``saveDataPath`` in ``SegmentPointsHoughUI.__init__()``.</span>
<span class="sd">            If ``segmentation=&#39;mask&#39;``, see ``maskParams`` in ``MaskImageUI.__init__()``.</span>
<span class="sd">        </span>
<span class="sd">        showViewer : bool</span>
<span class="sd">            If True, it pops up a viewer to show or edit the features.       </span>
<span class="sd">        </span>
<span class="sd">        featuresFile : mixed</span>
<span class="sd">            Features file path.</span>
<span class="sd">            If None, it will be ignored. Othwerwise, it must indicate the full path of a previously saved. This contains features data.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>                
        
        <span class="c"># Check input validity</span>
        <span class="n">checkFeature</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>
        <span class="n">checkSegmentation</span><span class="p">(</span><span class="n">segmentation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">featuresFile</span> <span class="o">&lt;&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">checkFilePath</span><span class="p">(</span><span class="n">featuresFile</span><span class="p">)</span>
        <span class="n">checkUsFiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c"># Load image if necessary</span>
        <span class="c">#if featuresFile == None:</span>
        <span class="c"># Read DICOM file</span>
        <span class="k">print</span> <span class="s">&#39;Reading DICOM file {0} ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">readDICOM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">pixelData2grey</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>   <span class="c"># supposing D is &quot;small&quot; and fits in memory</span>
        <span class="k">print</span> <span class="s">&#39;Number of frames: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span> <span class="s">&#39;DICOM file read&#39;</span>
        
        <span class="c"># Load features from file is requested</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">featuresFile</span> <span class="o">&lt;&gt;</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Loading features file...&#39;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">readFeaturesFile</span><span class="p">(</span><span class="n">featuresFile</span><span class="p">)</span>
           
        <span class="c"># Perform feature extraction</span>
        <span class="k">print</span> <span class="s">&#39;Extracting features...&#39;</span>
        <span class="k">if</span> <span class="n">feature</span> <span class="o">==</span> <span class="s">&#39;2_points_on_line&#39;</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;Click on 2 points on the border line&#39;</span>
            <span class="k">if</span> <span class="n">segmentation</span> <span class="o">==</span> <span class="s">&#39;manual&#39;</span><span class="p">:</span>
                <span class="n">ui</span> <span class="o">=</span> <span class="n">SegmentPointsUI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">segmentation</span> <span class="o">==</span> <span class="s">&#39;auto_hough&#39;</span><span class="p">:</span>
                <span class="n">parSeg</span> <span class="o">=</span> <span class="n">segParams</span><span class="p">[</span><span class="s">&#39;par_seg&#39;</span><span class="p">]</span>
                <span class="n">dataConstr</span> <span class="o">=</span> <span class="n">segParams</span><span class="p">[</span><span class="s">&#39;data_constr&#39;</span><span class="p">]</span>
                <span class="n">saveDataPath</span> <span class="o">=</span> <span class="n">segParams</span><span class="p">[</span><span class="s">&#39;save_data_path&#39;</span><span class="p">]</span>
                <span class="n">ui</span> <span class="o">=</span> <span class="n">SegmentPointsHoughUI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">parSeg</span><span class="p">,</span> <span class="n">dataConstr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">saveDataPath</span><span class="o">=</span><span class="n">saveDataPath</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">feature</span> <span class="o">==</span> <span class="s">&#39;2_points&#39;</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;Click on 2 points&#39;</span>
            <span class="k">if</span> <span class="n">segmentation</span> <span class="o">==</span> <span class="s">&#39;manual&#39;</span><span class="p">:</span>
                <span class="n">ui</span> <span class="o">=</span> <span class="n">SegmentPointsUI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">feature</span> <span class="o">==</span> <span class="s">&#39;1_point&#39;</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;Click on 1 point&#39;</span>
            <span class="k">if</span> <span class="n">segmentation</span> <span class="o">==</span> <span class="s">&#39;manual&#39;</span><span class="p">:</span>
                <span class="n">ui</span> <span class="o">=</span> <span class="n">SegmentPointsUI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">feature</span> <span class="o">==</span> <span class="s">&#39;mask&#39;</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;Select a mask&#39;</span>
            <span class="n">ui</span> <span class="o">=</span> <span class="n">MaskImageUI</span><span class="p">(</span><span class="n">segParams</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="c"># Show viewer if requested</span>
        <span class="k">if</span> <span class="n">showViewer</span><span class="p">:</span>
            <span class="n">ui</span><span class="o">.</span><span class="n">showViewer</span><span class="p">()</span>
        <span class="n">ui</span><span class="o">.</span><span class="n">closeViewer</span><span class="p">()</span>
        
        <span class="c"># Get features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span>
            
        <span class="k">print</span> <span class="s">&#39;Features extracted&#39;</span>
    
</div>
<div class="viewcode-block" id="Process.calibrateProbe"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.calibrateProbe">[docs]</a>    <span class="k">def</span> <span class="nf">calibrateProbe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;eq_based&#39;</span><span class="p">,</span> <span class="n">method_args</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;phantom&#39;</span><span class="p">:</span><span class="s">&#39;single_wall&#39;</span><span class="p">,</span><span class="s">&#39;regularize_J&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">},</span> <span class="n">fixed</span><span class="o">=</span><span class="p">[],</span> <span class="n">correctResults</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the attitude (or pose) of the US images with respect to the probe reference frame.        </span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">        </span>
<span class="sd">            In [Ref2]_, this is named :math:`^{R}T_{P}`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        init : dict</span>
<span class="sd">            Dictionary containing initial values for the calibration algorithm (see [Ref2]_, Table 1).</span>
<span class="sd">            Keys must belong to this list:</span>
<span class="sd">            </span>
<span class="sd">            - sx, sy: number of mm for each pixel in US image, for horizontal and vertical axis (in *mm/pixel*)</span>
<span class="sd">            - x1, y1, z1: coordinates (in *mm*) of vector pointing from US probe reference frame origin to the US image reference frame origin.</span>
<span class="sd">            - gamma1, beta1, alpha1: rotation angles (in *rad*) representing consecutive rotations around the US image reference frame axis (X, Y and Z). This rotations would get it oriented as the US probe reference frame (see `here &lt;http://kwon3d.com/theory/euler/euler_angles.html&gt;`_ for more details). Use opposite sign with respect to the `right-hand rule &lt;http://en.wikipedia.org/wiki/Right-hand_rule&gt;`_</span>
<span class="sd">            - x2, y2, z2: coordinates (in *mm*) of vector pointing from global reference frame origin to the calibration phantom reference frame origin.</span>
<span class="sd">            - gamma2, beta2, alpha2: same meaning as gamma1, beta1, alpha1, but now the rotations are from global reference frame to probe reference frame.</span>
<span class="sd">    </span>
<span class="sd">            If ``method=&#39;eq_based&#39;``, only the following variables have to be present: &#39;sx&#39;, &#39;sy&#39;, &#39;x1&#39;, &#39;y1&#39;, &#39;z1&#39;, &#39;alpha1&#39;, &#39;beta1&#39;, &#39;gamma1&#39;, &#39;x2&#39;, &#39;y2&#39;, &#39;z2&#39;, &#39;alpha2&#39;, &#39;beta2&#39;, &#39;gamma2&#39;.</span>
<span class="sd">            If ``method=&#39;maximize_NCCint&#39;`` or ``&#39;maximize_NCC&#39;``, only the following variables have to be present: &#39;x1&#39;, &#39;y1&#39;, &#39;z1&#39;, &#39;alpha1&#39;, &#39;beta1&#39;, &#39;gamma1&#39;.</span>

<span class="sd">        xtol : float</span>
<span class="sd">            Relative error desired in the approximate solution (see argument ``options[&#39;xtol&#39;]`` or ``tol`` in ``scipy.optimize.root()``).</span>
<span class="sd">        </span>
<span class="sd">        ftol : float</span>
<span class="sd">            Relative error desired in the sum of squares (see argument ``options[&#39;ftol&#39;]`` in ``scipy.optimize.root()``).</span>

<span class="sd">        method : str</span>
<span class="sd">            Method used to estimate calibration parameters.</span>
<span class="sd">            If &#39;eq_based&#39;, a system of equations (representing contraints) will be solved (see [Ref2]_).</span>
<span class="sd">            If &#39;maximize_NCCint&#39;, the algorithm used is a modification of the one described in [Ref3]_. It aims at maximizing the average Normalized Cross-Correlation of the intersection of pair of US images.</span>
<span class="sd">            If &#39;maximize_NCC&#39; or &#39;maximize_NCCfast&#39;, the algorithm used is described in [Ref3]_.   </span>
<span class="sd">        </span>
<span class="sd">        method_args : dict</span>
<span class="sd">            Further arguments for method used.</span>
<span class="sd">            If ``method=&#39;eq_based&#39;``, it must contain the following keys:</span>
<span class="sd">            </span>
<span class="sd">            - &#39;phantom&#39;: calibration phantom type (see [Ref2]_). </span>
<span class="sd">            If &#39;single_wall&#39;, the calibration equations system is solved by using formula 8 in [Ref2]_. Variables x2, y2, alpha2 will be forced to 0.</span>
<span class="sd">            </span>
<span class="sd">            If ``method=&#39;maximize_NCCint&#39;``, it must contain the following keys:</span>
<span class="sd">            </span>
<span class="sd">            - &#39;frames&#39;: If &#39;all_combos_in&#39;, then all the frames combinations in a interval will be used. If list, each element must be a list of 2 elements, representing a frames combination for NCC calculation.</span>
<span class="sd">            </span>
<span class="sd">            - &#39;frames_interval&#39;: see &#39;frames&#39;.</span>
<span class="sd">            </span>
<span class="sd">            NCC values, each one related to a couple of frames, will be averaged.</span>
<span class="sd">    </span>
<span class="sd">            If ``method=&#39;maximize_NCC&#39;`` or ``method=&#39;maximize_NCCfast&#39;``, it must contain the following keys:</span>
<span class="sd">            </span>
<span class="sd">            - &#39;sweep_frames&#39;: 2-elem list where the first element is a list of original images sweep frames and the second element is a 2-elem list defining start and end frame of the reconstruction sweep. </span>
<span class="sd">            </span>
<span class="sd">            - &#39;imag_comp_save_path&#39;: if not empty, it will be used to save each the couple original image - reconstruction for each iteration. </span>
<span class="sd">            Each file name is in the format it&lt;itn&gt;_im&lt;ofn&gt;.jpeg, where &lt;itn&gt; is the iteration number (for Nelder-Mead method), &lt;ofn&gt; is the original image frame number.</span>
<span class="sd">            </span>
<span class="sd">            - &#39;max_expr&#39;: expression to maximize.</span>
<span class="sd">            If &#39;avg_NCC&#39;, the NCCs calculated for each wanted pair original frame vs reconstruction template will be averaged.</span>
<span class="sd">            If &#39;weighted_avg_NCC&#39;, the NCCs calculated for each wanted pair original frame vs reconstruction template will be averaged using as weigths the percentage of reconstructed template.</span>
<span class="sd">            This percentage, in the bottom-left picture in the figures saved in &#39;imag_comp_save_path&#39;, corresponds to the ratio between the area occupied by the straight lines and the image size.</span>
<span class="sd">            </span>
<span class="sd">            Common parameters for all NCC-based methods:</span>
<span class="sd">    </span>
<span class="sd">            - &#39;th_z&#39;: threshold value (in *mm*) under which points on a reconstruction sweep can be considered belonging to an original image plane.</span>
<span class="sd">            </span>
<span class="sd">            NCC values, each one related to one frame from the first sweep and the reconstruction sweep, will be averaged.</span>
<span class="sd">        </span>
<span class="sd">        fixed : list</span>
<span class="sd">            List of variable name for which the value is exactly known.</span>
<span class="sd">            These variables become constant in the calibration equations. For the list of allowed names, see argument ``init``.</span>
<span class="sd">        </span>
<span class="sd">        correctResults : bool</span>
<span class="sd">            Correct for mirror solutions.</span>
<span class="sd">            According to the Appendix of [Ref2]_, calculated variables could bring to &#39;mirror solutions&#39;. This flag will bring them to a standard form.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity </span>
        <span class="n">checkCalibMethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;eq_based&#39;</span><span class="p">:</span>
            <span class="n">phantom</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="s">&#39;phantom&#39;</span><span class="p">]</span>
            <span class="n">checkPhantom</span><span class="p">(</span><span class="n">phantom</span><span class="p">)</span>
            <span class="n">checkFeatures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;maximize_NCCint&#39;</span><span class="p">,</span> <span class="s">&#39;maximize_NCC&#39;</span><span class="p">,</span> <span class="s">&#39;maximize_NCCfast&#39;</span><span class="p">]:</span>
            <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
            <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
            <span class="n">checkUsFiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">checkPr2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span><span class="p">)</span>
        
        <span class="c"># Create expressions</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;eq_based&#39;</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Creating calibration equations...&#39;</span>
            <span class="n">eq</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">prTi</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">allVariables</span><span class="p">,</span> <span class="n">mus</span> <span class="o">=</span> <span class="n">createCalibEquations</span><span class="p">()</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="n">allVariables</span><span class="p">[:]</span>
            <span class="k">print</span> <span class="s">&#39;Equations defined&#39;</span>
                
            <span class="c"># Set to 0 some variables depending on phantom</span>
            <span class="k">if</span> <span class="n">phantom</span> <span class="o">==</span> <span class="s">&#39;single_wall&#39;</span><span class="p">:</span>
                <span class="c"># Select equation</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>    <span class="c"># select 3rd equation</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>      <span class="c"># select 3d equation</span>
                <span class="n">J</span><span class="o">.</span><span class="n">col_del</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>    <span class="c"># delete derivatives for x2</span>
                <span class="n">J</span><span class="o">.</span><span class="n">col_del</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>    <span class="c"># delete derivatives for y2</span>
                <span class="n">J</span><span class="o">.</span><span class="n">col_del</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>    <span class="c"># delete derivatives for alpha2</span>
                <span class="c"># Set to 0 some variables</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">syms</span><span class="p">[</span><span class="s">&#39;x2&#39;</span><span class="p">],</span><span class="mi">0</span><span class="p">),(</span><span class="n">syms</span><span class="p">[</span><span class="s">&#39;y2&#39;</span><span class="p">],</span><span class="mi">0</span><span class="p">),(</span><span class="n">syms</span><span class="p">[</span><span class="s">&#39;alpha2&#39;</span><span class="p">],</span><span class="mi">0</span><span class="p">)])</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">syms</span><span class="p">[</span><span class="s">&#39;x2&#39;</span><span class="p">],</span><span class="mi">0</span><span class="p">),(</span><span class="n">syms</span><span class="p">[</span><span class="s">&#39;y2&#39;</span><span class="p">],</span><span class="mi">0</span><span class="p">),(</span><span class="n">syms</span><span class="p">[</span><span class="s">&#39;alpha2&#39;</span><span class="p">],</span><span class="mi">0</span><span class="p">)])</span>
                <span class="k">del</span> <span class="n">syms</span><span class="p">[</span><span class="s">&#39;x2&#39;</span><span class="p">],</span> <span class="n">syms</span><span class="p">[</span><span class="s">&#39;y2&#39;</span><span class="p">],</span> <span class="n">syms</span><span class="p">[</span><span class="s">&#39;alpha2&#39;</span><span class="p">]</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&#39;x2&#39;</span><span class="p">)</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&#39;y2&#39;</span><span class="p">)</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&#39;alpha2&#39;</span><span class="p">)</span>
                <span class="c"># Delete unwanted variables</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fixed</span><span class="p">:</span>
                    <span class="n">J</span><span class="o">.</span><span class="n">col_del</span><span class="p">(</span><span class="n">variables</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">syms</span><span class="p">[</span><span class="n">f</span><span class="p">],</span><span class="n">init</span><span class="p">[</span><span class="n">f</span><span class="p">])])</span>
                    <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">syms</span><span class="p">[</span><span class="n">f</span><span class="p">],</span><span class="n">init</span><span class="p">[</span><span class="n">f</span><span class="p">])])</span>
                    <span class="k">del</span> <span class="n">syms</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
                    <span class="n">variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;maximize_NCCint&#39;</span><span class="p">,</span> <span class="s">&#39;maximize_NCC&#39;</span><span class="p">,</span> <span class="s">&#39;maximize_NCCfast&#39;</span><span class="p">]:</span>
            <span class="n">i2Ti1</span><span class="p">,</span> <span class="n">prTi</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">allVariables</span><span class="p">,</span> <span class="n">mus</span> <span class="o">=</span> <span class="n">createCalibExpressionsForMaxNCC</span><span class="p">()</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="n">allVariables</span><span class="p">[:]</span>
            <span class="c"># Delete unwanted variables</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fixed</span><span class="p">:</span>
                <span class="n">i2Ti1</span> <span class="o">=</span> <span class="n">i2Ti1</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">syms</span><span class="p">[</span><span class="n">f</span><span class="p">],</span><span class="n">init</span><span class="p">[</span><span class="n">f</span><span class="p">])])</span>
                <span class="k">del</span> <span class="n">syms</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            
        <span class="c"># Check variables init values</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">variables</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Some variables were not initialized&#39;</span><span class="p">)</span>
        <span class="n">initValues</span> <span class="o">=</span> <span class="p">[</span><span class="n">init</span><span class="p">[</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">))]</span>
                
        <span class="c"># Solve the equations</span>
        <span class="k">print</span> <span class="s">&#39;List of variables: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;List of initial values: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">initValues</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;Solving calibration...&#39;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;eq_based&#39;</span><span class="p">:</span>
            <span class="n">regJ</span> <span class="o">=</span> <span class="n">frames</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="s">&#39;regularize_J&#39;</span><span class="p">]</span>
            <span class="n">sol</span><span class="p">,</span> <span class="n">kond</span> <span class="o">=</span> <span class="n">solveCalibEquations</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">initValues</span><span class="p">,</span> <span class="n">xtol</span><span class="p">,</span> <span class="n">ftol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">regJ</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;maximize_NCCint&#39;</span><span class="p">,</span><span class="s">&#39;maximize_NCC&#39;</span><span class="p">,</span><span class="s">&#39;maximize_NCCfast&#39;</span><span class="p">]:</span>
            <span class="c"># Read DICOM file</span>
            <span class="n">D</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">readDICOM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">pixelData2grey</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;maximize_NCCint&#39;</span><span class="p">:</span>
                <span class="c"># Create frames couples</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="s">&#39;frames&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">frames</span> <span class="o">==</span> <span class="s">&#39;all_combos_in&#39;</span><span class="p">:</span>
                    <span class="n">framesInt</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="s">&#39;frames_interval&#39;</span><span class="p">]</span>
                    <span class="n">comb</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">framesInt</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">co</span> <span class="k">for</span> <span class="n">co</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">]</span>
                <span class="c"># Run calibration</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">maximizeNCCint</span><span class="p">(</span><span class="n">i2Ti1</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">initValues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">,</span> <span class="n">frames</span><span class="p">)</span>
                <span class="n">kond</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;maximize_NCC&#39;</span><span class="p">,</span> <span class="s">&#39;maximize_NCCfast&#39;</span><span class="p">]:</span>
                <span class="c"># Get options</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="s">&#39;sweep_frames&#39;</span><span class="p">]</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="s">&#39;imag_comp_save_path&#39;</span><span class="p">]</span>
                <span class="n">thZ</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="s">&#39;th_z&#39;</span><span class="p">]</span>
                <span class="n">maxExpr</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="s">&#39;max_expr&#39;</span><span class="p">]</span>
                <span class="c"># Get mask, if existing</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">No</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">No</span><span class="p">,</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">No</span><span class="p">):</span>
                        <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
                <span class="c"># Run calibration</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;maximize_NCC&#39;</span><span class="p">:</span>
                    <span class="n">NCCfunction</span> <span class="o">=</span> <span class="n">maximizeNCC</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">NCCfunction</span> <span class="o">=</span> <span class="n">maximizeNCCcy</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">NCCfunction</span><span class="p">(</span><span class="n">i2Ti1</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">initValues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">thZ</span><span class="p">,</span> <span class="n">maxExpr</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">kond</span> <span class="o">=</span> <span class="mi">0</span>                
        <span class="k">print</span> <span class="s">&#39;Iterations terminated ({0})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">sol</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="c"># Show conditioning number</span>
            <span class="k">print</span> <span class="s">&#39;Condition number: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">kond</span>
            <span class="c"># Create solution dictionary</span>
            <span class="k">print</span> <span class="s">&#39;Calibration succesfully solved&#39;</span> 
            <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">allVariables</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">variables</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">init</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">init</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="c"># Correct results if wanted</span>
            <span class="k">if</span> <span class="n">correctResults</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;eq_based&#39;</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;Correcting results...&#39;</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;alpha1&#39;</span><span class="p">,</span> <span class="s">&#39;beta1&#39;</span><span class="p">,</span> <span class="s">&#39;gamma1&#39;</span><span class="p">,</span> <span class="s">&#39;alpha2&#39;</span><span class="p">,</span> <span class="s">&#39;beta2&#39;</span><span class="p">,</span> <span class="s">&#39;gamma2&#39;</span><span class="p">]:</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">setInsideRange</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">setInsideRange</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s">&#39;beta1&#39;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;beta1&#39;</span><span class="p">]:</span>
                        <span class="n">x</span><span class="p">[</span><span class="s">&#39;beta1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                        <span class="n">x</span><span class="p">[</span><span class="s">&#39;alpha1&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                        <span class="n">x</span><span class="p">[</span><span class="s">&#39;gamma1&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;sy&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">[</span><span class="s">&#39;gamma1&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                        <span class="n">x</span><span class="p">[</span><span class="s">&#39;sy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="s">&#39;sy&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;sx&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">[</span><span class="s">&#39;alpha1&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                        <span class="n">x</span><span class="p">[</span><span class="s">&#39;beta1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="s">&#39;beta1&#39;</span><span class="p">]</span>
                        <span class="n">x</span><span class="p">[</span><span class="s">&#39;gamma1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;gamma1&#39;</span><span class="p">]</span>
                        <span class="n">x</span><span class="p">[</span><span class="s">&#39;sx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="s">&#39;sx&#39;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;alpha1&#39;</span><span class="p">,</span> <span class="s">&#39;gamma1&#39;</span><span class="p">,</span> <span class="s">&#39;alpha2&#39;</span><span class="p">,</span> <span class="s">&#39;gamma2&#39;</span><span class="p">]:</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">setInsideRange</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="k">print</span> <span class="s">&#39;Results corrected&#39;</span>
            <span class="c"># Calculate image-to-probe attitude</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">subs</span><span class="p">[</span><span class="s">&#39;x1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;x1&#39;</span><span class="p">]</span>
            <span class="n">subs</span><span class="p">[</span><span class="s">&#39;y1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;y1&#39;</span><span class="p">]</span>
            <span class="n">subs</span><span class="p">[</span><span class="s">&#39;z1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;z1&#39;</span><span class="p">]</span>
            <span class="n">subs</span><span class="p">[</span><span class="s">&#39;alpha1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;alpha1&#39;</span><span class="p">]</span>
            <span class="n">subs</span><span class="p">[</span><span class="s">&#39;beta1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;beta1&#39;</span><span class="p">]</span>
            <span class="n">subs</span><span class="p">[</span><span class="s">&#39;gamma1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;gamma1&#39;</span><span class="p">]</span>
            <span class="n">prTi</span> <span class="o">=</span> <span class="n">prTi</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="n">subs</span><span class="p">)</span>
            <span class="n">prTi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prTi</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="n">prRim</span> <span class="o">=</span> <span class="n">prTi</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">Tim</span> <span class="o">=</span> <span class="n">prTi</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c"># Extract pixem2mm values</span>
            <span class="k">if</span> <span class="s">&#39;sx&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">sx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;sx&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span>
            <span class="k">if</span> <span class="s">&#39;sy&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">sy</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;sy&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span>
            <span class="c"># Print results </span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">allVariables</span><span class="p">,</span> <span class="n">mus</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">mu</span> <span class="o">==</span> <span class="s">&#39;rad&#39;</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="s">&#39;deg&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">print</span> <span class="n">v</span> <span class="o">+</span> <span class="p">(</span><span class="s">&#39;: </span><span class="si">%f</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="n">mu</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;System not succesfully solved&#39;</span> <span class="p">)</span>

        <span class="c"># Set data internally</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prRim</span> <span class="o">=</span> <span class="n">prRim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tim</span> <span class="o">=</span> <span class="n">Tim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span> <span class="o">=</span> <span class="n">sx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span> <span class="o">=</span> <span class="n">sy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calib</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calib</span><span class="p">[</span><span class="s">&#39;root_sol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calib</span><span class="p">[</span><span class="s">&#39;root_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;eq_based&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calib</span><span class="p">[</span><span class="s">&#39;RMS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calib</span><span class="p">[</span><span class="s">&#39;RMS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calib</span><span class="p">[</span><span class="s">&#39;kond&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kond</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;eq_based&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calib</span><span class="p">[</span><span class="s">&#39;cov_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">cov_x</span> <span class="o">*</span> <span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calib</span><span class="p">[</span><span class="s">&#39;cov_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    
    </div>
<div class="viewcode-block" id="Process.getProbeCalibrationData"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getProbeCalibrationData">[docs]</a>    <span class="k">def</span> <span class="nf">getProbeCalibrationData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get calibration results.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        prRim : np.ndarray</span>
<span class="sd">            3 x 3 rotation matrix from US image reference frame to probe reference frame.</span>
<span class="sd">        </span>
<span class="sd">        Tim : np.ndarray</span>
<span class="sd">            3-elem vector (in *mm*), expressed in probe reference frame, from probe reference frame origin to US image reference frame origin.</span>
<span class="sd">        </span>
<span class="sd">        sx, sy : float</span>
<span class="sd">            See method ``calibrateProbe()``.</span>
<span class="sd">        </span>
<span class="sd">        calib : dict</span>
<span class="sd">            Dictionary with the following fields:</span>
<span class="sd">        </span>
<span class="sd">                - root_sol (*Result*)  contains output from ``scipy.optimize.root()``.</span>
<span class="sd">                </span>
<span class="sd">                - root_vars (*list*)  contains variables names (see argument ``init`` for argument ``calibrateProbe()``).</span>
<span class="sd">                </span>
<span class="sd">                - RMS (*float*)  RMS of the equations residuals (only for ``method=&#39;eq_based&#39;`` in ``calibrateProbe()``)</span>
<span class="sd">                </span>
<span class="sd">                - kond (*int*)  Condition number calculated as the ratio between max and min eigenvalues from the SVD decomposition of *Jacobian* matrix calculated in the solution point (only for ``method=&#39;eq_based&#39;`` in ``calibrateProbe()``).</span>
<span class="sd">                </span>
<span class="sd">                - cov_x (*np.ndarray*)  covariance matrix differing from calib[&#39;root_sol&#39;].cov_x for a multiplying factor being sum of squared residuals divided by degrees of freedom (only for ``method=&#39;eq_based&#39;`` in ``calibrateProbe()``).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prRim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calib</span>

</div>
<div class="viewcode-block" id="Process.setProbeCalibrationData"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setProbeCalibrationData">[docs]</a>    <span class="k">def</span> <span class="nf">setProbeCalibrationData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prRim</span><span class="p">,</span> <span class="n">Tim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set probe calibration data.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prRim : np.ndarray</span>
<span class="sd">            See method ``getProbeCalibrationData()``.</span>
<span class="sd">        Tim : np.ndarray</span>
<span class="sd">            See method ``getProbeCalibrationData()``.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkIm2PrPose</span><span class="p">(</span><span class="n">prRim</span><span class="p">,</span> <span class="n">Tim</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">prRim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tim</span> <span class="o">=</span> <span class="n">prRim</span><span class="p">,</span> <span class="n">Tim</span>
        
    </div>
<div class="viewcode-block" id="Process.evalCalibMatrix"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.evalCalibMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">evalCalibMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;*(static)* Evaluate calibration matrix with parameters values.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : dict</span>
<span class="sd">            See param ``init`` for function ``calibrateProbe()``. Only the following keys will be used: alpha1, beta1, gamma1, x1, y1, z1.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        prRim : np.ndarray </span>
<span class="sd">            3 x 3 rotation matrix from US image reference frame to probe reference frame.</span>
<span class="sd">        </span>
<span class="sd">        Tim : np.ndarray</span>
<span class="sd">            3-elem vector (in *mm*), expressed in probe reference frame, from probe reference frame origin to US image reference frame origin.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Get calibration matrix expression</span>
        <span class="n">prTi</span><span class="p">,</span> <span class="n">syms</span> <span class="o">=</span> <span class="n">creatCalibMatrix</span><span class="p">()</span>
        
        <span class="c"># Evaluate the expression</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">subs</span><span class="p">[</span><span class="s">&#39;x1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;x1&#39;</span><span class="p">]</span>
        <span class="n">subs</span><span class="p">[</span><span class="s">&#39;y1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;y1&#39;</span><span class="p">]</span>
        <span class="n">subs</span><span class="p">[</span><span class="s">&#39;z1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;z1&#39;</span><span class="p">]</span>
        <span class="n">subs</span><span class="p">[</span><span class="s">&#39;alpha1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;alpha1&#39;</span><span class="p">]</span>
        <span class="n">subs</span><span class="p">[</span><span class="s">&#39;beta1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;beta1&#39;</span><span class="p">]</span>
        <span class="n">subs</span><span class="p">[</span><span class="s">&#39;gamma1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;gamma1&#39;</span><span class="p">]</span>
        <span class="n">prTi</span> <span class="o">=</span> <span class="n">prTi</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="n">subs</span><span class="p">)</span>
        <span class="n">prTi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prTi</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        
        <span class="c"># Get attitude and translation</span>
        <span class="n">prRim</span> <span class="o">=</span> <span class="n">prTi</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">Tim</span> <span class="o">=</span> <span class="n">prTi</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">prRim</span><span class="p">,</span> <span class="n">Tim</span>
        
        
        </div>
<div class="viewcode-block" id="Process.setValidFramesForVoxelArray"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setValidFramesForVoxelArray">[docs]</a>    <span class="k">def</span> <span class="nf">setValidFramesForVoxelArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">voxFrames</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span> <span class="n">voxFramesBounds</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the list of frames (US time line) of the images that can be contained in the voxel array.</span>
<span class="sd">        Frames are further filtered out based on the invalid kinematics frames calculated </span>
<span class="sd">        by ``calculatePoseForUSProbe()``.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        voxFrames : mixed</span>
<span class="sd">            List of US time frames.</span>
<span class="sd">            If &#39;auto&#39;, all the frames without missing optoelectronic data information will be considered.       </span>
<span class="sd">            If &#39;all&#39;, all the frames will be considered.</span>
<span class="sd">            If list, it must contain the list of frames to be considered.</span>
<span class="sd">        </span>
<span class="sd">        voxFramesBounds : mixed</span>
<span class="sd">            Bounding frames for the list of frames to be contained in the voxel array.</span>
<span class="sd">            If None, all the frames out of ``voxFrames`` will be used.</span>
<span class="sd">            If list, it must contain 2 elements specifying lower and upper bround frames for the list in ``voxFrames``.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">checkVoxFrames</span><span class="p">(</span><span class="n">voxFrames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">checkVoxFramesBounds</span><span class="p">(</span><span class="n">voxFramesBounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c"># Create voxel frames indices </span>
        <span class="k">if</span> <span class="n">voxFrames</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">voxFrames</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">voxFrames</span> <span class="o">==</span> <span class="s">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">voxFrames</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">))[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
        <span class="c"># Creae voxel frames bounds if not existing</span>
        <span class="k">if</span> <span class="n">voxFramesBounds</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">voxFramesBounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c"># Limit voxel frames to bounds</span>
        <span class="n">voxFrames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">voxFrames</span><span class="p">)</span>
        <span class="n">voxFrames</span> <span class="o">=</span> <span class="n">voxFrames</span><span class="p">[(</span><span class="n">voxFrames</span> <span class="o">&gt;=</span> <span class="n">voxFramesBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">voxFrames</span> <span class="o">&lt;=</span> <span class="n">voxFramesBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        
        <span class="c"># Intersect with the valid kinematics frames</span>
        <span class="n">voxFrames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">voxFrames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">validKineFrames</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span> <span class="o">=</span> <span class="n">voxFrames</span>
        
        </div>
<div class="viewcode-block" id="Process.calculateConvPose"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.calculateConvPose">[docs]</a>    <span class="k">def</span> <span class="nf">calculateConvPose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convR</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate roto-translation matrix from global reference frame to *convenient* reference frame.</span>
<span class="sd">        Voxel-array dimensions are calculated in this new refence frame. This rotation is important whenever the US scans sihouette is remarkably</span>
<span class="sd">        oblique to some axis of the global reference frame. In this case, the voxel-array dimensions (calculated by the smallest parallelepipedon </span>
<span class="sd">        wrapping all the realigned scans), calculated in the global refrence frame, would not be optimal, i.e. larger than necessary.</span>
<span class="sd">        </span>
<span class="sd">        .. image:: diag_scan_direction.png</span>
<span class="sd">           :scale: 30 %          </span>
<span class="sd">          </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        convR : mixed</span>
<span class="sd">            Roto-translation matrix.</span>
<span class="sd">            If str, it specifies the method for automatically calculate the matrix.</span>
<span class="sd">            If &#39;auto_PCA&#39;, PCA is performed on all US image corners. The x, y and z of the new convenient reference frame are represented by the eigenvectors out of the PCA.</span>
<span class="sd">            If &#39;first_last_frames_centroid&#39;, the convenent reference frame is expressed as:</span>
<span class="sd">            - x from first image centroid to last image centroid</span>
<span class="sd">            - z orthogonal to x and the axis and the vector joining the top-left corner to the top-right corner of the first image</span>
<span class="sd">            - y orthogonal to z and x</span>
<span class="sd">            If np.ndarray, it must be manually specified as a 4 x 4 affine matrix.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">checkVoxFrames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">checkGl2ConvPose</span><span class="p">(</span><span class="n">convR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convR</span> <span class="o">=</span> <span class="n">convR</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>    
    
        <span class="c"># Calculating best pose automatically, if necessary</span>
        <span class="n">ivx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">)</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">createImageCorners</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">convR</span> <span class="o">==</span> <span class="s">&#39;auto_PCA&#39;</span><span class="p">:</span>
            <span class="c"># Perform PCA on image corners</span>
            <span class="k">print</span> <span class="s">&#39;Performing PCA on images corners...&#39;</span>
            <span class="n">pcg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">ivx</span><span class="p">,:,:],</span><span class="n">pc</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,:]</span>    <span class="c"># N x 3 x 4</span>
            <span class="n">pcg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pcg</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">*</span><span class="n">ivx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">pca</span><span class="p">(</span><span class="n">pcg</span><span class="p">)</span>
            <span class="c"># Build convenience affine matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">U</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)))),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">print</span> <span class="s">&#39;PCA perfomed&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">convR</span> <span class="o">==</span> <span class="s">&#39;first_last_frames_centroid&#39;</span><span class="p">:</span>
            <span class="c"># Search connection from first image centroid to last image centroid (X)</span>
            <span class="k">print</span> <span class="s">&#39;Performing convenient reference frame calculation based on first and last image centroids...&#39;</span>
            <span class="n">pcg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">ivx</span><span class="p">,:,:],</span><span class="n">pc</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,:]</span>   <span class="c"># N x 3 x 4</span>
            <span class="n">C0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pcg</span><span class="p">[</span><span class="n">ivx</span><span class="o">.</span><span class="n">min</span><span class="p">(),:,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># 3</span>
            <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pcg</span><span class="p">[</span><span class="n">ivx</span><span class="o">.</span><span class="n">max</span><span class="p">(),:,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># 3</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">C1</span> <span class="o">-</span> <span class="n">C0</span>
            <span class="c"># Define Y and Z axis</span>
            <span class="n">corners0</span> <span class="o">=</span> <span class="n">pcg</span><span class="p">[</span><span class="n">ivx</span><span class="o">.</span><span class="n">min</span><span class="p">(),:,:]</span> <span class="c"># 3 x 4</span>
            <span class="n">Ytemp</span> <span class="o">=</span> <span class="n">corners0</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">corners0</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>   <span class="c"># from top-left corner to top-right corner</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Ytemp</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
            <span class="c"># Normalize axis length</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
            <span class="c"># Create rotation matrix</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="c"># Build convenience affine matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">M</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)))),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">print</span> <span class="s">&#39;Convenient reference frame calculated&#39;</span>
            
    </div>
<div class="viewcode-block" id="Process.getVoxelArrayPose"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getVoxelArrayPose">[docs]</a>    <span class="k">def</span> <span class="nf">getVoxelArrayPose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return roto-translation matrix from voxel array reference frame to global reference frame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            4 x 4 rototranslation matrix.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Define roto-translation from convenient to global reference frame</span>
        <span class="n">Tconv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convR</span><span class="p">)</span>
        
        <span class="c"># Define roto-translation from voxel-array to convenient reference frame</span>
        <span class="n">convTva</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">convTva</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">]</span>
        
        <span class="c"># Define roto-translation from voxel-array to global reference frame</span>
        <span class="n">Tva</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tconv</span><span class="p">,</span> <span class="n">convTva</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">Tva</span>
    
    
    </div>
<div class="viewcode-block" id="Process.setScaleFactors"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setScaleFactors">[docs]</a>    <span class="k">def</span> <span class="nf">setScaleFactors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fxyz</span><span class="p">,</span> <span class="n">voxFramesBounds</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set or calculate scale factors that multiply real voxel-array dimensions.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fxyz : mixed</span>
<span class="sd">            Scale factors.</span>
<span class="sd">            If list, it must contain 3 elements being the scale factors</span>
<span class="sd">            If &#39;auto_bounded_parallel_scans&#39;, the following should hold:</span>
<span class="sd">            - the US probe motion is supposed to be performed mainly along one axis (X);</span>
<span class="sd">            - corners of the US images during acquisition are supposed to not deviate too much from a straight line (along X);</span>
<span class="sd">            - motion velocity is supposed to be constant;</span>
<span class="sd">            - pixel/mm for US images are very similar for width and height.</span>
<span class="sd">            Scale factors are calculated as follows:</span>
<span class="sd">            - fx: ceil(abs((voxFramesBounds[1] - voxFramesBounds[0]) / (C1 - C0)));</span>
<span class="sd">            - fy, fz: ceil(1 / pixel2mmX).</span>
<span class="sd">            where:</span>
<span class="sd">            - C0 and C1 are the X coordinates (in *mm*) of the US image centers at frames ``voxFramesBounds[0]`` and ``voxFramesBounds[1]``;</span>
<span class="sd">            - pixel2mmX is the conversion factor (in *mm/pixel*) for width in the US images.</span>
<span class="sd">            See chapter :ref:`when-mem-error` for the use of these scale factors.</span>
<span class="sd">        </span>
<span class="sd">        voxFramesBounds : mixed</span>
<span class="sd">            Bounding frames for the list of frames to be contained in the voxel array.</span>
<span class="sd">            If None, first and last time frames out of ``setValidFramesForVoxelArray()`` will be used.</span>
<span class="sd">            If list, it must contain 2 elements specifying lower and upper bround frames.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkFxyz</span><span class="p">(</span><span class="n">fxyz</span><span class="p">)</span>
        <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">checkVoxFrames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">checkVoxFramesBounds</span><span class="p">(</span><span class="n">voxFramesBounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">checkGl2ConvPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convR</span><span class="p">)</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
        
        <span class="c"># Creae voxel frames bounds if not existing</span>
        <span class="k">if</span> <span class="n">voxFramesBounds</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">voxFramesBounds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        
        <span class="c"># Calculating scale factors</span>
        <span class="n">ivx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">)</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">createImageCorners</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
        <span class="n">pcg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dot2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convR</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">ivx</span><span class="p">,:,:]),</span><span class="n">pc</span><span class="p">)</span>  <span class="c"># N x 4 x 4 (#frames x #coords+1 x #points)</span>
        <span class="n">ivx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fxyz</span> <span class="o">==</span> <span class="s">&#39;auto_bounded_parallel_scans&#39;</span><span class="p">:</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">voxFramesBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">voxFramesBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ivx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Frame </span><span class="si">%d</span><span class="s"> is not a valid kinematic frame&#39;</span> <span class="o">%</span> <span class="n">i0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ivx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Frame </span><span class="si">%d</span><span class="s"> is not a valid kinematic frame&#39;</span> <span class="o">%</span> <span class="n">i1</span><span class="p">)</span>
            <span class="n">C0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pcg</span><span class="p">[</span><span class="n">ivx</span><span class="o">==</span><span class="n">i0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pcg</span><span class="p">[</span><span class="n">ivx</span><span class="o">==</span><span class="n">i1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">i1</span> <span class="o">-</span> <span class="n">i0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">C1</span> <span class="o">-</span> <span class="n">C0</span><span class="p">)))</span>
            <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
            <span class="n">fz</span> <span class="o">=</span> <span class="n">fy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span> <span class="o">=</span> <span class="n">fxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span> <span class="o">=</span> <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span>
        <span class="k">print</span> <span class="s">&#39;Scale factors fx, fy, fz set to: </span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span><span class="p">)</span>
        
    </div>
<div class="viewcode-block" id="Process.calculateVoxelArrayDimensions"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.calculateVoxelArrayDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">calculateVoxelArrayDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate dimensions for voxel array. The convenient reference frame</span>
<span class="sd">        (see ``calculateConvPose()``) is translated to a *voxel array* reference</span>
<span class="sd">        frame, optimally containing the US images is the first quadrant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkFxyz</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span><span class="p">])</span>
        <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">checkGl2ConvPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convR</span><span class="p">)</span>
        <span class="n">checkVoxFrames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>

        <span class="c"># Calculate coordinates for all points in convevient reference frame        </span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">createImageCorners</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
        <span class="n">ivx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">validKineFrames</span><span class="p">)</span>
        <span class="n">pcg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dot2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convR</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">ivx</span><span class="p">,:,:]),</span><span class="n">pc</span><span class="p">)</span>  <span class="c"># N x 4 x 4 (#frames x #coords+1 x #points)</span>
        
        <span class="c"># Calculate volume dimensions</span>
        <span class="k">print</span> <span class="s">&#39;Calculating voxel array dimension ...&#39;</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">pcg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">pcg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">pcg</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">pcg</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">pcg</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">pcg</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span> <span class="o">=</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span>       
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span>
         
        <span class="c"># Calculate voxel array size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xl</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span> <span class="o">*</span> <span class="n">xmax</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span> <span class="o">*</span> <span class="n">xmin</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yl</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fy</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fy</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zl</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fz</span> <span class="o">*</span> <span class="n">zmax</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fz</span> <span class="o">*</span> <span class="n">zmin</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span> <span class="o">*</span> <span class="n">xmin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fy</span> <span class="o">*</span> <span class="n">ymin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fz</span> <span class="o">*</span> <span class="n">zmin</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;Voxel array dimension: {0} x {1} x {2}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">)</span>
        
    </div>
<div class="viewcode-block" id="Process.initVoxelArray"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.initVoxelArray">[docs]</a>    <span class="k">def</span> <span class="nf">initVoxelArray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize voxel array. It instantiate data for the voxel array grey values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        
        <span class="c"># Create voxel array for grey values</span>
        
        <span class="c"># NOTE:</span>
        <span class="c">#</span>
        <span class="c"># For a flat structure:</span>
        <span class="c"># </span>
        <span class="c"># pros:</span>
        <span class="c"># - it is already usable for a VTK data copy by numpy_to_vtk, without any ravel (MemoryError avoided)</span>
        <span class="c">#</span>
        <span class="c"># cons:</span>
        <span class="c"># - direct block slicing takes some overhead (use helper funcs getCubeCoords(), xyz2idx())</span>
        
        <span class="n">struct</span> <span class="o">=</span> <span class="s">&#39;flat&#39;</span>
        <span class="k">if</span> <span class="n">struct</span> <span class="o">==</span> <span class="s">&#39;flat&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        
        <span class="c"># Create voxel array for grey values indicating hox many times a voxel</span>
        <span class="c"># has been written</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        
        <span class="c"># Create voxel array for bool values indicating if the voxel contains</span>
        <span class="c"># raw data</span>
        <span class="c">#self.usedV = np.zeros(self.V.shape, dtype=np.bool)  # it occupies as much as a np.uint8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usedV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contV</span>
        
        <span class="c"># Create voxel array for bool values indicating if the voxel belongs</span>
        <span class="c"># to the sequence of slices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internalV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        
        
    </div>
<div class="viewcode-block" id="Process.setUSImagesAlignmentParameters"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setUSImagesAlignmentParameters">[docs]</a>    <span class="k">def</span> <span class="nf">setUSImagesAlignmentParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set parameters for US scans alignement in global reference frame.</span>
<span class="sd">        See chapter :ref:`when-mem-error` for tips about setting these parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrapper : str</span>
<span class="sd">            Type of wrapper to create scanning silhouette.</span>
<span class="sd">            If &#39;parallelepipedon&#39;, the smallest wrapping paralellepipedon (with</span>
<span class="sd">            dimensions aligned with the global reference frame) is created between</span>
<span class="sd">            two US scans.</span>
<span class="sd">            If &#39;convex_hull&#39;, the convex hull is created between two US scans.</span>
<span class="sd">            This one is more accurate than &#39;parallelepipedon&#39;, but it takes more</span>
<span class="sd">            time to be created.</span>
<span class="sd">            If &#39;none&#39; (default), no wrapper is created.</span>
<span class="sd">            </span>
<span class="sd">            .. image:: parall_vs_convexhull.png</span>
<span class="sd">               :scale: 50 %</span>
<span class="sd">        </span>
<span class="sd">        step : int</span>
<span class="sd">            Interval (in number of US frames) between two US scans</span>
<span class="sd">            used to create the wrapper. Default to 1.</span>
<span class="sd">        </span>
<span class="sd">        alignFrames : list</span>
<span class="sd">            List of frames (US time line) on which to perform US images alignment.</span>
<span class="sd">        </span>
<span class="sd">        fillVoxMethod : str</span>
<span class="sd">            Method for filling each voxel.</span>
<span class="sd">            If &#39;avg&#39;, an average between the current voxel value and the new value </span>
<span class="sd">            is performed.</span>
<span class="sd">            If &#39;last&#39;, the new image value will replace the current one.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check wrapper</span>
        <span class="k">if</span> <span class="s">&#39;wrapper&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;wrapper&#39;</span><span class="p">]</span>
            <span class="n">checkWrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapper</span> <span class="o">=</span> <span class="n">wrapper</span>

        <span class="c"># Check step</span>
        <span class="k">if</span> <span class="s">&#39;step&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;step&#39;</span><span class="p">]</span>
            <span class="n">checkStep</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>
        
        <span class="c"># Check frameWin</span>
        <span class="k">if</span> <span class="s">&#39;alignFrames&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">alignFrames</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;alignFrames&#39;</span><span class="p">]</span>
            <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
            <span class="n">checkAlignFrames</span><span class="p">(</span><span class="n">alignFrames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alignFrames</span> <span class="o">=</span> <span class="n">alignFrames</span>
            
        <span class="c"># Check fillVoxMethod</span>
        <span class="k">if</span> <span class="s">&#39;fillVoxMethod&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">fillVoxMethod</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;fillVoxMethod&#39;</span><span class="p">]</span>
            <span class="n">checkFillVoxMethod</span><span class="p">(</span><span class="n">fillVoxMethod</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fillVoxMethod</span> <span class="o">=</span> <span class="n">fillVoxMethod</span>
        
    </div>
<div class="viewcode-block" id="Process.alignUSImages"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.alignUSImages">[docs]</a>    <span class="k">def</span> <span class="nf">alignUSImages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Align US images in the global reference frame.</span>
<span class="sd">        This task can take some time, and computation time is proportional</span>
<span class="sd">        to the *total* number of US images to align.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
        <span class="n">checkImDim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
        <span class="n">checkUsFiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span><span class="p">)</span>
        <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">checkGl2ConvPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convR</span><span class="p">)</span>
        <span class="n">checkFxyz</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span><span class="p">])</span>
        <span class="c"># xl, xo</span>
        <span class="n">checkV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
        <span class="n">checkV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contV</span><span class="p">)</span>
        <span class="n">checkV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">)</span>
        <span class="n">checkV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)</span>
        <span class="n">checkWrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapper</span><span class="p">)</span>
        <span class="n">checkStep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="n">checkFillVoxMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fillVoxMethod</span><span class="p">)</span>

        <span class="c"># Create if necessary and check alignFrames</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignFrames</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alignFrames</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">checkAlignFrames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alignFrames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c"># Create pixel coordinates (in mm) in image reference frame</span>
        <span class="k">print</span> <span class="s">&#39;Creating pixel 3D coordinates in image reference frame ...&#39;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">createImageCoords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;Pixel 3D coordinates calculated&#39;</span>
        
        <span class="c"># Calculate image corners coordinates</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">createImageCorners</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
        
        <span class="c"># Calculate position for all the pixels, for all the time instant</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">fileNames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usFiles</span>
        <span class="n">ioffset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ivx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxFrames</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">fileNames</span><span class="p">)):</span>
            <span class="c"># Read DICOM file</span>
            <span class="k">print</span> <span class="s">&#39;Reading DICOM file {0} ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fileNames</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
            <span class="n">D</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">readDICOM</span><span class="p">(</span><span class="n">fileNames</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
            <span class="k">print</span> <span class="s">&#39;DICOM file read&#39;</span>
            <span class="c">#print D.shape</span>
            <span class="n">Ni</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">iStart</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ni</span><span class="p">):</span>
                <span class="c"># Calculate absolute index</span>
                <span class="n">iR</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">ioffset</span>
                <span class="c"># Check if frame has to be realigned</span>
                <span class="k">if</span> <span class="n">iR</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ivx</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">iR</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignFrames</span><span class="p">:</span>
                    <span class="k">continue</span>
<span class="c">#                if iR not in self.validKineFrames:</span>
<span class="c">#                    continue</span>
                <span class="k">if</span> <span class="n">iStart</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">iStart</span> <span class="o">=</span> <span class="n">i</span>
                <span class="c"># Create gray values</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">pixelData2grey</span><span class="p">(</span><span class="n">D</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:,:])</span>
                <span class="k">print</span> <span class="s">&#39;Inserting oriented slice for instant {0}/{1} ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iR</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ni</span><span class="p">)</span>
                <span class="c"># Calculate frames position in space</span>
                <span class="n">pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convR</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">iR</span><span class="p">,:,:]),</span><span class="n">p</span><span class="p">)</span> <span class="c"># mm</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pg</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xo</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="c"># 1 x Np</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pg</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">yo</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pg</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zo</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="c"># Fill voxel array with grey values</span>
                <span class="n">idxV</span> <span class="o">=</span> <span class="n">xyz2idx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillVoxMethod</span> <span class="o">==</span> <span class="s">&#39;avg&#39;</span><span class="p">:</span>
                    <span class="c">#self.V[idxV] = (self.contV[idxV] * self.V[idxV]) / (self.contV[idxV] + 1) + I.ravel() / (self.contV[idxV] + 1)   # wrong: overflow </span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idxV</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idxV</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contV</span><span class="p">[</span><span class="n">idxV</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contV</span><span class="p">[</span><span class="n">idxV</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">I</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contV</span><span class="p">[</span><span class="n">idxV</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>  
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillVoxMethod</span> <span class="o">==</span> <span class="s">&#39;last&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idxV</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">contV</span><span class="p">[</span><span class="n">idxV</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c">#self.usedV[idxV] = True                </span>
                <span class="k">del</span> <span class="n">I</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapper</span> <span class="o">==</span> <span class="s">&#39;parallelepipedon&#39;</span><span class="p">:</span>
                    <span class="n">xc</span> <span class="o">=</span> <span class="n">x</span>
                    <span class="n">yc</span> <span class="o">=</span> <span class="n">y</span>
                    <span class="n">zc</span> <span class="o">=</span> <span class="n">z</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapper</span> <span class="o">==</span> <span class="s">&#39;convex_hull&#39;</span><span class="p">:</span>
                    <span class="c"># Calculate coordinates of image corners </span>
                    <span class="n">pcg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convR</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">iR</span><span class="p">,:,:]),</span><span class="n">pc</span><span class="p">)</span> <span class="c"># mm</span>
                    <span class="n">xc</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pcg</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xo</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="c"># 1 x 4</span>
                    <span class="n">yc</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pcg</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">yo</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                    <span class="n">zc</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pcg</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zo</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>  
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#self.internalV[idxV] = True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">[</span><span class="n">idxV</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">continue</span>
                <span class="c"># Create wrapper</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">iStart</span><span class="p">:</span>
                    <span class="n">xcPrev</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">ycPrev</span> <span class="o">=</span> <span class="n">yc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">zcPrev</span> <span class="o">=</span> <span class="n">zc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapper</span> <span class="o">==</span> <span class="s">&#39;parallelepipedon&#39;</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;Creating parallelepipedon ...&#39;</span>
                    <span class="n">xcMin</span><span class="p">,</span> <span class="n">xcMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">xc</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">xcPrev</span><span class="o">.</span><span class="n">min</span><span class="p">())),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">xc</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">xcPrev</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
                    <span class="n">ycMin</span><span class="p">,</span> <span class="n">ycMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">yc</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">ycPrev</span><span class="o">.</span><span class="n">min</span><span class="p">())),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">yc</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">ycPrev</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
                    <span class="n">zcMin</span><span class="p">,</span> <span class="n">zcMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">zc</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">zcPrev</span><span class="o">.</span><span class="n">min</span><span class="p">())),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">zc</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">zcPrev</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
                    <span class="n">xcInternal</span><span class="p">,</span> <span class="n">ycInternal</span><span class="p">,</span> <span class="n">zcInternal</span> <span class="o">=</span> <span class="n">getCubeCoords</span><span class="p">(([</span><span class="n">xcMin</span><span class="p">,</span><span class="n">xcMax</span><span class="p">],[</span><span class="n">ycMin</span><span class="p">,</span><span class="n">ycMax</span><span class="p">],[</span><span class="n">zcMin</span><span class="p">,</span><span class="n">zcMax</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapper</span> <span class="o">==</span> <span class="s">&#39;convex_hull&#39;</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;Creating convex hull ...&#39;</span>
                    <span class="n">cCurrent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">zc</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">cPrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">xcPrev</span><span class="p">,</span><span class="n">ycPrev</span><span class="p">,</span><span class="n">zcPrev</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">cCurrent</span><span class="p">,</span><span class="n">cPrev</span><span class="p">):</span>
                        <span class="n">cHull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cCurrent</span><span class="p">,</span><span class="n">cPrev</span><span class="p">))</span>
                        <span class="n">cInternal</span> <span class="o">=</span> <span class="n">getCoordsInConvexHull</span><span class="p">(</span><span class="n">cHull</span><span class="p">)</span>
                        <span class="n">xcInternal</span><span class="p">,</span> <span class="n">ycInternal</span><span class="p">,</span> <span class="n">zcInternal</span> <span class="o">=</span> <span class="n">cInternal</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">cInternal</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">cInternal</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s">&#39;The 2 slices are exactly overlapped. Impossible to create convex hull&#39;</span>
                <span class="c">#idxInternal = xyz2idx(xcInternal, ycInternal, zcInternal, self.xl, self.yl, self.zl).squeeze()</span>
                <span class="n">idxInternal</span> <span class="o">=</span> <span class="n">xyz2idx</span><span class="p">(</span><span class="n">xcInternal</span><span class="p">,</span> <span class="n">ycInternal</span><span class="p">,</span> <span class="n">zcInternal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">[</span><span class="n">idxInternal</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">xcPrev</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">ycPrev</span> <span class="o">=</span> <span class="n">yc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">zcPrev</span> <span class="o">=</span> <span class="n">zc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
            <span class="n">ioffset</span> <span class="o">+=</span> <span class="n">Ni</span>
            <span class="k">del</span> <span class="n">D</span><span class="p">,</span> <span class="n">ds</span>       
            
            
        <span class="c">#del self.contV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usedV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contV</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapper</span> <span class="o">&lt;&gt;</span> <span class="s">&#39;none&#39;</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">xcPrev</span><span class="p">,</span> <span class="n">ycPrev</span><span class="p">,</span> <span class="n">zcPrev</span><span class="p">,</span> <span class="n">idxInternal</span><span class="p">,</span> <span class="n">xcInternal</span><span class="p">,</span> <span class="n">ycInternal</span><span class="p">,</span> <span class="n">zcInternal</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span>
        <span class="k">print</span> <span class="s">&#39;Elapsed time: {0} s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elapsed</span><span class="p">)</span>
        <span class="n">idxEmptyN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">)</span>
        <span class="n">pctEmpty</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">idxEmptyN</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">size</span>
        <span class="k">print</span> <span class="s">&#39;Pct of empty voxels: ({0}% total)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pctEmpty</span><span class="p">)</span>
        <span class="n">pctInternal</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">size</span>
        <span class="k">print</span> <span class="s">&#39;Estimate of pct of internal voxels: ({0}% total)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pctInternal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pctInternalEmpty</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span> <span class="o">&amp;</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pctInternalEmpty</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">print</span> <span class="s">&#39;Estimate of pct of internal empty voxels: ({0}</span><span class="si">% i</span><span class="s">nternal)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pctInternalEmpty</span><span class="p">)</span>
    


</div>
<div class="viewcode-block" id="Process.setGapFillingParameters"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setGapFillingParameters">[docs]</a>    <span class="k">def</span> <span class="nf">setGapFillingParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set parameters for gap filling.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            Method for filling gaps.</span>
<span class="sd">            If &#39;VNN&#39; (Voxel Nearest Neighbour, default), the nearest voxel to the gap is</span>
<span class="sd">            used to fill the gap. Arguments ``maxS`` and ``minPct`` will be ignored.</span>
<span class="sd">            If ``distTh` is set, voxels with a distance greater than this threshold will</span>
<span class="sd">            be ignored when filling gaps.</span>
<span class="sd">            If &#39;AVG_CUBE&#39;, this procedure is applied:</span>
<span class="sd">                1. create a cube with side 3 voxels, centered around the gap</span>
<span class="sd">                2. search for a minimum ``minPct`` percentage of non-gaps inside the cube (100% = number of voxels in the cube)</span>
<span class="sd">                3. if that percentage is found, a non-gap voxels average (wighted by the Euclidean distances) is performed into the cube</span>
<span class="sd">                4. if that percentage is not found, the cube size in incremented by 2 voxels</span>
<span class="sd">                5. if cube size is lesser than maxS, start again from point 2. Otherwise, stop and don&#39;t fill the gap.</span>
<span class="sd">            This method is much slower than &#39;VNN&#39;, but allows to limit the search area.</span>
<span class="sd">        </span>
<span class="sd">        maxS : int</span>
<span class="sd">            See ``method``. This number must be an odd number. Default to 1.</span>
<span class="sd">        </span>
<span class="sd">        minPct : float </span>
<span class="sd">            See ``method``. This value must be between 0 and 1. Default to 0.</span>
<span class="sd">        </span>
<span class="sd">        blocksN : int</span>
<span class="sd">            Positive number (greater or equal than 1) indicating the number of</span>
<span class="sd">            subvoxel-arrays into which to decompose the gap-filling problem. This can be tuned to</span>
<span class="sd">            modify computation time and memory usage. Default to 100.</span>
<span class="sd">        </span>
<span class="sd">        blockDir : str</span>
<span class="sd">            String defining the direction for blocks motion.</span>
<span class="sd">            It can be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;.</span>
<span class="sd">        </span>
<span class="sd">        distTh : int</span>
<span class="sd">            See ``method``. This must be greater or equal than 1.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        *Only* the gaps internal to the wrapper created by ``alighImages()`` will beconsidered.</span>
<span class="sd">        If a gap is not filled, its value will be considered the same as a *completely black* voxel.</span>
<span class="sd">        See chapter :ref:`when-mem-error` for tips about setting these parameters.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check method</span>
        <span class="k">if</span> <span class="s">&#39;method&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;method&#39;</span><span class="p">]</span>
            <span class="n">checkMethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
            
        <span class="c"># Check blocksN</span>
        <span class="k">if</span> <span class="s">&#39;blocksN&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">blocksN</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;blocksN&#39;</span><span class="p">]</span>
            <span class="n">checkBlocksN</span><span class="p">(</span><span class="n">blocksN</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocksN</span> <span class="o">=</span> <span class="n">blocksN</span>

        <span class="c"># Check blockDir</span>
        <span class="k">if</span> <span class="s">&#39;blockDir&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">blockDir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;blockDir&#39;</span><span class="p">]</span>
            <span class="n">checkBlockDir</span><span class="p">(</span><span class="n">blockDir</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blockDir</span> <span class="o">=</span> <span class="n">blockDir</span>

        <span class="c"># Check maxS</span>
        <span class="k">if</span> <span class="s">&#39;maxS&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">maxS</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;maxS&#39;</span><span class="p">]</span>
            <span class="n">checkMaxS</span><span class="p">(</span><span class="n">maxS</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxS</span> <span class="o">=</span> <span class="n">maxS</span>
            
        <span class="c"># Check distTh</span>
        <span class="k">if</span> <span class="s">&#39;distTh&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">distTh</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;distTh&#39;</span><span class="p">]</span>
            <span class="n">checkDistTh</span><span class="p">(</span><span class="n">distTh</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distTh</span> <span class="o">=</span> <span class="n">distTh</span>
    
        
        <span class="c"># Check minPct</span>
        <span class="k">if</span> <span class="s">&#39;minPct&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">minPct</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;minPct&#39;</span><span class="p">]</span>
            <span class="n">checkMinPct</span><span class="p">(</span><span class="n">minPct</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minPct</span> <span class="o">=</span> <span class="n">minPct</span>
            
    </div>
<div class="viewcode-block" id="Process.fillGaps"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.fillGaps">[docs]</a>    <span class="k">def</span> <span class="nf">fillGaps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run the gap-filling procedure.</span>
<span class="sd">        This task can take some time.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c"># Check input validity</span>
        <span class="n">checkMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
        <span class="n">checkBlocksN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocksN</span><span class="p">)</span>
        <span class="n">checkMaxS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxS</span><span class="p">)</span>
        <span class="n">checkBlockDir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blockDir</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;VNN&#39;</span><span class="p">:</span>
            <span class="n">checkDistTh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distTh</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;AVG_CUBE&#39;</span><span class="p">:</span>
            <span class="n">checkMinPct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minPct</span><span class="p">)</span>        
        <span class="n">checkV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
        <span class="n">checkV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">)</span>
        <span class="n">checkV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)</span>
        
        <span class="k">print</span> <span class="s">&#39;Filling empty voxels ({0}), when possible ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockDir</span> <span class="o">==</span> <span class="s">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">bxl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xl</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksN</span><span class="p">)</span>
            <span class="n">byl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span>
            <span class="n">bzl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockDir</span> <span class="o">==</span> <span class="s">&#39;Y&#39;</span><span class="p">:</span>
            <span class="n">bxl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span>
            <span class="n">byl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yl</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksN</span><span class="p">)</span>
            <span class="n">bzl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockDir</span> <span class="o">==</span> <span class="s">&#39;Z&#39;</span><span class="p">:</span>
            <span class="n">bxl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span>
            <span class="n">byl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span>
            <span class="n">bzl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zl</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksN</span><span class="p">)</span>
<span class="c">#        blockSize = bxl * byl * bzl</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sliceMethod</span> <span class="o">=</span> <span class="s">&#39;fast&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sliceMethod</span> <span class="o">=</span> <span class="s">&#39;slow&#39;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksN</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&#39;Block {0} ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="c"># Initialize block indices</span>
            <span class="n">cLims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockDir</span> <span class="o">==</span> <span class="s">&#39;X&#39;</span><span class="p">:</span>
                <span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">*</span><span class="n">bxl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bxl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">])]</span>
                <span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">]</span>
                <span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bxl</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">:</span>
                    <span class="n">bxl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">bxl</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockDir</span> <span class="o">==</span> <span class="s">&#39;Y&#39;</span><span class="p">:</span>
                <span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">]</span>
                <span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">*</span><span class="n">byl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">byl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">])]</span>
                <span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">byl</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">:</span>
                    <span class="n">byl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">byl</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockDir</span> <span class="o">==</span> <span class="s">&#39;Z&#39;</span><span class="p">:</span>
                <span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">]</span>
                <span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">]</span>
                <span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">*</span><span class="n">bzl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bzl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">])]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bzl</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">:</span>
                    <span class="n">bzl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">bzl</span>
            <span class="k">if</span> <span class="n">sliceMethod</span> <span class="o">==</span> <span class="s">&#39;slow&#39;</span><span class="p">:</span>
                <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">zc</span> <span class="o">=</span> <span class="n">getCubeCoords</span><span class="p">(</span><span class="n">cLims</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">xyz2idx</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">zc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">)</span>
                <span class="n">idxBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">idxBlock</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;VNN&#39;</span><span class="p">:</span>
                <span class="c"># Apply VNN</span>
<span class="c">#                bzl = np.sum(idxBlock) / (bxl * byl)</span>
                <span class="k">if</span> <span class="n">sliceMethod</span> <span class="o">==</span> <span class="s">&#39;slow&#39;</span><span class="p">:</span>
                    <span class="n">reshV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">usedV</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)[</span><span class="n">idxBlock</span><span class="p">],</span> <span class="p">(</span><span class="n">bzl</span><span class="p">,</span><span class="n">byl</span><span class="p">,</span><span class="n">bxl</span><span class="p">))</span>
                    <span class="n">reshV2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idxBlock</span><span class="p">],</span> <span class="p">(</span><span class="n">bzl</span><span class="p">,</span><span class="n">byl</span><span class="p">,</span><span class="n">bxl</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">sliceMethod</span> <span class="o">==</span> <span class="s">&#39;fast&#39;</span><span class="p">:</span>
                    <span class="n">reshV</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">usedV</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)[</span><span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">reshV2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distTh</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">idxV</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">reshV</span><span class="p">,</span> <span class="n">return_distances</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edt</span><span class="p">,</span> <span class="n">idxV</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">reshV</span><span class="p">,</span> <span class="n">return_distances</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">idxTh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">edt</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">distTh</span><span class="p">)</span>
                    <span class="n">idxV</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idxTh</span><span class="p">]</span> <span class="o">=</span> <span class="n">idxTh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">idxV</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">idxTh</span><span class="p">]</span> <span class="o">=</span> <span class="n">idxTh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">idxV</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">idxTh</span><span class="p">]</span> <span class="o">=</span> <span class="n">idxTh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">edt</span><span class="p">,</span> <span class="n">idxTh</span>
                <span class="k">if</span> <span class="n">sliceMethod</span> <span class="o">==</span> <span class="s">&#39;slow&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idxBlock</span><span class="p">]</span> <span class="o">=</span> <span class="n">reshV2</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idxV</span><span class="p">)]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">[</span><span class="n">idxBlock</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">del</span> <span class="n">idxBlock</span>
                <span class="k">elif</span> <span class="n">sliceMethod</span> <span class="o">==</span> <span class="s">&#39;fast&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">reshV2</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idxV</span><span class="p">)]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">[</span><span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">cLims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">del</span> <span class="n">reshV</span><span class="p">,</span> <span class="n">reshV2</span><span class="p">,</span> <span class="n">idxV</span>
                <span class="c"># Print some info</span>
                <span class="n">pctInternalEmpty</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span> <span class="o">&amp;</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">Estimate of pct of internal empty voxels: ({0}</span><span class="si">% i</span><span class="s">nternal)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pctInternalEmpty</span><span class="p">)</span> 
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;AVG_CUBE&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxS</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c"># Generate voxel coordinates for the search cube</span>
                        <span class="n">xCube</span><span class="p">,</span> <span class="n">yCube</span><span class="p">,</span> <span class="n">zCube</span> <span class="o">=</span> <span class="n">getCubeCoords</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
                        <span class="c"># Remove central voxel of the cube</span>
                        <span class="n">idxCentral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">xCube</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">yCube</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">zCube</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">xCube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">xCube</span><span class="p">,</span> <span class="n">idxCentral</span><span class="p">)[:,</span> <span class="bp">None</span><span class="p">]</span>
                        <span class="n">yCube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">yCube</span><span class="p">,</span> <span class="n">idxCentral</span><span class="p">)[:,</span> <span class="bp">None</span><span class="p">]</span>
                        <span class="n">zCube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">zCube</span><span class="p">,</span> <span class="n">idxCentral</span><span class="p">)[:,</span> <span class="bp">None</span><span class="p">]</span>
                        <span class="c"># Calculate distance from each vixel to central voxel</span>
                        <span class="n">distNeighs</span> <span class="o">=</span> <span class="p">(</span><span class="n">xCube</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yCube</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">zCube</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                        <span class="n">idxSort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distNeighs</span><span class="p">)</span>
                        <span class="n">distNeighs</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">distNeighs</span><span class="p">[</span><span class="n">idxSort</span><span class="p">,:]</span>
                    <span class="n">idxEmpty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">idxBlock</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>   <span class="c"># time bottleneck</span>
                    <span class="c"># Get coordinates of empty voxels</span>
                    <span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">zn</span> <span class="o">=</span> <span class="n">idx2xyz</span><span class="p">(</span><span class="n">idxEmpty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">)</span>
                    <span class="n">xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">yn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">yn</span><span class="p">,</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">zn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">zn</span><span class="p">,</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">idxNeighs</span> <span class="o">=</span> <span class="n">xyz2idx</span><span class="p">(</span><span class="n">xn</span><span class="o">+</span><span class="n">xCube</span><span class="p">,</span><span class="n">yn</span><span class="o">+</span><span class="n">yCube</span><span class="p">,</span><span class="n">zn</span><span class="o">+</span><span class="n">zCube</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">)</span>
                    <span class="c"># Get values for neigbour voxels, empty or not</span>
                    <span class="n">neighsV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idxNeighs</span><span class="p">]</span>
                    <span class="n">neighsUsedV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">[</span><span class="n">idxNeighs</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">idxNeighs</span>
                    <span class="c"># Sort by distance</span>
                    <span class="n">neighsV</span> <span class="o">=</span> <span class="n">neighsV</span><span class="p">[</span><span class="n">idxSort</span><span class="p">,:]</span>
                    <span class="n">neighsUsedV</span> <span class="o">=</span> <span class="n">neighsUsedV</span><span class="p">[</span><span class="n">idxSort</span><span class="p">,:]</span>
                    <span class="c"># Fill some empty voxels</span>
                    <span class="n">idxFillable</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">neighsUsedV</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minPct</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                    <span class="n">wMeanNum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">neighsUsedV</span> <span class="o">*</span> <span class="n">neighsV</span> <span class="o">*</span> <span class="n">distNeighs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                    <span class="n">wMeanDen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">neighsUsedV</span> <span class="o">*</span> <span class="n">distNeighs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">idxEmpty</span><span class="p">[</span><span class="n">idxFillable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wMeanNum</span><span class="p">[</span><span class="n">idxFillable</span><span class="p">]</span> <span class="o">/</span> <span class="n">wMeanDen</span><span class="p">[</span><span class="n">idxFillable</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  
                    <span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">[</span><span class="n">idxEmpty</span><span class="p">[</span><span class="n">idxFillable</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">True</span>   
                    <span class="c"># Print some info</span>
                    <span class="n">pctInternalEmpty</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span> <span class="o">&amp;</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">usedV</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)</span>
                    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">Estimate of pct of internal empty voxels after filling with cube of side {0}: ({1}</span><span class="si">% i</span><span class="s">nternal)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">pctInternalEmpty</span><span class="p">)</span>              
                    <span class="c"># Delete biggest arrays in inner loop                </span>
                    <span class="k">del</span> <span class="n">idxEmpty</span><span class="p">,</span> <span class="n">neighsV</span><span class="p">,</span> <span class="n">neighsUsedV</span><span class="p">,</span> <span class="n">idxFillable</span><span class="p">,</span> <span class="n">wMeanNum</span><span class="p">,</span> <span class="n">wMeanDen</span>
        
        <span class="k">print</span> <span class="s">&#39;Empty voxels filled when possible&#39;</span>
        <span class="k">return</span> <span class="n">pctInternalEmpty</span>
        
    </div>
<div class="viewcode-block" id="Process.getVoxelPhysicalSize"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getVoxelPhysicalSize">[docs]</a>    <span class="k">def</span> <span class="nf">getVoxelPhysicalSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get physical size for a single voxel.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            3-elem list with voxel dimensions (in *mm*) for each direction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check fxyz</span>
        <span class="n">checkFxyz</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span><span class="p">])</span>
        
        <span class="c"># Calculate physical dimensions (in mm)</span>
        <span class="n">vx</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fx</span>
        <span class="n">vy</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span>
        <span class="n">vz</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span>
        
        <span class="k">return</span> <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span>
    
    </div>
<div class="viewcode-block" id="Process.setVtkImageDataProperties"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setVtkImageDataProperties">[docs]</a>    <span class="k">def</span> <span class="nf">setVtkImageDataProperties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set parameters of ``vtkImageData`` object.</span>
<span class="sd">        </span>
<span class="sd">        Whenever a ``vtkImageData`` has to be created (e.g. for exportation purpose)</span>
<span class="sd">        from the internal voxel-array structure, these parameters are used.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sxyz : mixed</span>
<span class="sd">            Spacing factors fot object.</span>
<span class="sd">            If list, it must contain 3 elements containing spacing factors for each voxel dimension (see `here &lt;http://www.vtk.org/doc/nightly/html/classvtkImageData.html#ab3288d13810266e0b30ba0632f7b5b0b&gt;`_).</span>
<span class="sd">            If &#39;auto&#39;, spacing factors are automatically calculated using scale factors ``fxyz`` (see method ``initVoxelArray()``)</span>
<span class="sd">            Each factor *s* is calculated by using the correspoding scale factor *f* as: s = LCM(fx,fy,fz) / f,</span>
<span class="sd">            where LCM is the Least Minimum Multiple operator.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Check sxyz</span>
        <span class="k">if</span> <span class="s">&#39;sxyz&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">sxyz</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;sxyz&#39;</span><span class="p">]</span>
            <span class="n">checkSxyz</span><span class="p">(</span><span class="n">sxyz</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sxyz</span> <span class="o">==</span> <span class="s">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">checkFxyz</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span><span class="p">])</span>
                <span class="n">spacing</span> <span class="o">=</span> <span class="n">lcmm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fz</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fz</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sz</span> <span class="o">=</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sz</span> <span class="o">=</span> <span class="n">sxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">print</span> <span class="s">&#39;vtkImageData spacing factors set to: </span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sz</span><span class="p">)</span>
        
    </div>
<div class="viewcode-block" id="Process.exportVoxelArrayToVTI"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.exportVoxelArrayToVTI">[docs]</a>    <span class="k">def</span> <span class="nf">exportVoxelArrayToVTI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outFile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Export grey-values voxel-array to VTI file.</span>
<span class="sd">        </span>
<span class="sd">        VTI is a VTK file format (see `here &lt;http://www.cacr.caltech.edu/~slombey/asci/vtk/vtk_formats.simple.html&gt;`_).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outFile : str</span>
<span class="sd">            Full file path for the VTI file to be saved.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkFilePath</span><span class="p">(</span><span class="n">outFile</span><span class="p">)</span>
        <span class="n">checkSxyz</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sz</span><span class="p">])</span>
        <span class="n">checkV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
        <span class="c"># xl</span>
        
        <span class="c"># Create vtkImageData object for grey values voxel array</span>
        <span class="k">print</span> <span class="s">&#39;Creating vtkImageData object for grey values voxel array...&#39;</span>
        <span class="n">vtkV</span> <span class="o">=</span> <span class="n">nparray2vtkImageData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sz</span><span class="p">),</span> <span class="n">vtk</span><span class="o">.</span><span class="n">VTK_UNSIGNED_CHAR</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;vtkImageData object created&#39;</span>
        <span class="c"># Write grey values voxel array to file</span>
        <span class="k">print</span> <span class="s">&#39;Saving VTI file for grey values voxel array {0} ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outFile</span><span class="p">)</span>
        <span class="n">vtkImageData2vti</span><span class="p">(</span><span class="n">outFile</span><span class="p">,</span> <span class="n">vtkV</span><span class="p">)</span>    
        <span class="k">print</span> <span class="s">&#39;VTI file saved&#39;</span>

        
    </div>
<div class="viewcode-block" id="Process.exportVoxelArraySilhouetteToVTI"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.exportVoxelArraySilhouetteToVTI">[docs]</a>    <span class="k">def</span> <span class="nf">exportVoxelArraySilhouetteToVTI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outFile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Export US scan silhouette voxel-array to VTI file.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outFile : str</span>
<span class="sd">            Full file path for the VTI file to be saved.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Check input validity</span>
        <span class="n">checkFilePath</span><span class="p">(</span><span class="n">outFile</span><span class="p">)</span>
        <span class="n">checkSxyz</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sz</span><span class="p">])</span>
        <span class="n">checkV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="p">)</span>
        
        <span class="c"># Create vtkImageData object for silhouette voxel array</span>
        <span class="k">print</span> <span class="s">&#39;Creating vtkImageData object for silhouette values voxel array...&#39;</span>
        <span class="n">vtkInternalV</span> <span class="o">=</span> <span class="n">nparray2vtkImageData</span><span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">internalV</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">yl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">zl</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sz</span><span class="p">),</span> <span class="n">vtk</span><span class="o">.</span><span class="n">VTK_UNSIGNED_CHAR</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;vtkImageData object created&#39;</span>
        <span class="c"># Write silhouette voxel array to file</span>
        <span class="k">print</span> <span class="s">&#39;Saving VTI file for silhouette voxel array {0} ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outFile</span><span class="p">)</span>
        <span class="n">vtkImageData2vti</span><span class="p">(</span><span class="n">outFile</span><span class="p">,</span> <span class="n">vtkInternalV</span><span class="p">)</span>    
        <span class="k">print</span> <span class="s">&#39;VTI file saved&#39;</span>
        
        
</div>
<div class="viewcode-block" id="Process.calculateProbeCalibrationPrecision"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.calculateProbeCalibrationPrecision">[docs]</a>    <span class="k">def</span> <span class="nf">calculateProbeCalibrationPrecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="s">&#39;RP&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate calibration precision.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prec : str</span>
<span class="sd">            Precision type to estimate.</span>
<span class="sd">            If &#39;RP&#39;, Reconstruction Precision is estimated (see [Ref1]_). It needs</span>
<span class="sd">            single-point feature to be extracted for some US images of a calibration </span>
<span class="sd">            quality assessment acquisition. The points are the reconstructed in </span>
<span class="sd">            3D space, creating a cloud of points. RP is the mean of the distances</span>
<span class="sd">            between each 3D point and the 3D average point.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkPrecType</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
        <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">checkFeatures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>
        
        <span class="c"># Calculate precision</span>
        <span class="k">if</span> <span class="n">prec</span> <span class="o">==</span> <span class="s">&#39;RP&#39;</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Calculating reconstruction precision...&#39;</span>
            <span class="n">precValue</span> <span class="o">=</span> <span class="n">calculateRP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>            
            <span class="k">print</span> <span class="s">&#39;Precision calculated&#39;</span>
        
        <span class="c"># Set data internally</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prec</span><span class="p">[</span><span class="n">prec</span><span class="p">]</span> <span class="o">=</span> <span class="n">precValue</span>
        
    
    </div>
<div class="viewcode-block" id="Process.getProbeCalibrationPrecision"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getProbeCalibrationPrecision">[docs]</a>    <span class="k">def</span> <span class="nf">getProbeCalibrationPrecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="s">&#39;RP&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get estimated calibration precision data.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prec : str</span>
<span class="sd">            See method ``calculateProbeCalibrationPrecision()``.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Precision estimation.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkPrecType</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        
        <span class="c"># Get precision</span>
        <span class="k">if</span> <span class="n">prec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prec</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;This precision type was not calculated yet&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prec</span><span class="p">[</span><span class="n">prec</span><span class="p">]</span>
        
        
    </div>
<div class="viewcode-block" id="Process.calculateProbeCalibrationAccuracy"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.calculateProbeCalibrationAccuracy">[docs]</a>    <span class="k">def</span> <span class="nf">calculateProbeCalibrationAccuracy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="s">&#39;DA&#39;</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">))):</span>
        <span class="sd">&quot;&quot;&quot;Estimate calibration accuracy.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        acc : str</span>
<span class="sd">            Accuracy type to estimate.</span>
<span class="sd">            If &#39;DA&#39;, Distance Accuracy is estimated (see [Ref2]_). It needs</span>
<span class="sd">            2 single-point features to be extracted for some US images of a calibration </span>
<span class="sd">            quality assessment acquisition. These 2 points (each for different US images)</span>
<span class="sd">            are reconstructed in global reference frame and the distance is calculated. This process can be</span>
<span class="sd">            repeated for other couples of US images. For instance, if one point is indicated</span>
<span class="sd">            for frames 1, 4, 10, 15, 25, 40, then 3 distances are calculated (1-4, 10-15, 25-40).</span>
<span class="sd">            DA is the mean of the difference between these distances and the gold-standard</span>
<span class="sd">            measured real distance ``L``.</span>
<span class="sd">            If &#39;RA&#39;, Reconstruction Accuracy is estimated (see [Ref2]_). It needs</span>
<span class="sd">            1 single-point feature to be extracted for some US images of a calibration </span>
<span class="sd">            quality assessment acquisition. These points (each for different US images)</span>
<span class="sd">            are reconstructed in global reference frame. </span>
<span class="sd">            RA is the mean of the norm of the difference between these points and </span>
<span class="sd">            the gold-standard points ``P``.</span>
<span class="sd">            </span>
<span class="sd">        L : float</span>
<span class="sd">            Gold-standard distance (in *mm*) for DA estimation.</span>
<span class="sd">            </span>
<span class="sd">        P : np.ndarray</span>
<span class="sd">            Gold-standard 3D position (in *mm*) for RA estimation.</span>
<span class="sd">            It must be a N x 3 array containing 3D positions for points, where the time</span>
<span class="sd">            line is the same as the US data. Only the points whose time frames correspond</span>
<span class="sd">            to the single-point features.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkAccType</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">acc</span> <span class="o">==</span> <span class="s">&#39;DA&#39;</span><span class="p">:</span>    
            <span class="n">checkDist</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">)</span>
        <span class="n">checkPixel2mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">)</span>
        <span class="n">checkIm2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">checkFeatures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>
        
        <span class="c"># Calculate precision</span>
        <span class="k">if</span> <span class="n">acc</span> <span class="o">==</span> <span class="s">&#39;DA&#39;</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Calculating distance accuracy...&#39;</span>
            <span class="n">accList</span><span class="p">,</span> <span class="n">accValue</span> <span class="o">=</span> <span class="n">calculateDA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">acc</span> <span class="o">==</span> <span class="s">&#39;RA&#39;</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Calculating reconstruction accuracy...&#39;</span>
            <span class="n">accList</span><span class="p">,</span> <span class="n">accValue</span> <span class="o">=</span> <span class="n">calculateRA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2mmY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>            
        <span class="k">print</span> <span class="s">&#39;Accuracy calculated&#39;</span>
        <span class="c"># Set data internally</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acc</span><span class="p">[</span><span class="n">acc</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">accList</span><span class="p">,</span> <span class="n">accValue</span><span class="p">)</span>
        

</div>
<div class="viewcode-block" id="Process.getProbeCalibrationAccuracy"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getProbeCalibrationAccuracy">[docs]</a>    <span class="k">def</span> <span class="nf">getProbeCalibrationAccuracy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="s">&#39;DA&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get estimated calibration accuracy data.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        acc : str</span>
<span class="sd">            See method ``calculateProbeCalibrationAccuracy()``.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        listDA : np.ndarray</span>
<span class="sd">            Array containing as many values as the keys into ``points``. </span>
<span class="sd">            If 2 points where indicated in the corresponding US image, </span>
<span class="sd">            than the value corresponds to the difference between the </span>
<span class="sd">            points distance and ``L``, ``np.nan`` otherwise.</span>
<span class="sd">        </span>
<span class="sd">        DA : float</span>
<span class="sd">            Mean of ``listDA`` ignoring nans.</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c"># Check input validity</span>
        <span class="n">checkAccType</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
        
        <span class="c"># Get accuracy</span>
        <span class="k">if</span> <span class="n">acc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;This accuracy type was not calculated yet&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc</span><span class="p">[</span><span class="n">acc</span><span class="p">]</span>   

</div>
<div class="viewcode-block" id="Process.calculateDevicesTimeDelay"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.calculateDevicesTimeDelay">[docs]</a>    <span class="k">def</span> <span class="nf">calculateDevicesTimeDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;vert_motion_sync&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot;Estimate the delay between the US device and the optoelectronic device.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method: str</span>
<span class="sd">            Method used for the estimation.</span>
<span class="sd">            If &#39;vert_motion_sync&#39;, the user should have performed a vertical motion of the US probe</span>
<span class="sd">            so that the vertical coordinate of the markers cluster reference frame resambles a </span>
<span class="sd">            sine wave. It is suggested to scan the bottom of a water tank and make sure that the</span>
<span class="sd">            bottom of the line is kept more or less horizontal. The center of that line should have</span>
<span class="sd">            been detected in advance. A cross-correlation, between the normalized y coordinate (in US</span>
<span class="sd">            image reference frame) of the line center and the the normalized vertical coordinate (in </span>
<span class="sd">            global reference frame) of the origin of markers cluster reference frame, will be performed.</span>
<span class="sd">            Normalization consists of demeaning and dividing by the maximum of the rectified signal.</span>
<span class="sd">            From the cross-correlation signal, the maximum value within the time range (-1,+1), in </span>
<span class="sd">            seconds, is found. The time instant in which that maximum occurs is the time delay estimation.</span>
<span class="sd">            If positive, the US device is early with respect to the optolectronic device. </span>
<span class="sd">        </span>
<span class="sd">        vertCoordIdx : int, optional</span>
<span class="sd">            3D marker coordinate index representing the vertical coordinate with respect to global </span>
<span class="sd">            reference frame (0 &lt;= vertCoordIdx&lt;= 2). Considered if ``method=&#39;vert_motion_sync&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        showGraphs : bool, optional</span>
<span class="sd">            If True, normalized signals to be correled and correlation signal will be displayed. </span>
<span class="sd">            Execution will stop until the graphs windows is closed.</span>
<span class="sd">            Considered if ``method=&#39;vert_motion_sync&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkTemporalCalibMethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;vert_motion_sync&#39;</span><span class="p">:</span>
            <span class="n">checkPr2GlPose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Rpr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span><span class="p">)</span>
            <span class="n">checkFeatures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>
        
        <span class="c"># Perform estimate</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;vert_motion_sync&#39;</span><span class="p">:</span>
            <span class="c"># Get time vector</span>
            <span class="n">timeVector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># Get further arguments</span>
            <span class="n">vertCoordIdx</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;vertCoordIdx&#39;</span><span class="p">]</span>
            <span class="n">showGraphs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;showGraphs&#39;</span><span class="p">]</span>
            <span class="c"># Get vertical coordinate from opto device</span>
            <span class="n">optoSignal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tpr</span><span class="p">[:,</span><span class="n">vertCoordIdx</span><span class="p">]</span>
            <span class="c"># Get height for point in image coordinates</span>
            <span class="n">usSignal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">optoSignal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">usSignal</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># Estimate delay</span>
            <span class="k">print</span> <span class="s">&#39;Estimating time delay...&#39;</span>
            <span class="n">timeDelay</span> <span class="o">=</span> <span class="n">calculateTimeDelayXCorr</span><span class="p">(</span><span class="n">optoSignal</span><span class="p">,</span> <span class="n">usSignal</span><span class="p">,</span> <span class="s">&#39;Normalized height of markers cluster origin&#39;</span><span class="p">,</span> <span class="s">&#39;Y coordinate for point features detected in US images&#39;</span><span class="p">,</span> <span class="n">timeVector</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="n">lagsBound</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">withPlots</span><span class="o">=</span><span class="n">showGraphs</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&#39;Time delay estimated&#39;</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">timeDelay</span> <span class="o">=</span> <span class="n">timeDelay</span>
        
    </div>
<div class="viewcode-block" id="Process.getDevicesTimeDelay"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getDevicesTimeDelay">[docs]</a>    <span class="k">def</span> <span class="nf">getDevicesTimeDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get estimated delay between the US device and the optoelectronic device</span>
<span class="sd">        (See method ``calculateDevicesTimeDelay()``).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Time delay (in *seconds*).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeDelay</span>
        
    </div>
<div class="viewcode-block" id="Process.setDevicesTimeDelay"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.setDevicesTimeDelay">[docs]</a>    <span class="k">def</span> <span class="nf">setDevicesTimeDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeDelay</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set delay between the US device and the optoelectronic device.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------  </span>
<span class="sd">        timeDelay : float</span>
<span class="sd">            Time delay (in *seconds*) between the two devices. If positive, US device is early. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="n">checkTimeDelay</span><span class="p">(</span><span class="n">timeDelay</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeDelay</span> <span class="o">=</span> <span class="n">timeDelay</span>
        
        </div>
<div class="viewcode-block" id="Process.adjustUSTimeVector"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.adjustUSTimeVector">[docs]</a>    <span class="k">def</span> <span class="nf">adjustUSTimeVector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjust the original time vector of US images.</span>
<span class="sd">        The time delay set by ``setDevicesTimeDelay()`` will be subtracted from the</span>
<span class="sd">        original time vector extracted from US data.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">        </span>
<span class="sd">            This method must be called before any method using optoelectronic data,</span>
<span class="sd">            such as ``calculatePoseForUSProbe()``.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Check input validity</span>
        <span class="n">checkTimeVector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span><span class="p">)</span>
        <span class="n">checkTimeDelay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeDelay</span><span class="p">)</span>
        
        <span class="c"># Adjust original time vectors</span>
        <span class="k">print</span> <span class="s">&#39;Adjusting US TimeVector for delay...&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVectorAdj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usTimeVector</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usTimeVectorAdj</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVectorAdj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usTimeVectorAdj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeDelay</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&#39;TimeVector adjusted&#39;</span>
        
    </div>
<div class="viewcode-block" id="Process.getAdjustedUSTimeVector"><a class="viewcode-back" href="../../api/api.html#Py3DFreeHandUS.process.Process.getAdjustedUSTimeVector">[docs]</a>    <span class="k">def</span> <span class="nf">getAdjustedUSTimeVector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get adjusted US time vector (see ``adjustUSTimeVector()``).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Adjusted US time vector.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">usTimeVectorAdj</span>

        
        
        
        

        
        
        
        

        
        
        </div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Py3DFreeHandUS 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Davide Monari.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>