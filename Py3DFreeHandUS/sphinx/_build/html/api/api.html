<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API &mdash; Py3DFreeHandUS 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Py3DFreeHandUS 1.0 documentation" href="../index.html" />
    <link rel="next" title="License" href="../license.html" />
    <link rel="prev" title="In case of MemoryError" href="../tutorial/when_mem_error.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../license.html" title="License"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../tutorial/when_mem_error.html" title="In case of MemoryError"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Py3DFreeHandUS 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-Py3DFreeHandUS">
<span id="api"></span><h1>API<a class="headerlink" href="#module-Py3DFreeHandUS" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-Py3DFreeHandUS.process">
<span id="process"></span><h2><tt class="docutils literal"><span class="pre">process</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.process" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-process"></span><dl class="class">
<dt id="Py3DFreeHandUS.process.Process">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.process.</tt><tt class="descname">Process</tt><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for performing: US probe calibration; calibration quality assessment; voxel-array reconstruction</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.adjustUSTimeVector">
<tt class="descname">adjustUSTimeVector</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.adjustUSTimeVector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.adjustUSTimeVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the original time vector of US images.
The time delay set by <tt class="docutils literal"><span class="pre">setDevicesTimeDelay()</span></tt> will be subtracted from the
original time vector extracted from US data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method must be called before any method using optoelectronic data,
such as <tt class="docutils literal"><span class="pre">calculatePoseForUSProbe()</span></tt>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.alignUSImages">
<tt class="descname">alignUSImages</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.alignUSImages"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.alignUSImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Align US images in the global reference frame.
This task can take some time, and computation time is proportional
to the <em>total</em> number of US images to align.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.calculateConvPose">
<tt class="descname">calculateConvPose</tt><big>(</big><em>convR</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.calculateConvPose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.calculateConvPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate roto-translation matrix from global reference frame to <em>convenient</em> reference frame.
Voxel-array dimensions are calculated in this new refence frame. This rotation is important whenever the US scans sihouette is remarkably
oblique to some axis of the global reference frame. In this case, the voxel-array dimensions (calculated by the smallest parallelepipedon 
wrapping all the realigned scans), calculated in the global refrence frame, would not be optimal, i.e. larger than necessary.</p>
<a class="reference internal image-reference" href="../_images/diag_scan_direction.png"><img alt="../_images/diag_scan_direction.png" src="../_images/diag_scan_direction.png" style="width: 758.4px; height: 591.9px;" /></a>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>convR</strong> : mixed</p>
<blockquote class="last">
<div><p>Roto-translation matrix.
If str, it specifies the method for automatically calculate the matrix.
If &#8216;auto_PCA&#8217;, PCA is performed on all US image corners. The x, y and z of the new convenient reference frame are represented by the eigenvectors out of the PCA.
If &#8216;first_last_frames_centroid&#8217;, the convenent reference frame is expressed as:</p>
<ul class="simple">
<li>x from first image centroid to last image centroid</li>
<li>z orthogonal to x and the axis and the vector joining the top-left corner to the top-right corner of the first image</li>
<li>y orthogonal to z and x</li>
</ul>
<p>If np.ndarray, it must be manually specified as a 4 x 4 affine matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.calculateDevicesTimeDelay">
<tt class="descname">calculateDevicesTimeDelay</tt><big>(</big><em>method='vert_motion_sync'</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.calculateDevicesTimeDelay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.calculateDevicesTimeDelay" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the delay between the US device and the optoelectronic device.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method: str</strong></p>
<blockquote>
<div><p>Method used for the estimation.
If &#8216;vert_motion_sync&#8217;, the user should have performed a vertical motion of the US probe
so that the vertical coordinate of the markers cluster reference frame resambles a 
sine wave. It is suggested to scan the bottom of a water tank and make sure that the
bottom of the line is kept more or less horizontal. The center of that line should have
been detected in advance. A cross-correlation, between the normalized y coordinate (in US
image reference frame) of the line center and the the normalized vertical coordinate (in 
global reference frame) of the origin of markers cluster reference frame, will be performed.
Normalization consists of demeaning and dividing by the maximum of the rectified signal.
From the cross-correlation signal, the maximum value within the time range (-1,+1), in 
seconds, is found. The time instant in which that maximum occurs is the time delay estimation.
If positive, the US device is early with respect to the optolectronic device.</p>
</div></blockquote>
<p><strong>vertCoordIdx</strong> : int, optional</p>
<blockquote>
<div><p>3D marker coordinate index representing the vertical coordinate with respect to global 
reference frame (0 &lt;= vertCoordIdx&lt;= 2). Considered if <tt class="docutils literal"><span class="pre">method='vert_motion_sync'</span></tt>.</p>
</div></blockquote>
<p><strong>showGraphs</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If True, normalized signals to be correled and correlation signal will be displayed. 
Execution will stop until the graphs windows is closed.
Considered if <tt class="docutils literal"><span class="pre">method='vert_motion_sync'</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.calculatePoseForUSImages">
<tt class="descname">calculatePoseForUSImages</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.calculatePoseForUSImages"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.calculatePoseForUSImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the pose of the US images with respect to the global reference frame.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In <a class="reference internal" href="../intro.html#ref2" id="id1">[Ref2]</a>, this is the product <img src="../_images/mathmpl/math-ba0c36ac94.png" style="position: relative; bottom: -7px"/>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.calculatePoseForUSProbe">
<tt class="descname">calculatePoseForUSProbe</tt><big>(</big><em>mkrList=['M1', 'M2', 'M3', 'M4'], USProbePoseFun='default', USProbePoseFunArgs=None, globPoseFun=None, globPoseFunArgs=None, kineFilesReadOpts={}, showMarkers=False</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.calculatePoseForUSProbe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.calculatePoseForUSProbe" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the attitude (or pose) of the marker-based US probe reference frame with respect to the global reference frame.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In <a class="reference internal" href="../intro.html#ref2" id="id2">[Ref2]</a>, this is named <img src="../_images/mathmpl/math-d30a78994e.png" style="position: relative; bottom: -7px"/>.</p>
</div>
<p>After extracting markers data from the kinematics files set with method <tt class="docutils literal"><span class="pre">setKineFiles()</span></tt>, this data will
be concatenated and resampled using <tt class="docutils literal"><span class="pre">USTimeVector</span></tt>, if this one is available. Otherwise, kinematics data
will be resampled based on optoelectronic system frequency and US system frequency. Only after kinematics and
US data have a common time line, US probe attitude will be calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrList</strong> : list</p>
<blockquote>
<div><p>List of marker names to be extracted from kinematics files. These will be used for
creating the probe reference frame, and the global reference frame, if requested.</p>
</div></blockquote>
<p><strong>USProbePoseFun</strong> : mixed</p>
<blockquote>
<div><p>Function defining the US probe reference frame. 
If function, it takes two input parameters. The first one is <tt class="docutils literal"><span class="pre">mkrList</span></tt>, while the second one being
a dictionary where the keys are marker names defined in <tt class="docutils literal"><span class="pre">mkrList</span></tt>, and value are N x 3 Numpy arrays of 
3D coordinates (N is the number of time frames). The function must return a 2-elements list; the first one 
is a Numpy N x 3 x 3 rotation matrix from probe reference frame to laboratory reference frame; the second
one is a N x 3 Numpy array representing 3D coordinates of US probe reference frame origin in laboratory 
reference frame. 
If string, it must be <tt class="docutils literal"><span class="pre">'default'</span></tt>. In this case, the reference frame is defined as in the function 
<tt class="docutils literal"><span class="pre">kine.markersClusterFun()</span></tt>.</p>
</div></blockquote>
<p><strong>USProbePoseFunArgs</strong> : mixed</p>
<blockquote>
<div><p>Additional parameters passed to <tt class="docutils literal"><span class="pre">USProbePoseFun</span></tt>.</p>
</div></blockquote>
<p><strong>globPoseFunArgs</strong> : mixed</p>
<blockquote>
<div><p>Additional parameters passed to <tt class="docutils literal"><span class="pre">globPoseFunArgs</span></tt>.</p>
</div></blockquote>
<p><strong>globPoseFun</strong> : mixed</p>
<blockquote>
<div><p>Function defining the global reference frame.
This function takes the same input arguments as the function <tt class="docutils literal"><span class="pre">USProbePoseFun</span></tt>. It must return a 2-elements
list; the first one is a Numpy N x 3 x 3 rotation matrix from global reference frame to laboratory reference 
frame; the second one is a N x 3 Numpy array representing 3D coordinates of the global reference frame origin
in laboratory reference frame.</p>
</div></blockquote>
<p><strong>kineFilesReadOpts</strong> : dict</p>
<blockquote>
<div><p>Options for kinematics files reading. See parameter <tt class="docutils literal"><span class="pre">opts</span></tt> for <tt class="docutils literal"><span class="pre">kine.readC3D()</span></tt> function.</p>
</div></blockquote>
<p><strong>showMarkers</strong> : bool</p>
<blockquote class="last">
<div><p>If <tt class="docutils literal"><span class="pre">True</span></tt>, show the marker data after resampling to US time line.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.calculateProbeCalibrationAccuracy">
<tt class="descname">calculateProbeCalibrationAccuracy</tt><big>(</big><em>acc='DA'</em>, <em>L=100.0</em>, <em>P=array([]</em>, <em>shape=(0L</em>, <em>3L)</em>, <em>dtype=float64)</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.calculateProbeCalibrationAccuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.calculateProbeCalibrationAccuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate calibration accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>acc</strong> : str</p>
<blockquote>
<div><p>Accuracy type to estimate.
If &#8216;DA&#8217;, Distance Accuracy is estimated (see <a class="reference internal" href="../intro.html#ref2" id="id3">[Ref2]</a>). It needs
2 single-point features to be extracted for some US images of a calibration 
quality assessment acquisition. These 2 points (each for different US images)
are reconstructed in global reference frame and the distance is calculated. This process can be
repeated for other couples of US images. For instance, if one point is indicated
for frames 1, 4, 10, 15, 25, 40, then 3 distances are calculated (1-4, 10-15, 25-40).
DA is the mean of the difference between these distances and the gold-standard
measured real distance <tt class="docutils literal"><span class="pre">L</span></tt>.
If &#8216;RA&#8217;, Reconstruction Accuracy is estimated (see <a class="reference internal" href="../intro.html#ref2" id="id4">[Ref2]</a>). It needs
1 single-point feature to be extracted for some US images of a calibration 
quality assessment acquisition. These points (each for different US images)
are reconstructed in global reference frame. 
RA is the mean of the norm of the difference between these points and 
the gold-standard points <tt class="docutils literal"><span class="pre">P</span></tt>.</p>
</div></blockquote>
<p><strong>L</strong> : float</p>
<blockquote>
<div><p>Gold-standard distance (in <em>mm</em>) for DA estimation.</p>
</div></blockquote>
<p><strong>P</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Gold-standard 3D position (in <em>mm</em>) for RA estimation.
It must be a N x 3 array containing 3D positions for points, where the time
line is the same as the US data. Only the points whose time frames correspond
to the single-point features.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.calculateProbeCalibrationPrecision">
<tt class="descname">calculateProbeCalibrationPrecision</tt><big>(</big><em>prec='RP'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.calculateProbeCalibrationPrecision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.calculateProbeCalibrationPrecision" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate calibration precision.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>prec</strong> : str</p>
<blockquote class="last">
<div><p>Precision type to estimate.
If &#8216;RP&#8217;, Reconstruction Precision is estimated (see <a class="reference internal" href="../intro.html#ref1" id="id5">[Ref1]</a>). It needs
single-point feature to be extracted for some US images of a calibration 
quality assessment acquisition. The points are the reconstructed in 
3D space, creating a cloud of points. RP is the mean of the distances
between each 3D point and the 3D average point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.calculateVoxelArrayDimensions">
<tt class="descname">calculateVoxelArrayDimensions</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.calculateVoxelArrayDimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.calculateVoxelArrayDimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate dimensions for voxel array. The convenient reference frame
(see <tt class="docutils literal"><span class="pre">calculateConvPose()</span></tt>) is translated to a <em>voxel array</em> reference
frame, optimally containing the US images is the first quadrant.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.calibrateProbe">
<tt class="descname">calibrateProbe</tt><big>(</big><em>init</em>, <em>xtol=None</em>, <em>ftol=None</em>, <em>method='eq_based'</em>, <em>method_args={'phantom': 'single_wall'</em>, <em>'regularize_J': True}</em>, <em>fixed=[]</em>, <em>correctResults=False</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.calibrateProbe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.calibrateProbe" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the attitude (or pose) of the US images with respect to the probe reference frame.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In <a class="reference internal" href="../intro.html#ref2" id="id6">[Ref2]</a>, this is named <img src="../_images/mathmpl/math-b1eaade554.png" style="position: relative; bottom: -7px"/>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>init</strong> : dict</p>
<blockquote>
<div><p>Dictionary containing initial values for the calibration algorithm (see <a class="reference internal" href="../intro.html#ref2" id="id7">[Ref2]</a>, Table 1).
Keys must belong to this list:</p>
<ul class="simple">
<li>sx, sy: number of mm for each pixel in US image, for horizontal and vertical axis (in <em>mm/pixel</em>)</li>
<li>x1, y1, z1: coordinates (in <em>mm</em>) of vector pointing from US probe reference frame origin to the US image reference frame origin.</li>
<li>gamma1, beta1, alpha1: rotation angles (in <em>rad</em>) representing consecutive rotations around the US image reference frame axis (X, Y and Z). This rotations would get it oriented as the US probe reference frame (see <a class="reference external" href="http://kwon3d.com/theory/euler/euler_angles.html">here</a> for more details). Use opposite sign with respect to the <a class="reference external" href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a></li>
<li>x2, y2, z2: coordinates (in <em>mm</em>) of vector pointing from global reference frame origin to the calibration phantom reference frame origin.</li>
<li>gamma2, beta2, alpha2: same meaning as gamma1, beta1, alpha1, but now the rotations are from global reference frame to probe reference frame.</li>
</ul>
<p>If <tt class="docutils literal"><span class="pre">method='eq_based'</span></tt>, only the following variables have to be present: &#8216;sx&#8217;, &#8216;sy&#8217;, &#8216;x1&#8217;, &#8216;y1&#8217;, &#8216;z1&#8217;, &#8216;alpha1&#8217;, &#8216;beta1&#8217;, &#8216;gamma1&#8217;, &#8216;x2&#8217;, &#8216;y2&#8217;, &#8216;z2&#8217;, &#8216;alpha2&#8217;, &#8216;beta2&#8217;, &#8216;gamma2&#8217;.
If <tt class="docutils literal"><span class="pre">method='maximize_NCCint'</span></tt> or <tt class="docutils literal"><span class="pre">'maximize_NCC'</span></tt>, only the following variables have to be present: &#8216;x1&#8217;, &#8216;y1&#8217;, &#8216;z1&#8217;, &#8216;alpha1&#8217;, &#8216;beta1&#8217;, &#8216;gamma1&#8217;.</p>
</div></blockquote>
<p><strong>xtol</strong> : float</p>
<blockquote>
<div><p>Relative error desired in the approximate solution (see argument <tt class="docutils literal"><span class="pre">options['xtol']</span></tt> or <tt class="docutils literal"><span class="pre">tol</span></tt> in <tt class="docutils literal"><span class="pre">scipy.optimize.root()</span></tt>).</p>
</div></blockquote>
<p><strong>ftol</strong> : float</p>
<blockquote>
<div><p>Relative error desired in the sum of squares (see argument <tt class="docutils literal"><span class="pre">options['ftol']</span></tt> in <tt class="docutils literal"><span class="pre">scipy.optimize.root()</span></tt>).</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>Method used to estimate calibration parameters.
If &#8216;eq_based&#8217;, a system of equations (representing contraints) will be solved (see <a class="reference internal" href="../intro.html#ref2" id="id8">[Ref2]</a>).
If &#8216;maximize_NCCint&#8217;, the algorithm used is a modification of the one described in <a class="reference internal" href="../intro.html#ref3" id="id9">[Ref3]</a>. It aims at maximizing the average Normalized Cross-Correlation of the intersection of pair of US images.
If &#8216;maximize_NCC&#8217; or &#8216;maximize_NCCfast&#8217;, the algorithm used is described in <a class="reference internal" href="../intro.html#ref3" id="id10">[Ref3]</a>.</p>
</div></blockquote>
<p><strong>method_args</strong> : dict</p>
<blockquote>
<div><p>Further arguments for method used.
If <tt class="docutils literal"><span class="pre">method='eq_based'</span></tt>, it must contain the following keys:</p>
<ul class="simple">
<li>&#8216;phantom&#8217;: calibration phantom type (see <a class="reference internal" href="../intro.html#ref2" id="id11">[Ref2]</a>). 
If &#8216;single_wall&#8217;, the calibration equations system is solved by using formula 8 in <a class="reference internal" href="../intro.html#ref2" id="id12">[Ref2]</a>. Variables x2, y2, alpha2 will be forced to 0.</li>
</ul>
<p>If <tt class="docutils literal"><span class="pre">method='maximize_NCCint'</span></tt>, it must contain the following keys:</p>
<ul class="simple">
<li>&#8216;frames&#8217;: If &#8216;all_combos_in&#8217;, then all the frames combinations in a interval will be used. If list, each element must be a list of 2 elements, representing a frames combination for NCC calculation.</li>
<li>&#8216;frames_interval&#8217;: see &#8216;frames&#8217;.</li>
</ul>
<p>NCC values, each one related to a couple of frames, will be averaged.</p>
<p>If <tt class="docutils literal"><span class="pre">method='maximize_NCC'</span></tt> or <tt class="docutils literal"><span class="pre">method='maximize_NCCfast'</span></tt>, it must contain the following keys:</p>
<ul class="simple">
<li>&#8216;sweep_frames&#8217;: 2-elem list where the first element is a list of original images sweep frames and the second element is a 2-elem list defining start and end frame of the reconstruction sweep.</li>
<li>&#8216;imag_comp_save_path&#8217;: if not empty, it will be used to save each the couple original image - reconstruction for each iteration. 
Each file name is in the format it&lt;itn&gt;_im&lt;ofn&gt;.jpeg, where &lt;itn&gt; is the iteration number (for Nelder-Mead method), &lt;ofn&gt; is the original image frame number.</li>
<li>&#8216;max_expr&#8217;: expression to maximize.
If &#8216;avg_NCC&#8217;, the NCCs calculated for each wanted pair original frame vs reconstruction template will be averaged.
If &#8216;weighted_avg_NCC&#8217;, the NCCs calculated for each wanted pair original frame vs reconstruction template will be averaged using as weigths the percentage of reconstructed template.
This percentage, in the bottom-left picture in the figures saved in &#8216;imag_comp_save_path&#8217;, corresponds to the ratio between the area occupied by the straight lines and the image size.</li>
</ul>
<p>Common parameters for all NCC-based methods:</p>
<ul class="simple">
<li>&#8216;th_z&#8217;: threshold value (in <em>mm</em>) under which points on a reconstruction sweep can be considered belonging to an original image plane.</li>
</ul>
<p>NCC values, each one related to one frame from the first sweep and the reconstruction sweep, will be averaged.</p>
</div></blockquote>
<p><strong>fixed</strong> : list</p>
<blockquote>
<div><p>List of variable name for which the value is exactly known.
These variables become constant in the calibration equations. For the list of allowed names, see argument <tt class="docutils literal"><span class="pre">init</span></tt>.</p>
</div></blockquote>
<p><strong>correctResults</strong> : bool</p>
<blockquote class="last">
<div><p>Correct for mirror solutions.
According to the Appendix of <a class="reference internal" href="../intro.html#ref2" id="id13">[Ref2]</a>, calculated variables could bring to &#8216;mirror solutions&#8217;. This flag will bring them to a standard form.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.evalCalibMatrix">
<tt class="descname">evalCalibMatrix</tt><big>(</big><em>x</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.evalCalibMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.evalCalibMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p><em>(static)</em> Evaluate calibration matrix with parameters values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : dict</p>
<blockquote>
<div><p>See param <tt class="docutils literal"><span class="pre">init</span></tt> for function <tt class="docutils literal"><span class="pre">calibrateProbe()</span></tt>. Only the following keys will be used: alpha1, beta1, gamma1, x1, y1, z1.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>prRim</strong> : np.ndarray</p>
<blockquote>
<div><p>3 x 3 rotation matrix from US image reference frame to probe reference frame.</p>
</div></blockquote>
<p><strong>Tim</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>3-elem vector (in <em>mm</em>), expressed in probe reference frame, from probe reference frame origin to US image reference frame origin.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.exportVoxelArraySilhouetteToVTI">
<tt class="descname">exportVoxelArraySilhouetteToVTI</tt><big>(</big><em>outFile</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.exportVoxelArraySilhouetteToVTI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.exportVoxelArraySilhouetteToVTI" title="Permalink to this definition">¶</a></dt>
<dd><p>Export US scan silhouette voxel-array to VTI file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outFile</strong> : str</p>
<blockquote class="last">
<div><p>Full file path for the VTI file to be saved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.exportVoxelArrayToVTI">
<tt class="descname">exportVoxelArrayToVTI</tt><big>(</big><em>outFile</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.exportVoxelArrayToVTI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.exportVoxelArrayToVTI" title="Permalink to this definition">¶</a></dt>
<dd><p>Export grey-values voxel-array to VTI file.</p>
<p>VTI is a VTK file format (see <a class="reference external" href="http://www.cacr.caltech.edu/~slombey/asci/vtk/vtk_formats.simple.html">here</a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outFile</strong> : str</p>
<blockquote class="last">
<div><p>Full file path for the VTI file to be saved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.extractFeatureFromUSImages">
<tt class="descname">extractFeatureFromUSImages</tt><big>(</big><em>feature='2_points_on_line'</em>, <em>segmentation='manual'</em>, <em>segParams={}</em>, <em>showViewer=True</em>, <em>featuresFile=None</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.extractFeatureFromUSImages"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.extractFeatureFromUSImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract features (points, lines, ...) from US images.</p>
<p>The used file will be the one indicated in method <tt class="docutils literal"><span class="pre">setUSFiles()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>feature</strong> : str</p>
<blockquote>
<div><p>target feature type.
If &#8216;2_points_on_line&#8217;, the features under consideration are 2 points on the longest edge line in the image.
If &#8216;2_points&#8217;, the features under consideration are 2 manually defined points.
If &#8216;1_point&#8217;, the feature under consideration is 1 manually defined point.
If &#8216;mask&#8217;, the feature under consideration is a suset of pixels of the image.</p>
</div></blockquote>
<p><strong>segmentation</strong> : str</p>
<blockquote>
<div><p>Segmentation method.
If &#8216;manual&#8217;, an interactive window will be popped up and the user will be able to select manually the features image per image. 
If &#8216;auto_hough&#8217; (only for <tt class="docutils literal"><span class="pre">feature='2_points_on_line'</span></tt>), the longest line will be automatically detected by the Hough transform and 2 points will be place on that line according to <tt class="docutils literal"><span class="pre">segParams</span></tt>.</p>
</div></blockquote>
<p><strong>segParams</strong> : dict</p>
<blockquote>
<div><p>Parameters for features extraction.
If <tt class="docutils literal"><span class="pre">segmentation='auto_hough'</span></tt>:</p>
<ul class="simple">
<li>&#8216;par_seg&#8217;: see <tt class="docutils literal"><span class="pre">parSeg</span></tt> in <tt class="docutils literal"><span class="pre">SegmentPointsHoughUI.__init__()</span></tt>.</li>
<li>&#8216;data_constr&#8217;: see <tt class="docutils literal"><span class="pre">dataConstr</span></tt> in <tt class="docutils literal"><span class="pre">SegmentPointsHoughUI.__init__()</span></tt>.</li>
<li>&#8216;save_data_path&#8217;: see <tt class="docutils literal"><span class="pre">saveDataPath</span></tt> in <tt class="docutils literal"><span class="pre">SegmentPointsHoughUI.__init__()</span></tt>.</li>
</ul>
<p>If <tt class="docutils literal"><span class="pre">segmentation='mask'</span></tt>, see <tt class="docutils literal"><span class="pre">maskParams</span></tt> in <tt class="docutils literal"><span class="pre">MaskImageUI.__init__()</span></tt>.</p>
</div></blockquote>
<p><strong>showViewer</strong> : bool</p>
<blockquote>
<div><p>If True, it pops up a viewer to show or edit the features.</p>
</div></blockquote>
<p><strong>featuresFile</strong> : mixed</p>
<blockquote class="last">
<div><p>Features file path.
If None, it will be ignored. Othwerwise, it must indicate the full path of a previously saved. This contains features data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.fillGaps">
<tt class="descname">fillGaps</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.fillGaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.fillGaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the gap-filling procedure.
This task can take some time.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getAdjustedUSTimeVector">
<tt class="descname">getAdjustedUSTimeVector</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getAdjustedUSTimeVector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getAdjustedUSTimeVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Get adjusted US time vector (see <tt class="docutils literal"><span class="pre">adjustUSTimeVector()</span></tt>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>Adjusted US time vector.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getDevicesTimeDelay">
<tt class="descname">getDevicesTimeDelay</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getDevicesTimeDelay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getDevicesTimeDelay" title="Permalink to this definition">¶</a></dt>
<dd><p>Get estimated delay between the US device and the optoelectronic device
(See method <tt class="docutils literal"><span class="pre">calculateDevicesTimeDelay()</span></tt>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>Time delay (in <em>seconds</em>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getImageCornersAs3DPoints">
<tt class="descname">getImageCornersAs3DPoints</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getImageCornersAs3DPoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getImageCornersAs3DPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Create virtual 3D points for US images corners with respect to the global reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>Dictionary where keys are 4 marker names and values are np.ndarray
N x 3 matrices, representing point coordinates, for N time frames.
The following are the points created:</p>
<ul class="simple">
<li>im_TR: top-right corner</li>
<li>im_BR: bottom-right corner</li>
<li>im_TL: top-left corner</li>
<li>im_BL: bottom-left corner</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getKineFiles">
<tt class="descname">getKineFiles</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getKineFiles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getKineFiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get kinematics files list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>List of kinematics files.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getPoseForUSImages">
<tt class="descname">getPoseForUSImages</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getPoseForUSImages"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getPoseForUSImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the pose of the US images with respect to the global reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>N x 4 x 4 pose, for N time frames.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getProbeCalibrationAccuracy">
<tt class="descname">getProbeCalibrationAccuracy</tt><big>(</big><em>acc='DA'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getProbeCalibrationAccuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getProbeCalibrationAccuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get estimated calibration accuracy data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>acc</strong> : str</p>
<blockquote>
<div><p>See method <tt class="docutils literal"><span class="pre">calculateProbeCalibrationAccuracy()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>listDA</strong> : np.ndarray</p>
<blockquote>
<div><p>Array containing as many values as the keys into <tt class="docutils literal"><span class="pre">points</span></tt>. 
If 2 points where indicated in the corresponding US image, 
than the value corresponds to the difference between the 
points distance and <tt class="docutils literal"><span class="pre">L</span></tt>, <tt class="docutils literal"><span class="pre">np.nan</span></tt> otherwise.</p>
</div></blockquote>
<p><strong>DA</strong> : float</p>
<blockquote class="last">
<div><p>Mean of <tt class="docutils literal"><span class="pre">listDA</span></tt> ignoring nans.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getProbeCalibrationData">
<tt class="descname">getProbeCalibrationData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getProbeCalibrationData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getProbeCalibrationData" title="Permalink to this definition">¶</a></dt>
<dd><p>Get calibration results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>prRim</strong> : np.ndarray</p>
<blockquote>
<div><p>3 x 3 rotation matrix from US image reference frame to probe reference frame.</p>
</div></blockquote>
<p><strong>Tim</strong> : np.ndarray</p>
<blockquote>
<div><p>3-elem vector (in <em>mm</em>), expressed in probe reference frame, from probe reference frame origin to US image reference frame origin.</p>
</div></blockquote>
<p><strong>sx, sy</strong> : float</p>
<blockquote>
<div><p>See method <tt class="docutils literal"><span class="pre">calibrateProbe()</span></tt>.</p>
</div></blockquote>
<p><strong>calib</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary with the following fields:</p>
<ul class="simple">
<li>root_sol (<em>Result</em>) – contains output from <tt class="docutils literal"><span class="pre">scipy.optimize.root()</span></tt>.</li>
<li>root_vars (<em>list</em>) – contains variables names (see argument <tt class="docutils literal"><span class="pre">init</span></tt> for argument <tt class="docutils literal"><span class="pre">calibrateProbe()</span></tt>).</li>
<li>RMS (<em>float</em>) – RMS of the equations residuals (only for <tt class="docutils literal"><span class="pre">method='eq_based'</span></tt> in <tt class="docutils literal"><span class="pre">calibrateProbe()</span></tt>)</li>
<li>kond (<em>int</em>) – Condition number calculated as the ratio between max and min eigenvalues from the SVD decomposition of <em>Jacobian</em> matrix calculated in the solution point (only for <tt class="docutils literal"><span class="pre">method='eq_based'</span></tt> in <tt class="docutils literal"><span class="pre">calibrateProbe()</span></tt>).</li>
<li>cov_x (<em>np.ndarray</em>) – covariance matrix differing from calib[&#8216;root_sol&#8217;].cov_x for a multiplying factor being sum of squared residuals divided by degrees of freedom (only for <tt class="docutils literal"><span class="pre">method='eq_based'</span></tt> in <tt class="docutils literal"><span class="pre">calibrateProbe()</span></tt>).</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getProbeCalibrationPrecision">
<tt class="descname">getProbeCalibrationPrecision</tt><big>(</big><em>prec='RP'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getProbeCalibrationPrecision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getProbeCalibrationPrecision" title="Permalink to this definition">¶</a></dt>
<dd><p>Get estimated calibration precision data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>prec</strong> : str</p>
<blockquote>
<div><p>See method <tt class="docutils literal"><span class="pre">calculateProbeCalibrationPrecision()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>Precision estimation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getUSFiles">
<tt class="descname">getUSFiles</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getUSFiles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getUSFiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get US files list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>List of US files.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getVoxelArrayPose">
<tt class="descname">getVoxelArrayPose</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getVoxelArrayPose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getVoxelArrayPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return roto-translation matrix from voxel array reference frame to global reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>4 x 4 rototranslation matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.getVoxelPhysicalSize">
<tt class="descname">getVoxelPhysicalSize</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.getVoxelPhysicalSize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.getVoxelPhysicalSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Get physical size for a single voxel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>3-elem list with voxel dimensions (in <em>mm</em>) for each direction.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.initVoxelArray">
<tt class="descname">initVoxelArray</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.initVoxelArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.initVoxelArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize voxel array. It instantiate data for the voxel array grey values.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setDataSourceProperties">
<tt class="descname">setDataSourceProperties</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setDataSourceProperties"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setDataSourceProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data source properties (for US and/or optoelectronic system).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kineFreq</strong> : int, optional</p>
<blockquote>
<div><p>Optoelectronic system frequency (in <em>Hz</em>).</p>
</div></blockquote>
<p><strong>USFreq</strong> : int, optional</p>
<blockquote>
<div><p>US system frequency (in <em>Hz</em>).</p>
</div></blockquote>
<p><strong>w</strong> : int, optional</p>
<blockquote>
<div><p>US image width (in <em>pixels</em>).</p>
</div></blockquote>
<p><strong>h</strong> : int, optional</p>
<blockquote>
<div><p>US image height (in <em>pixels</em>).</p>
</div></blockquote>
<p><strong>USTimeVector</strong> : list, optional</p>
<blockquote>
<div><p>List of time instants (in <em>s</em>) in which US frame were recorded.
If multiple US files are provided in <tt class="docutils literal"><span class="pre">setUSFiles()</span></tt>, the length 
of this parameter must be equal to the sum of the frame numbers for
each US file.</p>
</div></blockquote>
<p><strong>fromUSFiles</strong> : list, optional</p>
<blockquote>
<div><p>List DICOM file paths from which to extract US data properties.
If specified, w, h, USTimeVector, USFreq provided as input will be 
ignored and will be parsed from these files</p>
</div></blockquote>
<p><strong>pixel2mmX, pixel2mmY</strong> : float; optional</p>
<blockquote class="last">
<div><p>Number of mm for each pixel in US image, for horizontal and 
vertical axis (in <em>mm/pixel</em>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setDevicesTimeDelay">
<tt class="descname">setDevicesTimeDelay</tt><big>(</big><em>timeDelay</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setDevicesTimeDelay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setDevicesTimeDelay" title="Permalink to this definition">¶</a></dt>
<dd><p>Set delay between the US device and the optoelectronic device.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>timeDelay</strong> : float</p>
<blockquote class="last">
<div><p>Time delay (in <em>seconds</em>) between the two devices. If positive, US device is early.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setGapFillingParameters">
<tt class="descname">setGapFillingParameters</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setGapFillingParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setGapFillingParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set parameters for gap filling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : str</p>
<blockquote>
<div><p>Method for filling gaps.
If &#8216;VNN&#8217; (Voxel Nearest Neighbour, default), the nearest voxel to the gap is
used to fill the gap. Arguments <tt class="docutils literal"><span class="pre">maxS</span></tt> and <tt class="docutils literal"><span class="pre">minPct</span></tt> will be ignored.
If <a href="#id15"><span class="problematic" id="id16">``</span></a>distTh` is set, voxels with a distance greater than this threshold will
be ignored when filling gaps.
If &#8216;AVG_CUBE&#8217;, this procedure is applied:</p>
<blockquote>
<div><ol class="arabic simple">
<li>create a cube with side 3 voxels, centered around the gap</li>
<li>search for a minimum <tt class="docutils literal"><span class="pre">minPct</span></tt> percentage of non-gaps inside the cube (100% = number of voxels in the cube)</li>
<li>if that percentage is found, a non-gap voxels average (wighted by the Euclidean distances) is performed into the cube</li>
<li>if that percentage is not found, the cube size in incremented by 2 voxels</li>
<li>if cube size is lesser than maxS, start again from point 2. Otherwise, stop and don&#8217;t fill the gap.</li>
</ol>
</div></blockquote>
<p>This method is much slower than &#8216;VNN&#8217;, but allows to limit the search area.</p>
</div></blockquote>
<p><strong>maxS</strong> : int</p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">method</span></tt>. This number must be an odd number. Default to 1.</p>
</div></blockquote>
<p><strong>minPct</strong> : float</p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">method</span></tt>. This value must be between 0 and 1. Default to 0.</p>
</div></blockquote>
<p><strong>blocksN</strong> : int</p>
<blockquote>
<div><p>Positive number (greater or equal than 1) indicating the number of
subvoxel-arrays into which to decompose the gap-filling problem. This can be tuned to
modify computation time and memory usage. Default to 100.</p>
</div></blockquote>
<p><strong>blockDir</strong> : str</p>
<blockquote>
<div><p>String defining the direction for blocks motion.
It can be &#8216;X&#8217;, &#8216;Y&#8217;, &#8216;Z&#8217;.</p>
</div></blockquote>
<p><strong>distTh</strong> : int</p>
<blockquote class="last">
<div><p>See <tt class="docutils literal"><span class="pre">method</span></tt>. This must be greater or equal than 1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p><em>Only</em> the gaps internal to the wrapper created by <tt class="docutils literal"><span class="pre">alighImages()</span></tt> will beconsidered.
If a gap is not filled, its value will be considered the same as a <em>completely black</em> voxel.
See chapter <a class="reference internal" href="../tutorial/when_mem_error.html#when-mem-error"><em>In case of MemoryError</em></a> for tips about setting these parameters.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setKineFiles">
<tt class="descname">setKineFiles</tt><big>(</big><em>kineFiles</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setKineFiles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setKineFiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Set kinematics files list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kineFiles</strong> : list</p>
<blockquote class="last">
<div><p>List of kinematics files.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setProbeCalibrationData">
<tt class="descname">setProbeCalibrationData</tt><big>(</big><em>prRim</em>, <em>Tim</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setProbeCalibrationData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setProbeCalibrationData" title="Permalink to this definition">¶</a></dt>
<dd><p>Set probe calibration data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>prRim</strong> : np.ndarray</p>
<blockquote>
<div><p>See method <tt class="docutils literal"><span class="pre">getProbeCalibrationData()</span></tt>.</p>
</div></blockquote>
<p><strong>Tim</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>See method <tt class="docutils literal"><span class="pre">getProbeCalibrationData()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setScaleFactors">
<tt class="descname">setScaleFactors</tt><big>(</big><em>fxyz</em>, <em>voxFramesBounds=None</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setScaleFactors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setScaleFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or calculate scale factors that multiply real voxel-array dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fxyz</strong> : mixed</p>
<blockquote>
<div><p>Scale factors.
If list, it must contain 3 elements being the scale factors
If &#8216;auto_bounded_parallel_scans&#8217;, the following should hold:</p>
<ul class="simple">
<li>the US probe motion is supposed to be performed mainly along one axis (X);</li>
<li>corners of the US images during acquisition are supposed to not deviate too much from a straight line (along X);</li>
<li>motion velocity is supposed to be constant;</li>
<li>pixel/mm for US images are very similar for width and height.</li>
</ul>
<p>Scale factors are calculated as follows:</p>
<ul class="simple">
<li>fx: ceil(abs((voxFramesBounds[1] - voxFramesBounds[0]) / (C1 - C0)));</li>
<li>fy, fz: ceil(1 / pixel2mmX).</li>
</ul>
<p>where:</p>
<ul class="simple">
<li>C0 and C1 are the X coordinates (in <em>mm</em>) of the US image centers at frames <tt class="docutils literal"><span class="pre">voxFramesBounds[0]</span></tt> and <tt class="docutils literal"><span class="pre">voxFramesBounds[1]</span></tt>;</li>
<li>pixel2mmX is the conversion factor (in <em>mm/pixel</em>) for width in the US images.</li>
</ul>
<p>See chapter <a class="reference internal" href="../tutorial/when_mem_error.html#when-mem-error"><em>In case of MemoryError</em></a> for the use of these scale factors.</p>
</div></blockquote>
<p><strong>voxFramesBounds</strong> : mixed</p>
<blockquote class="last">
<div><p>Bounding frames for the list of frames to be contained in the voxel array.
If None, first and last time frames out of <tt class="docutils literal"><span class="pre">setValidFramesForVoxelArray()</span></tt> will be used.
If list, it must contain 2 elements specifying lower and upper bround frames.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setUSFiles">
<tt class="descname">setUSFiles</tt><big>(</big><em>usFiles</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setUSFiles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setUSFiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Set US files list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>usFiles</strong> : list</p>
<blockquote class="last">
<div><p>List of US files.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setUSImagesAlignmentParameters">
<tt class="descname">setUSImagesAlignmentParameters</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setUSImagesAlignmentParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setUSImagesAlignmentParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set parameters for US scans alignement in global reference frame.
See chapter <a class="reference internal" href="../tutorial/when_mem_error.html#when-mem-error"><em>In case of MemoryError</em></a> for tips about setting these parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>wrapper</strong> : str</p>
<blockquote>
<div><p>Type of wrapper to create scanning silhouette.
If &#8216;parallelepipedon&#8217;, the smallest wrapping paralellepipedon (with
dimensions aligned with the global reference frame) is created between
two US scans.
If &#8216;convex_hull&#8217;, the convex hull is created between two US scans.
This one is more accurate than &#8216;parallelepipedon&#8217;, but it takes more
time to be created.
If &#8216;none&#8217; (default), no wrapper is created.</p>
<a class="reference internal image-reference" href="../_images/parall_vs_convexhull.png"><img alt="../_images/parall_vs_convexhull.png" src="../_images/parall_vs_convexhull.png" style="width: 679.5px; height: 588.5px;" /></a>
</div></blockquote>
<p><strong>step</strong> : int</p>
<blockquote>
<div><p>Interval (in number of US frames) between two US scans
used to create the wrapper. Default to 1.</p>
</div></blockquote>
<p><strong>alignFrames</strong> : list</p>
<blockquote>
<div><p>List of frames (US time line) on which to perform US images alignment.</p>
</div></blockquote>
<p><strong>fillVoxMethod</strong> : str</p>
<blockquote class="last">
<div><p>Method for filling each voxel.
If &#8216;avg&#8217;, an average between the current voxel value and the new value 
is performed.
If &#8216;last&#8217;, the new voxel value will replace the current one.
If &#8216;max&#8217;, the highest voxel value will replace the current one.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setValidFramesForVoxelArray">
<tt class="descname">setValidFramesForVoxelArray</tt><big>(</big><em>voxFrames='auto'</em>, <em>voxFramesBounds=None</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setValidFramesForVoxelArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setValidFramesForVoxelArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of frames (US time line) of the images that can be contained in the voxel array.
Frames are further filtered out based on the invalid kinematics frames calculated 
by <tt class="docutils literal"><span class="pre">calculatePoseForUSProbe()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>voxFrames</strong> : mixed</p>
<blockquote>
<div><p>List of US time frames.
If &#8216;auto&#8217;, all the frames without missing optoelectronic data information will be considered.       
If &#8216;all&#8217;, all the frames will be considered.
If list, it must contain the list of frames to be considered.</p>
</div></blockquote>
<p><strong>voxFramesBounds</strong> : mixed</p>
<blockquote class="last">
<div><p>Bounding frames for the list of frames to be contained in the voxel array.
If None, all the frames out of <tt class="docutils literal"><span class="pre">voxFrames</span></tt> will be used.
If list, it must contain 2 elements specifying lower and upper bround frames for the list in <tt class="docutils literal"><span class="pre">voxFrames</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.process.Process.setVtkImageDataProperties">
<tt class="descname">setVtkImageDataProperties</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/process.html#Process.setVtkImageDataProperties"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.process.Process.setVtkImageDataProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Set parameters of <tt class="docutils literal"><span class="pre">vtkImageData</span></tt> object.</p>
<p>Whenever a <tt class="docutils literal"><span class="pre">vtkImageData</span></tt> has to be created (e.g. for exportation purpose)
from the internal voxel-array structure, these parameters are used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sxyz</strong> : mixed</p>
<blockquote class="last">
<div><p>Spacing factors fot object.
If list, it must contain 3 elements containing spacing factors for each voxel dimension (see <a class="reference external" href="http://www.vtk.org/doc/nightly/html/classvtkImageData.html#ab3288d13810266e0b30ba0632f7b5b0b">here</a>).
If &#8216;auto&#8217;, spacing factors are automatically calculated using scale factors <tt class="docutils literal"><span class="pre">fxyz</span></tt> (see method <tt class="docutils literal"><span class="pre">initVoxelArray()</span></tt>)
Each factor <em>s</em> is calculated by using the correspoding scale factor <em>f</em> as: s = LCM(fx,fy,fz) / f,
where LCM is the Least Minimum Multiple operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.calib">
<span id="calib"></span><h2><tt class="docutils literal"><span class="pre">calib</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.calib" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-calib"></span><dl class="function">
<dt id="Py3DFreeHandUS.calib.MatrixOfMatrixSymbol">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">MatrixOfMatrixSymbol</tt><big>(</big><em>b</em>, <em>r</em>, <em>c</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#MatrixOfMatrixSymbol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.MatrixOfMatrixSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Emulates <tt class="docutils literal"><span class="pre">Matrix(MatrixSymbol(b,</span> <span class="pre">r,</span> <span class="pre">c))</span></tt> as for SymPy version 0.7.2-.</p>
<p>From SymPy 0.7.5+, <tt class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">Matrix(MatrixSymbol(b,</span> <span class="pre">r,</span> <span class="pre">c))</span></tt> is not safe since:</p>
<ul class="simple">
<li>the format of symbols has changed fomr s_ij to s[i, j]</li>
<li>the method <tt class="docutils literal"><span class="pre">M.inv()</span></tt> is broken</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.calculateDA">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">calculateDA</tt><big>(</big><em>T</em>, <em>sx</em>, <em>sy</em>, <em>points</em>, <em>L</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#calculateDA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.calculateDA" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Distance Accuracy, as indicated in <a class="reference internal" href="../intro.html#ref2" id="id18">[Ref2]</a>. It needs
2 single-point features to be extracted for some US images of a calibration 
quality assessment acquisition. These 2 points (each for different US images)
are reconstructed in and the distance is calculated. This process can be
repeated for other couples of US images. For instance, if one point is indicated
for frames 1, 4, 10, 15, 25, 40, then 3 distances are calculated (1-4, 10-15, 25-40).
DA is the mean of the difference between these distances and the gold-standard
measured real distance <tt class="docutils literal"><span class="pre">L</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>T</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 4 x 4 array where <tt class="docutils literal"><span class="pre">T[i,:,:]</span></tt> represents the roto-translation matrix from US image reference frame to global reference frame, for time frame <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</div></blockquote>
<p><strong>sx, sy</strong> : float</p>
<blockquote>
<div><p>Number of mm for each pixel in US image, for horizontal and vertical axis (in <em>mm/pixel</em>).</p>
</div></blockquote>
<p><strong>points</strong> : dict</p>
<blockquote>
<div><p>Dictionary where keys are frame numbers and values are lists of tuples, each one representing a point position in the corresponding US image. Only one tuple is needed.</p>
</div></blockquote>
<p><strong>L</strong> : float</p>
<blockquote>
<div><p>Gold-standard distance (in <em>mm</em>) for distance accuracy estimation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>listDA</strong> : np.ndarray</p>
<blockquote>
<div><p>Array containing distances, each on calculated by using points from 2 consecutive frame numbers from <tt class="docutils literal"><span class="pre">points</span></tt>.</p>
</div></blockquote>
<p><strong>DA</strong> : float</p>
<blockquote class="last">
<div><p>Mean of <tt class="docutils literal"><span class="pre">listDA</span></tt> ignoring nans.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.calculateRA">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">calculateRA</tt><big>(</big><em>T</em>, <em>sx</em>, <em>sy</em>, <em>points</em>, <em>P</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#calculateRA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.calculateRA" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Reconstruction Accuracy, as indicated in <a class="reference internal" href="../intro.html#ref2" id="id19">[Ref2]</a>. It needs
1 single-point feature to be extracted for some US images of a calibration 
quality assessment acquisition. These points (each for different US images)
are reconstructed in global reference frame. RA is the mean of the norm of
the difference between these points and the gold-standard points <tt class="docutils literal"><span class="pre">P</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>T</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 4 x 4 array where <tt class="docutils literal"><span class="pre">T[i,:,:]</span></tt> represents the roto-translation matrix from US image reference frame to global reference frame, for time frame <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</div></blockquote>
<p><strong>sx, sy</strong> : float</p>
<blockquote>
<div><p>Number of mm for each pixel in US image, for horizontal and vertical axis (in <em>mm/pixel</em>).</p>
</div></blockquote>
<p><strong>points</strong> : dict</p>
<blockquote>
<div><p>Dictionary where keys are frame numbers and values are lists of tuples, each one representing a point position in the corresponding US image. Only one tuple is needed.</p>
</div></blockquote>
<p><strong>P</strong> : np.ndarray</p>
<blockquote>
<div><p>Gold-standard 3D positions (in <em>mm</em>) for reconstruction accuracy estimation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist</strong> : np.ndarray</p>
<blockquote>
<div><p>Array containing distances, each on calculated by using a real 3D point and the reconstructed 3D point.</p>
</div></blockquote>
<p><strong>DA</strong> : float</p>
<blockquote class="last">
<div><p>Mean of <tt class="docutils literal"><span class="pre">dist</span></tt> ignoring nans.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.calculateRP">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">calculateRP</tt><big>(</big><em>T</em>, <em>sx</em>, <em>sy</em>, <em>points</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#calculateRP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.calculateRP" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate point reconstruction reconstruction precision, as in <a class="reference internal" href="../intro.html#ref1" id="id20">[Ref1]</a>. 
It needs single-point feature to be extracted for some US images of a calibration 
quality assessment acquisition. The points are the reconstructed in 
3D space, creating a cloud of points. RP is the mean of the distances
between each 3D point and the 3D average point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>T</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 4 x 4 array where <tt class="docutils literal"><span class="pre">T[i,:,:]</span></tt> represents the roto-translation matrix from US image reference frame to global reference frame, for time frame <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</div></blockquote>
<p><strong>sx, sy</strong> : float</p>
<blockquote>
<div><p>Number of mm for each pixel in US image, for horizontal and vertical axis (in <em>mm/pixel</em>).</p>
</div></blockquote>
<p><strong>points</strong> : dict</p>
<blockquote>
<div><p>dictionary where keys are frame numbers and values are lists of tuples, each one representing a point position in the corresponding US image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>Reconstruction precision value</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.calculateTimeDelayXCorr">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">calculateTimeDelayXCorr</tt><big>(</big><em>s1</em>, <em>s2</em>, <em>s1Label</em>, <em>s2Label</em>, <em>timeVector</em>, <em>step</em>, <em>lagsBound=None</em>, <em>withPlots=True</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#calculateTimeDelayXCorr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.calculateTimeDelayXCorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the delay between two normalized signals by cross-correlation.
Normalization consists of demeaning and dividing by the maximum of the rectified signal.
From the cross-correlation signal, the maximum value within the time range 
(<tt class="docutils literal"><span class="pre">-lagsBound</span></tt>, <tt class="docutils literal"><span class="pre">lagsBound</span></tt>), in <em>s</em>, is found. The time instant in
which that maximum occurs is the time delay estimation.
If positive, <tt class="docutils literal"><span class="pre">s2</span></tt> is early with respect to <tt class="docutils literal"><span class="pre">s1</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s1, s2</strong> : np.ndarray</p>
<blockquote>
<div><p>Mono-dimensional arrays representing the signals to cross-correlate.</p>
</div></blockquote>
<p><strong>s1Label, s2Label</strong> : str</p>
<blockquote>
<div><p>Strings for <tt class="docutils literal"><span class="pre">s1</span></tt> and <tt class="docutils literal"><span class="pre">s2</span></tt> to show in plots.</p>
</div></blockquote>
<p><strong>timeVector</strong> : np.ndarray</p>
<blockquote>
<div><p>Time line (in <em>s</em>) for both original signals <tt class="docutils literal"><span class="pre">s1</span></tt> and <tt class="docutils literal"><span class="pre">s2</span></tt>.
It must contain the same number of frames as <tt class="docutils literal"><span class="pre">s1</span></tt> and <tt class="docutils literal"><span class="pre">s2</span></tt>.</p>
</div></blockquote>
<p><strong>step</strong> : float</p>
<blockquote>
<div><p>Resampling step for new time line for <tt class="docutils literal"><span class="pre">s1</span></tt> and <tt class="docutils literal"><span class="pre">s2</span></tt>.
The new time line goes from <tt class="docutils literal"><span class="pre">timeVector[0]</span></tt> to <tt class="docutils literal"><span class="pre">timeVector[-1]</span></tt>.</p>
</div></blockquote>
<p><strong>lagsBounds</strong> : mixed</p>
<blockquote>
<div><p>Limiting range (in <em>s</em>) around which to search for the maximum cross-correlation value.
If None, all the time line willbe used.</p>
</div></blockquote>
<p><strong>withPlots</strong> : bool</p>
<blockquote>
<div><p>If True, plots for results willbe shown (in blocking mode).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>Estimated time delay (in <em>s</em>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.creatCalibMatrix">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">creatCalibMatrix</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#creatCalibMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.creatCalibMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and return symbolic expression of 4 x 4 affine rotation matrix from US probe reference frame to US image reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>prTi</strong> : sympy.matrices.matrices.MutableMatrix</p>
<blockquote>
<div><p>The matrix expression.</p>
</div></blockquote>
<p><strong>syms</strong> : list</p>
<blockquote class="last">
<div><p>List of <tt class="docutils literal"><span class="pre">sympy.core.symbol.Symbol</span></tt> symbol objects used to generate the expression.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.createCalibEquations">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">createCalibEquations</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#createCalibEquations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.createCalibEquations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and return symbolic calibration equations (1) in <a class="reference internal" href="../intro.html#ref2" id="id21">[Ref2]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Pph</strong> : sympy.matrices.matrices.MutableMatrix</p>
<blockquote>
<div><p>3 x 1 matrix containing symbolic equations (1) in <a class="reference internal" href="../intro.html#ref2" id="id22">[Ref2]</a>.</p>
</div></blockquote>
<p><strong>J</strong> : sympy.matrices.matrices.MutableMatrix*)</p>
<blockquote>
<div><p>3 x 14 matrix representing the Jacobian of equations <tt class="docutils literal"><span class="pre">Pph</span></tt>.</p>
</div></blockquote>
<p><strong>prTi</strong> : sympy.matrices.matrices.MutableMatrix*)</p>
<blockquote>
<div><p>4 x 4 affine rotation matrix from US probe reference frame to US image reference frame.</p>
</div></blockquote>
<p><strong>syms</strong> : dict</p>
<blockquote>
<div><p>Dictionary of where keys are variable names and values are <tt class="docutils literal"><span class="pre">sympy.core.symbol.Symbol</span></tt> objects. 
These symbols were used to create equations in <tt class="docutils literal"><span class="pre">Pph</span></tt>, <tt class="docutils literal"><span class="pre">J</span></tt>, <tt class="docutils literal"><span class="pre">prTi</span></tt>.</p>
</div></blockquote>
<p><strong>variables</strong> : list</p>
<blockquote>
<div><p>14-elem list of variable names (see <tt class="docutils literal"><span class="pre">process.Process.calibrateProbe()</span></tt>).</p>
</div></blockquote>
<p><strong>mus</strong> : list</p>
<blockquote class="last">
<div><p>14-elem list of varables measurement units.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.createCalibExpressionsForMaxNCC">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">createCalibExpressionsForMaxNCC</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#createCalibExpressionsForMaxNCC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.createCalibExpressionsForMaxNCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and return symbolic calibration roto-translation matrix in (3) in <a class="reference internal" href="../intro.html#ref3" id="id23">[Ref3]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>i2Ti1</strong> : sympy.matrices.matrices.MutableMatrix*)</p>
<blockquote>
<div><p>4 x 4 matrix containing symbolic roto-translation matrix in (3) in <a class="reference internal" href="../intro.html#ref3" id="id24">[Ref3]</a>.</p>
</div></blockquote>
<p><strong>prTi</strong> : sympy.matrices.matrices.MutableMatrix*)</p>
<blockquote>
<div><p>4 x 4 affine rotation matrix from US probe reference frame to US image reference frame.</p>
</div></blockquote>
<p><strong>syms</strong> : dict</p>
<blockquote>
<div><p>Dictionary of where keys are variable names and valuea are <tt class="docutils literal"><span class="pre">sympy.core.symbol.Symbol</span></tt> objects. These symbols
were used to create equations in <tt class="docutils literal"><span class="pre">i2Ti1</span></tt>.</p>
</div></blockquote>
<p><strong>variables</strong> : list</p>
<blockquote>
<div><p>6-elem list of variable names (see <tt class="docutils literal"><span class="pre">process.Process.calibrateProbe()</span></tt>).</p>
</div></blockquote>
<p><strong>mus</strong> : list</p>
<blockquote class="last">
<div><p>6-elem list of varables measurement units.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.maximizeNCC">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">maximizeNCC</tt><big>(</big><em>i2Ti1</em>, <em>syms</em>, <em>variables</em>, <em>init</em>, <em>Rpr</em>, <em>Tpr</em>, <em>I</em>, <em>pixel2mmX</em>, <em>pixel2mmY</em>, <em>frames</em>, <em>savePath</em>, <em>thZ</em>, <em>maxExpr</em>, <em>mask=None</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#maximizeNCC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.maximizeNCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimize a modification of expression (1) in <a class="reference internal" href="../intro.html#ref3" id="id25">[Ref3]</a>. More specifically, it aims at maximizing the average Normalized Cross-Correlation of the intersection of pair of US images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i2Ti1</strong> : sympy.core.add.Add:</p>
<blockquote>
<div><p>4 x 4 matrix containing symbolic roto-translation matrix in (3) in <a class="reference internal" href="../intro.html#ref3" id="id26">[Ref3]</a>.</p>
</div></blockquote>
<p><strong>syms</strong> : dict</p>
<blockquote>
<div><p>Dictionary of where keys are variable names and values are <tt class="docutils literal"><span class="pre">sympy.core.symbol.Symbol</span></tt> objects. These symbols were used to create equations in <tt class="docutils literal"><span class="pre">eq</span></tt>, <tt class="docutils literal"><span class="pre">J</span></tt>, <tt class="docutils literal"><span class="pre">prTi</span></tt>.</p>
</div></blockquote>
<p><strong>variables</strong> : list</p>
<blockquote>
<div><p>List of variable names (see <tt class="docutils literal"><span class="pre">process.Process.calibrateProbe()</span></tt>).</p>
</div></blockquote>
<p><strong>init</strong> : list</p>
<blockquote>
<div><p>List of initial values (same order of <tt class="docutils literal"><span class="pre">variables</span></tt>).</p>
</div></blockquote>
<p><strong>Rpr</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 array, where <tt class="docutils literal"><span class="pre">R[i,:,:]</span></tt> represents the rotation matrix from the US probe reference frame to the global reference frame, for time frame <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</div></blockquote>
<p><strong>Tpr</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 array, where <tt class="docutils literal"><span class="pre">Tpr[i,:]</span></tt> represents the vector from the global reference frame origin to the US probe reference frame origin, for time frame <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</div></blockquote>
<p><strong>I</strong> : np.ndarray</p>
<blockquote>
<div><p>N x Nr x Nc array, representing image data.</p>
</div></blockquote>
<p><strong>pixel2mmX, pixel2mmY</strong> : float</p>
<blockquote>
<div><p>Number of mm for each pixel in US image, for horizontal and vertical axis (in <em>mm/pixel</em>).</p>
</div></blockquote>
<p><strong>frames</strong> : list</p>
<blockquote>
<div><p>A 2-elem list where the first element is a list of original images sweep frames and the second element is a 2-elem list defining start and end frame of the reconstruction sweep.</p>
</div></blockquote>
<p><strong>savePath</strong> : str</p>
<blockquote>
<div><p>if not empty, it will be used to save each the couple original image - reconstruction for each iteration. 
Each file name is in the format it&lt;itn&gt;_im&lt;ofn&gt;.jpeg, where &lt;itn&gt; is the iteration number (for Nelder-Mead method), &lt;ofn&gt; is the original image frame number.</p>
</div></blockquote>
<p><strong>thZ</strong> : float</p>
<blockquote>
<div><p>Threshold value (in <em>mm</em>) under which points on a reconstruction sweep can be considered belonging to an original image plane.</p>
</div></blockquote>
<p><strong>maxExpr</strong> : str</p>
<blockquote>
<div><p>Expression to maximize.
If &#8216;avg_NCC&#8217;, the NCCs calculated for each wanted pair original frame vs reconstruction template will be averaged.
If &#8216;weighted_avg_NCC&#8217;, the NCCs calculated for each wanted pair original frame vs reconstruction template will be averaged using as weigths the percentage of reconstructed template.
This percentage, in the bottom-left picture in the figures saved in <tt class="docutils literal"><span class="pre">savePath</span></tt>, corresponds to the ratio between the area occupied by the straight lines and the image size.</p>
</div></blockquote>
<p><strong>mask</strong> : mixed</p>
<blockquote>
<div><p>Mask defining a sub-part of the original images to be considered.
If None, the whole part of the original images will be considered.
Otherwise, it must be an No x Nr x Nc array, where No is the number of original images.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">scipy.optimize.Result</p>
<blockquote class="last">
<div><p>solution object (see <tt class="docutils literal"><span class="pre">scipy.optimize.minimize</span></tt>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.maximizeNCCcy">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">maximizeNCCcy</tt><big>(</big><em>i2Ti1</em>, <em>syms</em>, <em>variables</em>, <em>init</em>, <em>Rpr</em>, <em>Tpr</em>, <em>I</em>, <em>pixel2mmX</em>, <em>pixel2mmY</em>, <em>frames</em>, <em>savePath</em>, <em>thZ</em>, <em>maxExpr</em>, <em>mask=None</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#maximizeNCCcy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.maximizeNCCcy" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">maximizeNCC()</span></tt>, but with Cython implementation.
Needs compilation first!</p>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.maximizeNCCfast">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">maximizeNCCfast</tt><big>(</big><em>i2Ti1</em>, <em>syms</em>, <em>variables</em>, <em>init</em>, <em>Rpr</em>, <em>Tpr</em>, <em>I</em>, <em>pixel2mmX</em>, <em>pixel2mmY</em>, <em>frames</em>, <em>savePath</em>, <em>thZ</em>, <em>maxExpr</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#maximizeNCCfast"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.maximizeNCCfast" title="Permalink to this definition">¶</a></dt>
<dd><p>(<em>Deprecated</em>) Same as <tt class="docutils literal"><span class="pre">maximizeNCC()</span></tt>, but with vectorized implementation.
Despite it is about 2x faster than <tt class="docutils literal"><span class="pre">maximizeNCC()</span></tt>, we experienced that the this function is intensive memory-wise, so we suggest not to use it yet.</p>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.maximizeNCCint">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">maximizeNCCint</tt><big>(</big><em>i2Ti1</em>, <em>syms</em>, <em>variables</em>, <em>init</em>, <em>Rpr</em>, <em>Tpr</em>, <em>I</em>, <em>pixel2mmX</em>, <em>pixel2mmY</em>, <em>frames</em>, <em>thZ</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#maximizeNCCint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.maximizeNCCint" title="Permalink to this definition">¶</a></dt>
<dd><p>(<em>Deprecated</em>) Minimize a modification of expression (1) in <a class="reference internal" href="../intro.html#ref3" id="id27">[Ref3]</a>. More specifically, it aims at maximizing the average Normalized Cross-Correlation of the intersection of pair of US images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i2Ti1</strong> : sympy.core.add.Add</p>
<blockquote>
<div><p>4 x 4 matrix containing symbolic roto-translation matrix in (3) in <a class="reference internal" href="../intro.html#ref3" id="id28">[Ref3]</a>.</p>
</div></blockquote>
<p><strong>syms</strong> : dict</p>
<blockquote>
<div><p>Dictionary of where keys are variable names and values are <tt class="docutils literal"><span class="pre">sympy.core.symbol.Symbol</span></tt> objects. These symbols were used to create equations in <tt class="docutils literal"><span class="pre">eq</span></tt>, <tt class="docutils literal"><span class="pre">J</span></tt>, <tt class="docutils literal"><span class="pre">prTi</span></tt>.</p>
</div></blockquote>
<p><strong>variables</strong> : list</p>
<blockquote>
<div><p>List of variable names (see <tt class="docutils literal"><span class="pre">process.Process.calibrateProbe()</span></tt>).</p>
</div></blockquote>
<p><strong>init</strong> : list</p>
<blockquote>
<div><p>List of initial values (same order of <tt class="docutils literal"><span class="pre">variables</span></tt>).</p>
</div></blockquote>
<p><strong>Rpr</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 array, where <tt class="docutils literal"><span class="pre">R[i,:,:]</span></tt> represents the rotation matrix from the US probe reference frame to the global reference frame, for time frame <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</div></blockquote>
<p><strong>Tpr</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 array, where <tt class="docutils literal"><span class="pre">Tpr[i,:]</span></tt> represents the vector from the global reference frame origin to the US probe reference frame origin, for time frame <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</div></blockquote>
<p><strong>I</strong> : np.ndarray</p>
<blockquote>
<div><p>N x Nr x Nc array, representing image data.</p>
</div></blockquote>
<p><strong>pixel2mmX, pixel2mmY</strong> : float</p>
<blockquote>
<div><p>Number of mm for each pixel in US image, for horizontal and vertical axis (in <em>mm/pixel</em>).</p>
</div></blockquote>
<p><strong>frames</strong> : list</p>
<blockquote>
<div><p>Each element must be a list of 2 elements, representing a frames combination for NCC calculation.</p>
</div></blockquote>
<p><strong>thZ</strong> : float</p>
<blockquote>
<div><p>Threshold value (in <em>mm</em>) under which points can be considered belonging to an image plane.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">scipy.optimize.Result</p>
<blockquote class="last">
<div><p>Solution object (see <tt class="docutils literal"><span class="pre">scipy.optimize.minimize</span></tt>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.calib.solveCalibEquations">
<tt class="descclassname">Py3DFreeHandUS.calib.</tt><tt class="descname">solveCalibEquations</tt><big>(</big><em>eq</em>, <em>J</em>, <em>syms</em>, <em>variables</em>, <em>init</em>, <em>xtol</em>, <em>ftol</em>, <em>Rpr</em>, <em>Tpr</em>, <em>features</em>, <em>regJ</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/calib.html#solveCalibEquations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.calib.solveCalibEquations" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve calibration equations (1) in <a class="reference internal" href="../intro.html#ref2" id="id29">[Ref2]</a>. More specifically, a system
of non-linear equations is created by coyping the symbolic equation <tt class="docutils literal"><span class="pre">eq</span></tt>,
replacing the experimental data for each time frame, and stacking it in the
system to be solved. The iterative method used to solve the system is <em>Levenberg–Marquardt</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>eq</strong> : sympy.core.add.Add</p>
<blockquote>
<div><p>Template equation to be stacked in the system.</p>
</div></blockquote>
<p><strong>J</strong> : sympy.core.add.Add</p>
<blockquote>
<div><p>Jacobian of equation <tt class="docutils literal"><span class="pre">eq</span></tt>.</p>
</div></blockquote>
<p><strong>syms</strong> : dict</p>
<blockquote>
<div><p>Dictionary of where keys are variable names and values are <tt class="docutils literal"><span class="pre">sympy.core.symbol.Symbol</span></tt> objects. These symbols were used to create equations in <tt class="docutils literal"><span class="pre">eq</span></tt>, <tt class="docutils literal"><span class="pre">J</span></tt>, <tt class="docutils literal"><span class="pre">prTi</span></tt>.</p>
</div></blockquote>
<p><strong>variables</strong> : list</p>
<blockquote>
<div><p>List of variable names (see <tt class="docutils literal"><span class="pre">process.Process.calibrateProbe()</span></tt>).</p>
</div></blockquote>
<p><strong>init</strong> : list</p>
<blockquote>
<div><p>List of initial values (same order of <tt class="docutils literal"><span class="pre">variables</span></tt>).</p>
</div></blockquote>
<p><strong>xtol</strong> : float</p>
<blockquote>
<div><p>Relative error desired in the approximate solution (see argument <tt class="docutils literal"><span class="pre">options['xtol']</span></tt> or <tt class="docutils literal"><span class="pre">tol</span></tt> in <tt class="docutils literal"><span class="pre">scipy.optimize.root()</span></tt>).</p>
</div></blockquote>
<p><strong>ftol</strong> : float</p>
<blockquote>
<div><p>Relative error desired in the sum of squares (see argument <tt class="docutils literal"><span class="pre">options['ftol']</span></tt> in <tt class="docutils literal"><span class="pre">scipy.optimize.root()</span></tt>).</p>
</div></blockquote>
<p><strong>Rpr</strong> : np.ndarrayN x 3 x 3 array, where <tt class="docutils literal"><span class="pre">R[i,:,:]</span></tt> represents the rotation matrix from the US probe reference frame to the global reference frame, for time frame <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
<p><strong>Tpr</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 array, where <tt class="docutils literal"><span class="pre">Tpr[i,:]</span></tt> represents the vector from the global reference frame origin to the US probe reference frame origin, for time frame <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</div></blockquote>
<p><strong>features: dict</strong></p>
<blockquote>
<div><p>Dictionary where keys are frame numbers and values are lists of tuples, each one representing a point position in the corresponding US image.</p>
</div></blockquote>
<p><strong>regJ: bool</strong></p>
<blockquote>
<div><p>If True, Jacobian will be regularized by using scaling in eq 15, <a class="reference internal" href="../intro.html#ref2" id="id30">[Ref2]</a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sol</strong> : scipy.optimize.Result</p>
<blockquote>
<div><p>Solution object (see <tt class="docutils literal"><span class="pre">scipy.optimize.root</span></tt>).</p>
</div></blockquote>
<p><strong>k</strong> : int</p>
<blockquote class="last">
<div><p>Condition number (see <a class="reference internal" href="../intro.html#ref2" id="id31">[Ref2]</a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.image_utils">
<span id="image-utils"></span><h2><tt class="docutils literal"><span class="pre">image_utils</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.image_utils" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-image_utils"></span><dl class="function">
<dt id="Py3DFreeHandUS.image_utils.CD2">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">CD2</tt><big>(</big><em>I1</em>, <em>I2</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#CD2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.CD2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate CD2 similarity measure (logarithm of division of Rayleigh 
noises). Images are supposed to be log-compressed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>I1, I2</strong> : np.ndarray(uint8)</p>
<blockquote>
<div><p>The 2 binary images, same size is required.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>CD2.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.NCC">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">NCC</tt><big>(</big><em>I1</em>, <em>I2</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#NCC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.NCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Normalized Cross-Correlation between 2 binary images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>I1, I2</strong> : np.ndarray(uint8)</p>
<blockquote>
<div><p>The 2 binary images, same size is required.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>NCC.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.createCenteredMaskCoords">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">createCenteredMaskCoords</tt><big>(</big><em>cx</em>, <em>cy</em>, <em>h</em>, <em>w</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#createCenteredMaskCoords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.createCenteredMaskCoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Create all pixel coordinates for a centered mask around a point.
Center point is (cx, cy).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cx</strong> : int</p>
<blockquote>
<div><p>X coordinate for mask center. If None, it will be set as half of the w.</p>
</div></blockquote>
<p><strong>cy</strong> : int</p>
<blockquote>
<div><p>Y coordinate for mask center.If None, it will be set as half of the h.</p>
</div></blockquote>
<p><strong>w</strong> : int</p>
<blockquote>
<div><p>Mask width. Should be odd.</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Mask height. Should be odd.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>(w * h) x 2 array of coordinates. Each row is a point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.createImageCoords">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">createImageCoords</tt><big>(</big><em>h</em>, <em>w</em>, <em>pixel2mmY</em>, <em>pixel2mmX</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#createImageCoords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.createImageCoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Create all pixel coordinates for an image.
Top-left corner is supposed to be the (0, 0) corner.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>w</strong> : int</p>
<blockquote>
<div><p>Image width (in <em>pixel</em>)</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Image height (in <em>pixel</em>)</p>
</div></blockquote>
<p><strong>pixel2mmX, pixel2mmY</strong> : float</p>
<blockquote>
<div><p>Number of mm for each pixel in US image, for horizontal and vertical axis (in <em>mm/pixel</em>)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>4 x (w * h) array of coordinates. Each column is a point. To (x, y), (z, 1)
are also added to make them ready to be mulitplied by a roto-translation
matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.createImageCorners">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">createImageCorners</tt><big>(</big><em>w</em>, <em>h</em>, <em>pixel2mmX</em>, <em>pixel2mmY</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#createImageCorners"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.createImageCorners" title="Permalink to this definition">¶</a></dt>
<dd><p>Create corner coordinates for an image.
Top-left corner is supposed to be the (0, 0) corner.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>w</strong> : int</p>
<blockquote>
<div><p>Image width (in <em>pixel</em>)</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Image height (in <em>pixel</em>)</p>
</div></blockquote>
<p><strong>pixel2mmX, pixel2mmY</strong> : float</p>
<blockquote>
<div><p>Number of mm for each pixel in US image, for horizontal and vertical axis (in <em>mm/pixel</em>)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>4 x 4 array of coordinates. Each column is a corner. To (x, y), (z, 1)
are also added to make them ready to be mulitplied by a roto-translation
matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.createRandomInMaskCoords">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">createRandomInMaskCoords</tt><big>(</big><em>cx</em>, <em>cy</em>, <em>h</em>, <em>w</em>, <em>N</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#createRandomInMaskCoords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.createRandomInMaskCoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Create random pixel coordinates for a centered mask around a point.
Center point is (cx, cy).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cx</strong> : int</p>
<blockquote>
<div><p>X coordinate for mask center.</p>
</div></blockquote>
<p><strong>cy</strong> : int</p>
<blockquote>
<div><p>Y coordinate for mask center.</p>
</div></blockquote>
<p><strong>w</strong> : int</p>
<blockquote>
<div><p>Mask width. Should be odd.</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Mask height. Should be odd.</p>
</div></blockquote>
<p><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of coordinates to generate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>N x 2 array of coordinates. Each row is a point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.createWhiteMask">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">createWhiteMask</tt><big>(</big><em>frameGray</em>, <em>cx</em>, <em>cy</em>, <em>h</em>, <em>w</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#createWhiteMask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.createWhiteMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create white mask in a grayscale frame, centered around (cx, cy).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>frameGray</strong> : np.ndarray</p>
<blockquote>
<div><p>frame to copy from for creating a new one with the mask</p>
</div></blockquote>
<p><strong>cx</strong> : int</p>
<blockquote>
<div><p>X coordinate for mask center.</p>
</div></blockquote>
<p><strong>cy</strong> : int</p>
<blockquote>
<div><p>Y coordinate for mask center.</p>
</div></blockquote>
<p><strong>w</strong> : int</p>
<blockquote>
<div><p>Mask width. Should be odd.</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Mask height. Should be odd.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple</p>
<blockquote class="last">
<div><p>First element is the frame containing the white mask, and black around.
Second element is the mask coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.findCornersInMask">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">findCornersInMask</tt><big>(</big><em>frameGray</em>, <em>cx</em>, <em>cy</em>, <em>h</em>, <em>w</em>, <em>featureParams</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#findCornersInMask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.findCornersInMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Find Shi-Tomasi corners in a subpart of a frame.
The research mask is centered around (cx, cy).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>frameGray</strong> : np.ndarray</p>
<blockquote>
<div><p>frame to search corners from.</p>
</div></blockquote>
<p><strong>cx</strong> : int</p>
<blockquote>
<div><p>X coordinate for mask center.</p>
</div></blockquote>
<p><strong>cy</strong> : int</p>
<blockquote>
<div><p>Y coordinate for mask center.</p>
</div></blockquote>
<p><strong>w</strong> : int</p>
<blockquote>
<div><p>Mask width. Should be odd.</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Mask height. Should be odd.</p>
</div></blockquote>
<p><strong>featureParams</strong> : dict</p>
<blockquote>
<div><p>See <a href="#id32"><span class="problematic" id="id33">**</span></a>kwargs in <tt class="docutils literal"><span class="pre">cv2.cv2.goodFeaturesToTrack()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple</p>
<blockquote class="last">
<div><p>First element is a N x 1 x 2 array containing coordinates of N good 
corners to track. Second element being the frame contanining the mask.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.histogramsSimilarity">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">histogramsSimilarity</tt><big>(</big><em>H1</em>, <em>H2</em>, <em>meas='bhattacharyya_coef'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#histogramsSimilarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.histogramsSimilarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate similarity measure between histograms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H1, H2</strong> : np.ndarray</p>
<blockquote>
<div><p>The 2 histograms, same size is required.</p>
</div></blockquote>
<p><strong>dist</strong> : str</p>
<blockquote>
<div><p>The kind of measure to compute. 
Allowed values: &#8216;bhattacharyya_coef&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>Similarity measure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.matchTemplate">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">matchTemplate</tt><big>(</big><em>SW</em>, <em>T</em>, <em>meas</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#matchTemplate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.matchTemplate" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute template match between a template match and a search window,
by using different similarity measures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>SW</strong> : np.ndarray(H x W)</p>
<blockquote>
<div><p>Search window.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray(h x w)</p>
<blockquote>
<div><p>Template to search.</p>
</div></blockquote>
<p><strong>meas</strong> : mixed</p>
<blockquote>
<div><p>If str, it can be &#8216;bhattacharyya_coef&#8217;, &#8216;CD2&#8217;.
It can also be an OpenCV constant (e.g. cv2.TM_CCORR_NORMED), and 
<tt class="docutils literal"><span class="pre">cv2.matchTemplate()</span></tt> will be called instead.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote>
<div><p>Additional arguments.
For &#8216;bhattacharyya_coef&#8217;, they are:</p>
<ul class="simple">
<li>&#8216;nBins&#8217;: number of bins for histograms calculation.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray(H-h+1 x W-w+1)</p>
<blockquote class="last">
<div><p>Matrix containing similarity measures.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.pixelData2grey">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">pixelData2grey</tt><big>(</big><em>D</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#pixelData2grey"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.pixelData2grey" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pixel array to grey values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>D</strong> : np.ndarray</p>
<blockquote>
<div><p>Pixel array, in format Nch x Nf x Nr x Nc, to convert.
If Nch is 3, then channels are supposed to be R, G, B.
If Nch is 2, then the values are supposed to be grey level and alpha.
If Nch is 1, then the values are supposed to be grey level.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>Nf x Nr x Nc array of grey level.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.readDICOM">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">readDICOM</tt><big>(</big><em>filePath</em>, <em>method='flattened'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#readDICOM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.readDICOM" title="Permalink to this definition">¶</a></dt>
<dd><p>Read DICOM file (containing data for Nc channels, Nf frames, and images of size Nr x Nc).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filePath</strong> : str</p>
<blockquote>
<div><p>DICOM full file path.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>Pixel array parsing method.
If &#8216;RGB&#8217;, pixel array is supposed to be 3 x Nf x Nr x Nc. Data for frame i is into [:,i,:,:].
If &#8216;flattened&#8217;, pixel array is supposed to be Nch x Nf x Nr x Nc. Data for frame i is into [j,k:k+Nch,:,:], where j = floor(Nch*i / Nf), k = (Nch*i) % Nf.
When using &#8216;flattened&#8217;, pixel array with dimension Nf x Nr x Nc is also supprted (the only stored value is supposed to be a grey level).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : np.ndarray</p>
<blockquote>
<div><p>Pixel array reshaped in the standard way Nch x Nf x Nr x Nc as for <tt class="docutils literal"><span class="pre">method='RGB'</span></tt>.</p>
</div></blockquote>
<p><strong>ds</strong> : dicom.dataset.FileDataset</p>
<blockquote class="last">
<div><p>Additional parameters in the DICOM file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.readImage">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">readImage</tt><big>(</big><em>img</em>, <em>reader='sitk'</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#readImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.readImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for reading image sequence input file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : mixed</p>
<blockquote>
<div><p>Input data.
If str, it is the file path.
Otherwise, it must be a list where the first element represents array 
data, and the second the metadata. This list is just unpacked and 
returned in output.</p>
</div></blockquote>
<p><strong>reader</strong> : str</p>
<blockquote>
<div><p>The specific reader to be used:</p>
<ul class="simple">
<li>&#8216;sitk&#8217;: <tt class="docutils literal"><span class="pre">readSITK()</span></tt> is called.</li>
<li>&#8216;pydicom&#8217;: <tt class="docutils literal"><span class="pre">readDICOM()</span></tt> is called.</li>
</ul>
</div></blockquote>
<p><strong>**kwargs</strong> : dict</p>
<blockquote>
<div><p>Additional keyword arguments to be passed to the specific reader.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : np.ndarray</p>
<blockquote>
<div><p>Pixel array (see specific readers for more details).</p>
</div></blockquote>
<p><strong>metadata</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary containing metadata information. These following are the 
available keys. If an item was not able to be retrieved, it is None.</p>
<ul class="simple">
<li>&#8216;frame_rate&#8217;: frame rate acquisition (in Hz)</li>
<li>&#8216;raw_obj&#8217;: the object as read by the specific reader</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.readSITK">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">readSITK</tt><big>(</big><em>filePath</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#readSITK"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.readSITK" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for reading SITK-compatible input file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filePath</strong> : str</p>
<blockquote>
<div><p>Full file path.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : np.ndarray</p>
<blockquote>
<div><p>Pixel array (dimensions depend on input dimensions).</p>
</div></blockquote>
<p><strong>image</strong> : sitk.Image</p>
<blockquote class="last">
<div><p>Image object as read by SITK.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.image_utils.rgb2grey">
<tt class="descclassname">Py3DFreeHandUS.image_utils.</tt><tt class="descname">rgb2grey</tt><big>(</big><em>R</em>, <em>G</em>, <em>B</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/image_utils.html#rgb2grey"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.image_utils.rgb2grey" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RGB channels to grey levels, by using the formula <a class="reference external" href="http://en.wikipedia.org/wiki/Grayscale#Luma_coding_in_video_systems">here</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R, G, B</strong> : np.ndarray</p>
<blockquote>
<div><p>Arrays containing red, green and blue values. R,G, B must have the same dimensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>Array of grey levels, having the same dimensions of either R, G or B.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.voxel_array_utils">
<span id="voxel-array-utils"></span><h2><tt class="docutils literal"><span class="pre">voxel_array_utils</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.voxel_array_utils" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-voxel_array_utils"></span><dl class="function">
<dt id="Py3DFreeHandUS.voxel_array_utils.createRandomSpheresIn3DVA">
<tt class="descclassname">Py3DFreeHandUS.voxel_array_utils.</tt><tt class="descname">createRandomSpheresIn3DVA</tt><big>(</big><em>xl</em>, <em>yl</em>, <em>zl</em>, <em>N=100</em>, <em>rMax='small'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/voxel_array_utils.html#createRandomSpheresIn3DVA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.voxel_array_utils.createRandomSpheresIn3DVA" title="Permalink to this definition">¶</a></dt>
<dd><p>Create voxel array containing spheres with random position and radius.
Spheres voxels have maximun gray level, the rest has minumum grey level.
There is no internal check about spheres physically nesting into each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xl</strong> : int</p>
<blockquote>
<div><p>Voxel array size along x.</p>
</div></blockquote>
<p><strong>yl</strong> : int</p>
<blockquote>
<div><p>Voxel array size along y.</p>
</div></blockquote>
<p><strong>zl</strong> : int</p>
<blockquote>
<div><p>Voxel array size along z.</p>
</div></blockquote>
<p><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of spheres.</p>
</div></blockquote>
<p><strong>rMax</strong> : mixed</p>
<blockquote>
<div><p>Maximum radius of the sphere.
If &#8216;small&#8217;, it is equivalent to 5% of the largest voxel array dimension.
If int, it is manually indicated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.array(uint8)</p>
<blockquote class="last">
<div><p>Voxel array created.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.voxel_array_utils.getCoordsInConvexHull">
<tt class="descclassname">Py3DFreeHandUS.voxel_array_utils.</tt><tt class="descname">getCoordsInConvexHull</tt><big>(</big><em>p</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/voxel_array_utils.html#getCoordsInConvexHull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.voxel_array_utils.getCoordsInConvexHull" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the convex hull for a list of points and the list of coorindates internal to it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 list of coordinates for which to calculate the cinvex hull. Coordinates should be integer.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>M x 3 array of coordinates, where M is the number of points internal to the convex hull.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.voxel_array_utils.getCubeCoords">
<tt class="descclassname">Py3DFreeHandUS.voxel_array_utils.</tt><tt class="descname">getCubeCoords</tt><big>(</big><em>S</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/voxel_array_utils.html#getCubeCoords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.voxel_array_utils.getCubeCoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Create cube or parallelepipedon coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>S</strong> : mixed</p>
<blockquote>
<div><p>Parallelepipedon or cube size.
If int, it represents the cube side, and must be an odd number. 
The coordinates origin is in the center of the cube.
If list, it must contain 3 lists (for x, y and z), each one containing mininum and maximum coordinate values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>List of 3 <tt class="docutils literal"><span class="pre">np.ndarray</span></tt> objects (for x, y and z), containing coordinate values into the parallelepipedon / cube.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.voxel_array_utils.getSphereCoords">
<tt class="descclassname">Py3DFreeHandUS.voxel_array_utils.</tt><tt class="descname">getSphereCoords</tt><big>(</big><em>r</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/voxel_array_utils.html#getSphereCoords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.voxel_array_utils.getSphereCoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Create sphere coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r</strong> : int</p>
<blockquote>
<div><p>Radius.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>List of 3 <tt class="docutils literal"><span class="pre">np.ndarray</span></tt> objects (for x, y and z), containing coordinate values into sphere.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.voxel_array_utils.idx2xyz">
<tt class="descclassname">Py3DFreeHandUS.voxel_array_utils.</tt><tt class="descname">idx2xyz</tt><big>(</big><em>idx</em>, <em>xl</em>, <em>yl</em>, <em>zl</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/voxel_array_utils.html#idx2xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.voxel_array_utils.idx2xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a list of indices of 1D array into coordinates of a 3D volume of certain sizes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : np.ndarray</p>
<blockquote>
<div><p>1D array to be converted. An increment of <tt class="docutils literal"><span class="pre">idx</span></tt>
corresponds to a an increment of x. When reaching <tt class="docutils literal"><span class="pre">xl</span></tt>, x is reset and 
y is incremented of one. When reaching <tt class="docutils literal"><span class="pre">yl</span></tt>, x and y are reset and z is
incremented.</p>
</div></blockquote>
<p><strong>xl, yl, zl</strong> : int</p>
<blockquote>
<div><p>Sizes for 3D volume.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>List of 3 <tt class="docutils literal"><span class="pre">np.ndarray</span></tt> objects (for x, y and z), containing coordinate value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.voxel_array_utils.nparray2vtkImageData">
<tt class="descclassname">Py3DFreeHandUS.voxel_array_utils.</tt><tt class="descname">nparray2vtkImageData</tt><big>(</big><em>v</em>, <em>d</em>, <em>s</em>, <em>vtkScalarType</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/voxel_array_utils.html#nparray2vtkImageData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.voxel_array_utils.nparray2vtkImageData" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a 1D <tt class="docutils literal"><span class="pre">numpy</span></tt> array into <tt class="docutils literal"><span class="pre">vtk.vtkImageData</span></tt> object. 
The object contains only one scalar component.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>v</strong> : np.ndarray</p>
<blockquote>
<div><p>1D array to convert.</p>
</div></blockquote>
<p><strong>d</strong> : list</p>
<blockquote>
<div><p>3-elem list of sizes of the <tt class="docutils literal"><span class="pre">vtk.vtkImageData</span></tt>.</p>
</div></blockquote>
<p><strong>s</strong> : list</p>
<blockquote>
<div><p>3-elem list of spacing factors of the <tt class="docutils literal"><span class="pre">vtk.vtkImageData</span></tt> (see <a class="reference external" href="http://www.vtk.org/doc/nightly/html/classvtkImageData.html#ab3288d13810266e0b30ba0632f7b5b0b">here</a>).</p>
</div></blockquote>
<p><strong>vtkScalarType :</strong></p>
<blockquote>
<div><p>Scalar type to be allocated (e.g. <tt class="docutils literal"><span class="pre">vtk.VTK_UNSIGNED_CHAR</span></tt>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">vtk.vtkImageData</p>
<blockquote class="last">
<div><p>object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.voxel_array_utils.vtkImageData2vti">
<tt class="descclassname">Py3DFreeHandUS.voxel_array_utils.</tt><tt class="descname">vtkImageData2vti</tt><big>(</big><em>filePath</em>, <em>source</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/voxel_array_utils.html#vtkImageData2vti"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.voxel_array_utils.vtkImageData2vti" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a <tt class="docutils literal"><span class="pre">vtk.vtkImageData</span></tt> object to VTI file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filePath</strong> : str</p>
<blockquote>
<div><p>Full path for the VTI to be created.</p>
</div></blockquote>
<p><strong>source</strong> : vtk.vtkImageData</p>
<blockquote class="last">
<div><p>object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.voxel_array_utils.xyz2idx">
<tt class="descclassname">Py3DFreeHandUS.voxel_array_utils.</tt><tt class="descname">xyz2idx</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>xl</em>, <em>yl</em>, <em>zl</em>, <em>idx='counter'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/voxel_array_utils.html#xyz2idx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.voxel_array_utils.xyz2idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform coordinates of a 3D volume of certain sizes into a list of indices of 1D array.
This is the opposite of function <tt class="docutils literal"><span class="pre">idx2xyz()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y, z</strong> : np.ndarray</p>
<blockquote>
<div><p>Coordinates to be converted.</p>
</div></blockquote>
<p><strong>xl, yl, zl</strong> : int</p>
<blockquote>
<div><p>Sizes for 3D volume.</p>
</div></blockquote>
<p><strong>idx: str</strong></p>
<blockquote>
<div><p>Str ing indicating output type.
If &#8216;counter&#8217;, the output is an array of voxel IDs, incrementing while x coordinate is incrementing.
If &#8216;list&#8217;, a list (z,y,x) is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray or list</p>
<blockquote class="last">
<div><p>Voxel indices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.kine">
<span id="kine"></span><h2><tt class="docutils literal"><span class="pre">kine</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.kine" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-kine"></span><dl class="function">
<dt id="Py3DFreeHandUS.kine.R2zxy">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">R2zxy</tt><big>(</big><em>Rvect</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#R2zxy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.R2zxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert joint rotation matrix to ZXY Euler sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Rvect</strong> : np.ndarray</p>
<blockquote>
<div><p>A 9-elements array representing concatenated rows of the joint 
rotation matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>A list of 3 angle values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.kine.Stylus">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">Stylus</tt><big>(</big><em>P=None</em>, <em>fun=None</em>, <em>args=None</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#Stylus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.Stylus" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper class for reconstructing stylus tip using source points rigidly connected to stylus.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="Py3DFreeHandUS.kine.Stylus.getTipData">
<tt class="descname">getTipData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#Stylus.getTipData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.Stylus.getTipData" title="Permalink to this definition">¶</a></dt>
<dd><p>Get tipa data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 array representing 3D coordinates of the reconstructed tip.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.kine.Stylus.reconstructTip">
<tt class="descname">reconstructTip</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#Stylus.reconstructTip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.Stylus.reconstructTip" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform tip reconstruction.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.kine.Stylus.setPointsData">
<tt class="descname">setPointsData</tt><big>(</big><em>P</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#Stylus.setPointsData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.Stylus.setPointsData" title="Permalink to this definition">¶</a></dt>
<dd><p>Set source points 3D coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>P</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of point 3D coordinates. Keys are points names,
values are np.ndarray N x 3, where N is the number of time frames.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.kine.Stylus.setTipReconstructionFunction">
<tt class="descname">setTipReconstructionFunction</tt><big>(</big><em>fun</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#Stylus.setTipReconstructionFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.Stylus.setTipReconstructionFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the function for tip reconstruction from source points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fun</strong> : fun</p>
<blockquote class="last">
<div><p>Function taking as input arguments <tt class="docutils literal"><span class="pre">P</span></tt> and, if not None, <tt class="docutils literal"><span class="pre">args</span></tt>. 
It must return a N x 3 np.ndarray representing 3D coordinates of 
the reconstructed tip.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.kine.Stylus.setTipReconstructionFunctionArgs">
<tt class="descname">setTipReconstructionFunctionArgs</tt><big>(</big><em>args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#Stylus.setTipReconstructionFunctionArgs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.Stylus.setTipReconstructionFunctionArgs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set additional arguments for tip reconstruction function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>args</strong> : mixed</p>
<blockquote class="last">
<div><p>Argument passed to <tt class="docutils literal"><span class="pre">fun</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.calcaneusPose">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">calcaneusPose</tt><big>(</big><em>mkrs</em>, <em>s='R'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#calcaneusPose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.calcaneusPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate roto-translation matrix from calcaneous to 
laboratory reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrs</strong> : dict</p>
<blockquote>
<div><p>Markers data. Keys are marker names, values are np.ndarray N x 3, 
where N is the number of time frames. Used names are:</p>
<ul class="simple">
<li>&#8216;CA&#8217;: calcalneous</li>
<li>&#8216;PT&#8217;: lateral apex of the peroneal tubercle</li>
<li>&#8216;ST&#8217;: most medial apex of the sustentaculum tali</li>
</ul>
</div></blockquote>
<p><strong>s</strong> : {&#8216;R&#8217;, &#8216;L&#8217;}</p>
<blockquote>
<div><p>Anatomical side.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 translation vector.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Leardini A, Benedetti MG, Berti L, Bettinelli D, Nativo R, Giannini S.
Rear-foot, mid-foot and fore-foot motion during the stance phase of gait. 
Gait Posture. 2007 Mar;25(3):453-62. Epub 2006 Sep 11. PubMed PMID: 16965916.</p>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.calcaneusPoseWithClusterSVD">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">calcaneusPoseWithClusterSVD</tt><big>(</big><em>mkrs</em>, <em>clusterMkrList</em>, <em>args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#calcaneusPoseWithClusterSVD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.calcaneusPoseWithClusterSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate roto-translation matrix from calcaneous to 
laboratory reference frame, using rigid segment-connected cluster of
technical markers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrs</strong> : dict</p>
<blockquote>
<div><p>Technical markers data. Keys are marker names, values are np.ndarray 
N x 3, where N is the number of time frames.</p>
</div></blockquote>
<p><strong>clusterMkrList</strong> : list</p>
<blockquote>
<div><p>List of technical marker names to use.</p>
</div></blockquote>
<p><strong>args</strong> : mixed</p>
<blockquote>
<div><p>Additional arguments:</p>
<ul class="simple">
<li>&#8216;mkrsLoc&#8217;: dictionary where keys are marker names and values are 
3-elem np.arrays indicating the coordinates in the local reference
frame. Both technical and anatomical markers are needed here. For
For anatomical landmark names, see <tt class="docutils literal"><span class="pre">calcaneusPoseISB()</span></tt>.</li>
<li>&#8216;side&#8217;: anatomical side, &#8216;R&#8217; or &#8216;L&#8217;.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 translation vector.</p>
</div></blockquote>
<p><strong>mkrsSeg</strong> : dict</p>
<blockquote class="last">
<div><p>Anatomical markers data in the laboratory reference frame.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.calculateStylusTipInCluster">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">calculateStylusTipInCluster</tt><big>(</big><em>stylus</em>, <em>markers</em>, <em>clusterMkrList</em>, <em>clusterArgs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#calculateStylusTipInCluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.calculateStylusTipInCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for:
- markers cluster pose estimation (by SVD)
- reconstruction of the stylus tip in the cluster reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>markers</strong> : dict</p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">mkrs</span></tt> in <tt class="docutils literal"><span class="pre">rigidBodySVDFun()</span></tt>.</p>
</div></blockquote>
<p><strong>clusterMkrList</strong> : list</p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">mkrList</span></tt> in <tt class="docutils literal"><span class="pre">rigidBodySVDFun()</span></tt>.</p>
</div></blockquote>
<p><strong>clusterArgs</strong> : mixed</p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">args</span></tt> in <tt class="docutils literal"><span class="pre">rigidBodySVDFun()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 array representing 3D coordinates of the reconstructed tip
(in <em>mm</em>) in the cluster reference frame, where N is the number of
time frames.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.changeMarkersReferenceFrame">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">changeMarkersReferenceFrame</tt><big>(</big><em>mkrs</em>, <em>Rfull</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#changeMarkersReferenceFrame"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.changeMarkersReferenceFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Express markers in another reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrs</strong> : dict</p>
<blockquote>
<div><p>Dictionary where each key is a maker name and each value 
is a N x 3 np.ndarray of 3D coordinates, where N is the number of time frames.</p>
</div></blockquote>
<p><strong>Rfull</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 4 x 4 affine matrix from current refence frame
to new reference frame, for N frames.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>Same structure as <tt class="docutils literal"><span class="pre">mkrs</span></tt>, but with new coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.collinearNPointsStylusFun">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">collinearNPointsStylusFun</tt><big>(</big><em>P</em>, <em>args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#collinearNPointsStylusFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.collinearNPointsStylusFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Tip reconstruction function for M collinear points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>P</strong> : dict</p>
<blockquote>
<div><p>Dictionary of point 3D coordinates. Keys are points names
values are np.ndarray N x 3 representing 3D coordinates (in <em>mm</em>)
in the global reference frame, where N is the number of time frames.</p>
</div></blockquote>
<p><strong>args</strong> : dict</p>
<blockquote>
<div><p>Dictionary with the floowing keys:</p>
<ul class="simple">
<li>&#8216;markers&#8217;: list of marker names to be used.</li>
<li>&#8216;dist&#8217;: dictionary of distances between points and tip. Keys must be
present in the &#8216;markers&#8217; list, values are distances (in <em>mm</em>).</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 array representing 3D coordinates of the reconstructed tip
(in <em>mm</em>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.composeRotoTranslMatrix">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">composeRotoTranslMatrix</tt><big>(</big><em>R</em>, <em>T</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#composeRotoTranslMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.composeRotoTranslMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Create affine roto-translation matrix from rotation matrix and translation vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix, for N frames.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 translation vector, for N frames.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>N x 4 x 4 affine matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.createClusterTemplate">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">createClusterTemplate</tt><big>(</big><em>markers</em>, <em>mkrList</em>, <em>timeWin='all_no_nan'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#createClusterTemplate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.createClusterTemplate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create cluster template data from existing markers data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>markers</strong> : dict</p>
<blockquote>
<div><p>Dictionary of point 3D coordinates. Keys are points names
values are np.ndarray N x 3 representing 3D coordinates in the global 
reference frame, where N is the number of time frames.</p>
</div></blockquote>
<p><strong>mkrList</strong> : list</p>
<blockquote>
<div><p>List of marker names to be used for the template.</p>
</div></blockquote>
<p><strong>timeWin</strong> : mixed</p>
<blockquote>
<div><p>Represents which time frames to select for template creation.
If str, it can be:</p>
<ul class="simple">
<li>&#8216;all_no_nan&#8217;: all time frames apart from those where marker data is nan.
If list, it must contain two values containing first and last frame for the 
time window to search into. Only non-nans will be used.
If single value, it indicates the frame to use.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>Dictionary where keys are marker names and values are 3-elem
np.arrays indicating the coordinates in the cluster reference frame.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.decomposeRotoTranslMatrix">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">decomposeRotoTranslMatrix</tt><big>(</big><em>Rfull</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#decomposeRotoTranslMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.decomposeRotoTranslMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract rotation matrix and translation vector from affine roto-translation matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Rfull</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 4 x 4 affine matrix, for N frames.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix and second</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 translation vector, for N frames.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.dot2">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">dot2</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#dot2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.dot2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix products between a M x N array and a K x N x P
array in a vectorized way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : np.ndarray</p>
<blockquote>
<div><p>M x N array</p>
</div></blockquote>
<p><strong>b</strong> : np.ndarrayK x N x P array</p>
<blockquote>
<div><p>np.ndarray</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>K x M x P array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.dot3">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">dot3</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#dot3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.dot3" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix products between a K x M x N array and K x N x P
array in a vectorized way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : np.ndarray</p>
<blockquote>
<div><p>K x M x N array</p>
</div></blockquote>
<p><strong>b</strong> : np.ndarray</p>
<blockquote>
<div><p>K x N x P array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>K x M x P array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.footPoseISB">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">footPoseISB</tt><big>(</big><em>mkrs</em>, <em>s='R'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#footPoseISB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.footPoseISB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate roto-translation matrix from foot (ISB conventions) to 
laboratory reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrs</strong> : dict</p>
<blockquote>
<div><p>Markers data. Keys are marker names, values are np.ndarray N x 3, 
where N is the number of time frames. Used names are:</p>
<ul class="simple">
<li>&#8216;CA&#8217;: calcalneous</li>
<li>&#8216;FM&#8217;: first metatarsal head</li>
<li>&#8216;SM&#8217;: second metatarsal head</li>
<li>&#8216;VM&#8217;: fifth metatarsal head</li>
</ul>
</div></blockquote>
<p><strong>s</strong> : {&#8216;R&#8217;, &#8216;L&#8217;}</p>
<blockquote>
<div><p>Anatomical side.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 translation vector.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Leardini A, Benedetti MG, Berti L, Bettinelli D, Nativo R, Giannini S.
Rear-foot, mid-foot and fore-foot motion during the stance phase of gait. 
Gait Posture. 2007 Mar;25(3):453-62. Epub 2006 Sep 11. PubMed PMID: 16965916.</p>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.footPoseISBWithClusterSVD">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">footPoseISBWithClusterSVD</tt><big>(</big><em>mkrs</em>, <em>clusterMkrList</em>, <em>args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#footPoseISBWithClusterSVD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.footPoseISBWithClusterSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate roto-translation matrix from foot (ISB conventions) to 
laboratory reference frame, using rigid segment-connected cluster of
technical markers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrs</strong> : dict</p>
<blockquote>
<div><p>Technical markers data. Keys are marker names, values are np.ndarray 
N x 3, where N is the number of time frames.</p>
</div></blockquote>
<p><strong>clusterMkrList</strong> : list</p>
<blockquote>
<div><p>List of technical marker names to use.</p>
</div></blockquote>
<p><strong>args</strong> : mixed</p>
<blockquote>
<div><p>Additional arguments:</p>
<ul class="simple">
<li>&#8216;mkrsLoc&#8217;: dictionary where keys are marker names and values are 
3-elem np.arrays indicating the coordinates in the local reference
frame. Both technical and anatomical markers are needed here. For
For anatomical landmark names, see <tt class="docutils literal"><span class="pre">footPoseISB()</span></tt>.</li>
<li>&#8216;side&#8217;: anatomical side, &#8216;R&#8217; or &#8216;L&#8217;.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 translation vector.</p>
</div></blockquote>
<p><strong>mkrsSeg</strong> : dict</p>
<blockquote class="last">
<div><p>Anatomical markers data in the laboratory reference frame.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.ges">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">ges</tt><big>(</big><em>Rvect</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#ges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.ges" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Groot &amp; Suntay anatomical joint angles from proximal and distal
segment rotation matrices. Angles are related to flexion-extension (FE) axis 
of the proximal segment, internal-external (IE) axis of the distal segment,
ab-adduction (AA) floating axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Rvect</strong> : np.ndarray</p>
<blockquote>
<div><p>18-elem vector representing row-flattened version of proximal and 
distal segment rotation matrix from global reference frame to segment.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>List of Groot &amp; Suntay angles (FE, AA, EI).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Grood et Suntay, A joint coordinate system for the clinical description of
three- dimensional motion: application to the knee.
J Biomech. Engng 1983 105: 136-144</p>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.getJointAngles">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">getJointAngles</tt><big>(</big><em>R1</em>, <em>R2</em>, <em>R2anglesFun=&lt;function R2zxy at 0x00000000090020B8&gt;</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#getJointAngles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.getJointAngles" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate 3 joint angles between 2 rigid bodies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R1</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrices from rigid body to global reference frame for body 1 (N time frames).</p>
</div></blockquote>
<p><strong>R2</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrices from rigid body to global reference frame for body 2.</p>
</div></blockquote>
<p><strong>R2anglesFun</strong> : func</p>
<blockquote>
<div><p>Function converting from joint rotation matrix to angles (see <tt class="docutils literal"><span class="pre">R2zxy()</span></tt>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 matrix of angles (in <em>deg</em>)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.getVersor">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">getVersor</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#getVersor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.getVersor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate versors of an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 array of versors coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.interpSignals">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">interpSignals</tt><big>(</big><em>x</em>, <em>xNew</em>, <em>D</em>, <em>kSpline=1</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#interpSignals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.interpSignals" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate data array, with extrapolation. Data can contain NaNs.
The gaps will not be filled.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>D</strong> : np.ndarray</p>
<blockquote>
<div><p>N x M data array to interpolate (interpolation is column-wise).</p>
</div></blockquote>
<p><strong>x</strong> : np.ndarray</p>
<blockquote>
<div><p>axis of the original data, with length N.</p>
</div></blockquote>
<p><strong>xNew</strong> : np.ndarray</p>
<blockquote>
<div><p>New axis for the interpolation, with length P.</p>
</div></blockquote>
<p><strong>kSpline</strong> : mixed</p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">k</span></tt> in <tt class="docutils literal"><span class="pre">scipy.interpolate.InterpolatedUnivariateSpline()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>P x M interpolated array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.inv2">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">inv2</tt><big>(</big><em>R</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#inv2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.inv2" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like np.linalg.inv for multiple matrices, but does not raise
exceptions if a matrix contains nans and it is not invertible.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x M x M series of matrices to invert.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>N x M x M array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.markersClusterFun">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">markersClusterFun</tt><big>(</big><em>mkrs</em>, <em>mkrList</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#markersClusterFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.markersClusterFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Default function for calculating a roto-translation matrix from a cluster
of markers to laboratory reference frame. It is based on the global position
for the markers only, and there is not assumption of rigid body. 
The reference frame is defined as:</p>
<ul class="simple">
<li>X versor from mkrList[-2] to mkrList[-1]</li>
<li>Z cross-product between X and versor from mkrList[-2] to mkrList[-3]</li>
<li>Y cross product between Z and X</li>
<li>Origin: mkrList[-2]</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrs</strong> : dict</p>
<blockquote>
<div><p>Dictionary where each key is a maker name and each value 
is a N x 3 np.ndarray of 3D coordinates, where N is the number of time frames.</p>
</div></blockquote>
<p><strong>mkrList</strong> : list</p>
<blockquote>
<div><p>List of marker names, whenever the names order is important.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 translation vector.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.pca">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">pca</tt><big>(</big><em>D</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#pca"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.pca" title="Permalink to this definition">¶</a></dt>
<dd><p>Run Principal Component Analysis on data matrix. It performs SVD
decomposition on data covariance matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>D</strong> : np.ndarray</p>
<blockquote>
<div><p>Nv x No matrix, where Nv is the number of variables 
and No the number of observations.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>U, s as out of SVD (<tt class="docutils literal"><span class="pre">see</span> <span class="pre">np.linalg.svd</span></tt>)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.readC3D">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">readC3D</tt><big>(</big><em>fileName</em>, <em>sections</em>, <em>opts={}</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#readC3D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.readC3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Read C3D file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>Full path of the C3D file.</p>
</div></blockquote>
<p><strong>sections</strong> : list</p>
<blockquote>
<div><p>List of strings indicating which section to read.
It can contain the following: &#8216;markers&#8217;.</p>
</div></blockquote>
<p><strong>opts</strong> : dict</p>
<blockquote>
<div><p>Options dictionary that can contain the following keys:</p>
<ul class="simple">
<li>setMarkersZeroValuesToNaN: if true, marker corrdinates exactly
matching 0 will be replace with NaNs (e.g. Optitrack systems).
Default is false.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>Collection of read data. It contains, as keys, the items contained
in <tt class="docutils literal"><span class="pre">sections</span></tt>:</p>
<ul class="simple">
<li>markers: this is a dictionary where each key is a point label, and each
value is a N x 3 np.ndarray of 3D coordinates (in <em>mm</em>), where N is the 
number of time frames.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.resampleMarker">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">resampleMarker</tt><big>(</big><em>M</em>, <em>x=None</em>, <em>origFreq=None</em>, <em>origX=None</em>, <em>step=None</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#resampleMarker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.resampleMarker" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample marker data.
The function first tries to see if the new time scale <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">origFreq</span></tt> 
(to create the old scale) or <tt class="docutils literal"><span class="pre">origX</span></tt> are available. If not, the 
resampling will take a frame each <tt class="docutils literal"><span class="pre">step</span></tt> frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 marker data array to resample</p>
</div></blockquote>
<p><strong>x</strong> : np.ndarray</p>
<blockquote>
<div><p>The new time scale (in <em>s</em>) on which to peform the resampling.</p>
</div></blockquote>
<p><strong>origFreq</strong> : double</p>
<blockquote>
<div><p>Frequency (in <em>Hz</em>) to recreate the old time scale.</p>
</div></blockquote>
<p><strong>origX</strong> : np.ndarray</p>
<blockquote>
<div><p>The old time scale (in <em>s</em>).</p>
</div></blockquote>
<p><strong>step</strong> : int</p>
<blockquote>
<div><p>Number of frames to skip when performing resampling not based on <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Mout</strong> : np.ndarray</p>
<blockquote>
<div><p>M x 3 resampled marker data</p>
</div></blockquote>
<p><strong>ind</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Indices of <tt class="docutils literal"><span class="pre">x</span></tt> intersecting time vector of the original <tt class="docutils literal"><span class="pre">M</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.resampleMarkers">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">resampleMarkers</tt><big>(</big><em>M</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#resampleMarkers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.resampleMarkers" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample markers data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M</strong> : dict</p>
<blockquote>
<div><p>Dictionary where keys are markers names and values are np.ndarray 
N x 3 marker data array to resample.</p>
</div></blockquote>
<p><strong>**kwargs</strong></p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">resampleMarker()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>resM</strong> : dict</p>
<blockquote>
<div><p>Resampled marker data</p>
</div></blockquote>
<p><strong>ind</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>See <tt class="docutils literal"><span class="pre">resampleMarker()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.rigidBodySVDFun">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">rigidBodySVDFun</tt><big>(</big><em>mkrs</em>, <em>mkrList</em>, <em>args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#rigidBodySVDFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.rigidBodySVDFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for calculating the optimal roto-translation matrix from a rigid
cluster of markers to laboratory reference frame. The computation, by using
SVD, minimizes the RMSE between the markers inthe laboratory reference frame
and the position of the markers in the local reference frame.
See <tt class="docutils literal"><span class="pre">rigidBodyTransformation()</span></tt> for more details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrs</strong> : dict</p>
<blockquote>
<div><p>Dictionary where each key is a marker name and each value 
is a N x 3 np.ndarray of 3D coordinates, where N is the number of time frames.</p>
</div></blockquote>
<p><strong>mkrList</strong> : list</p>
<blockquote>
<div><p>List of marker names used in the SVD.</p>
</div></blockquote>
<p><strong>args</strong> : mixed</p>
<blockquote>
<div><p>Additional arguments:
- &#8216;mkrsLoc&#8217;: dictionary where keys are marker names and values are 3-elem
np.arrays indicating the coordinates in the local reference frame.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 translation vector.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.rigidBodyTransformation">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">rigidBodyTransformation</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#rigidBodyTransformation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.rigidBodyTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate or rigid rotation and translation between x and y in such a way
that y = Rx + t + e is optimal in a least square optimal. Details of the
algorithm can be found here:</p>
<ul class="simple">
<li>Arun et al. (1987)</li>
<li>Woltring (1992)</li>
<li>Soderkvist &amp; Wedin (1993)</li>
<li>Challis (1995)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : np.ndarray</p>
<blockquote>
<div><p>Nm x 3 array containing coordinates for Nm points in 
the local rigid reference frame.</p>
</div></blockquote>
<p><strong>y</strong> : np.ndarray</p>
<blockquote>
<div><p>Nm x 3 array containing coordinates for Nm points in 
the global reference frame.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>3 x 3 estimated rotation matrix.</p>
</div></blockquote>
<p><strong>t</strong> : np.ndarray</p>
<blockquote>
<div><p>3-elem translation t.</p>
</div></blockquote>
<p><strong>e</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Nm-elem estimated error e.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.shankPoseISB">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">shankPoseISB</tt><big>(</big><em>mkrs</em>, <em>s='R'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#shankPoseISB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.shankPoseISB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate roto-translation matrix from shank (ISB conventions) to 
laboratory reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrs</strong> : dict</p>
<blockquote>
<div><p>Markers data. Keys are marker names, values are np.ndarray N x 3, 
where N is the number of time frames. Used names are:</p>
<ul class="simple">
<li>&#8216;MM&#8217;: medial malleolus</li>
<li>&#8216;LM&#8217;: lateral melleolus</li>
<li>&#8216;HF&#8217;: head of fibula</li>
<li>&#8216;TT&#8217;: tibial tuberosity</li>
</ul>
</div></blockquote>
<p><strong>s</strong> : {&#8216;R&#8217;, &#8216;L&#8217;}</p>
<blockquote>
<div><p>Anatomical side.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>N x 3 translation vector.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Leardini A, Benedetti MG, Berti L, Bettinelli D, Nativo R, Giannini S.
Rear-foot, mid-foot and fore-foot motion during the stance phase of gait. 
Gait Posture. 2007 Mar;25(3):453-62. Epub 2006 Sep 11. PubMed PMID: 16965916.</p>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.shankPoseISBWithClusterSVD">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">shankPoseISBWithClusterSVD</tt><big>(</big><em>mkrs</em>, <em>clusterMkrList</em>, <em>args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#shankPoseISBWithClusterSVD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.shankPoseISBWithClusterSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate roto-translation matrix from shank (ISB conventions) to 
laboratory reference frame, using rigid segment-connected cluster of
technical markers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mkrs</strong> : dict</p>
<blockquote>
<div><p>Technical markers data. Keys are marker names, values are np.ndarray 
N x 3, where N is the number of time frames.</p>
</div></blockquote>
<p><strong>clusterMkrList</strong> : list</p>
<blockquote>
<div><p>List of technical marker names to use.</p>
</div></blockquote>
<p><strong>args</strong> : mixed</p>
<blockquote>
<div><p>Additional arguments:</p>
<ul class="simple">
<li>&#8216;mkrsLoc&#8217;: dictionary where keys are marker names and values are 
3-elem np.arrays indicating the coordinates in the local reference
frame. Both technical and anatomical markers are needed here. For
For anatomical landmark names, see <tt class="docutils literal"><span class="pre">shankPoseISB()</span></tt>.</li>
<li>&#8216;side&#8217;: anatomical side, &#8216;R&#8217; or &#8216;L&#8217;.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 x 3 rotation matrix.</p>
</div></blockquote>
<p><strong>T</strong> : np.ndarray</p>
<blockquote>
<div><p>N x 3 translation vector.</p>
</div></blockquote>
<p><strong>mkrsSeg</strong> : dict</p>
<blockquote class="last">
<div><p>Anatomical markers data in the laboratory reference frame.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.vdot2">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">vdot2</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#vdot2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.vdot2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute dot product in a vectorized way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : np.ndarray</p>
<blockquote>
<div><p>K x 3 array</p>
</div></blockquote>
<p><strong>b</strong> : np.ndarray</p>
<blockquote>
<div><p>K x 3 array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>K-elems array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.kine.writeC3D">
<tt class="descclassname">Py3DFreeHandUS.kine.</tt><tt class="descname">writeC3D</tt><big>(</big><em>fileName</em>, <em>data</em>, <em>copyFromFile=None</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/kine.html#writeC3D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.kine.writeC3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Write to C3D file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>Full path of the C3D file.</p>
</div></blockquote>
<p><strong>data</strong> : dict</p>
<blockquote>
<div><p>Data dictionary that can contain the following keys:</p>
<ul>
<li><dl class="first docutils">
<dt>markers: this is marker-related data. This dictionary contains:</dt>
<dd><ul class="first last simple">
<li>data: dictionary where each key is a point label, and each
value is a N x 3 np.ndarray of 3D coordinates (in <em>mm</em>), where N is
the number of time frames. This field is always necessary.</li>
<li>framesNumber: number of data points per marker.
This field is necessary when creating files from scratch.</li>
<li>unit: string indicating the markers measurement unit. Available
strings are &#8216;mm&#8217; and &#8216;m&#8217;.
This field is necessary when creating files from scratch.</li>
<li>freq: number indicating the markers acquisition frequency.
This field is necessary when creating files from scratch.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><strong>copyFromFile</strong> : str</p>
<blockquote class="last">
<div><p>If None, it creates a new file from scratch.
If str indicating the path of an existing C3D file, it adds/owerwrite data copied from that file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.segment">
<span id="segment"></span><h2><tt class="docutils literal"><span class="pre">segment</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.segment" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-segment"></span><dl class="class">
<dt id="Py3DFreeHandUS.segment.MaskImageUI">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">MaskImageUI</tt><big>(</big><em>maskParams</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#MaskImageUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.MaskImageUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for visualization of 2D image frames and manually create a mask.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>maskParams</strong> : int</p>
<blockquote>
<div><p>masking parameters. See <tt class="docutils literal"><span class="pre">OptsMaskImageUI.__init__()</span></tt></p>
</div></blockquote>
<p><strong>data</strong> : dict</p>
<blockquote>
<div><p>Dictionary when keys a frame values and values are 2D binary Numpy matrices representing masks.</p>
</div></blockquote>
<p><strong>*args :</strong></p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">ViewerWithFeaturesUI.__init__()</span></tt>.</p>
</div></blockquote>
<p><strong>**kwargs :</strong></p>
<blockquote class="last">
<div><ul class="simple">
<li>&#8216;title&#8217;: window title.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">OptsMaskImageUI</tt><big>(</big><em>viewer</em>, <em>maskParams</em>, <em>data</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Class adding manual masking capabilities to class <tt class="docutils literal"><span class="pre">MaskImageUI</span></tt> or a derivate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>viewer</strong> : ViewerUI</p>
<blockquote>
<div><p>Instance of class <tt class="docutils literal"><span class="pre">ViewerUI</span></tt> or a derivate.</p>
</div></blockquote>
<p><strong>maskParams</strong> : int</p>
<blockquote>
<div><p>Dictionary for mask addition/creation:</p>
<ul class="simple">
<li>&#8216;selectorType&#8217;: string indicating mask selector type: &#8216;pen&#8217;, &#8216;lasso&#8217;.</li>
<li>&#8216;width&#8217;: width, in pixels, for the selector.</li>
</ul>
<p>If the selector is a pen, this is the pen thickness.
If the selector is a lasso, this is ignored.</p>
</div></blockquote>
<p><strong>data</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary when keys a frame values and values are 2D binary Numpy matrices representing masks.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.changedType">
<tt class="descname">changedType</tt><big>(</big><em>label</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.changedType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.changedType" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for selector type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>label</strong> : str</p>
<blockquote class="last">
<div><p>Current radiobutton label.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.changedWidth">
<tt class="descname">changedWidth</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.changedWidth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.changedWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.clearMask">
<tt class="descname">clearMask</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.clearMask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.clearMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove whoole mask from screen for current frame.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.fileLoad">
<tt class="descname">fileLoad</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.fileLoad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.fileLoad" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow to load masks data from file, by a user dialog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.fileSave">
<tt class="descname">fileSave</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.fileSave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.fileSave" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow to save masks data to file, by a user dialog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.getData">
<tt class="descname">getData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.getData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.getData" title="Permalink to this definition">¶</a></dt>
<dd><p>Return masks data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>Masks data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.modeChange">
<tt class="descname">modeChange</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.modeChange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.modeChange" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow to toggle add or remove modality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.reset">
<tt class="descname">reset</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the whole mask for current frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.showData">
<tt class="descname">showData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.showData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.showData" title="Permalink to this definition">¶</a></dt>
<dd><p>Refresh the screen with the mask for current frame.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsMaskImageUI.showMask">
<tt class="descname">showMask</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsMaskImageUI.showMask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsMaskImageUI.showMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Show mask on screen for current frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">OptsPointsHoughUI</tt><big>(</big><em>autoSegParams</em>, <em>dataConstr</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Class adding automatic (Hough transform) line segmentation capabilities to class <tt class="docutils literal"><span class="pre">ViewerUI</span></tt> or a derivate.
The images are supposed to have two areas of diffrent grays levels, divided by a single line.
For the details on the automatic line detection algorithm, see function <tt class="docutils literal"><span class="pre">detectHoughLongestLine()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>autoSegParams</strong> : dict</p>
<blockquote>
<div><p>Dictionary where keys are parameter names for function <tt class="docutils literal"><span class="pre">detectHoughLongestLine()</span></tt>.</p>
</div></blockquote>
<p><strong>dataConstr</strong> : list</p>
<blockquote>
<div><p>List of constraints for each point. Each element is a dictionary that can contain the follwing fields:</p>
<ul class="simple">
<li>&#8216;xPct&#8217;: this imposes the x coordinate of the point to be a perecentage of the image width.</li>
</ul>
</div></blockquote>
<p><strong>*args</strong></p>
<blockquote class="last">
<div><p>See <tt class="docutils literal"><span class="pre">OptsPointsUI.__init__()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.autoCreatePoints">
<tt class="descname">autoCreatePoints</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.autoCreatePoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.autoCreatePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Create points on the automatically detected line.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent:</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.changedKerSizeCan">
<tt class="descname">changedKerSizeCan</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.changedKerSizeCan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.changedKerSizeCan" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for Canny edge detector Sobel kernel size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.changedKerSizeDilH">
<tt class="descname">changedKerSizeDilH</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.changedKerSizeDilH"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.changedKerSizeDilH" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for dilation kernel width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.changedKerSizeDilV">
<tt class="descname">changedKerSizeDilV</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.changedKerSizeDilV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.changedKerSizeDilV" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for dilation kernel height.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.changedMaxLineGap">
<tt class="descname">changedMaxLineGap</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.changedMaxLineGap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.changedMaxLineGap" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for probabilistic Hough transform maximum line gap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.changedMinLineLength">
<tt class="descname">changedMinLineLength</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.changedMinLineLength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.changedMinLineLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for probabilistic Hough transform minimum line length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.changedThCan1">
<tt class="descname">changedThCan1</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.changedThCan1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.changedThCan1" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for Canny edge detector lower threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.changedThCan2">
<tt class="descname">changedThCan2</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.changedThCan2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.changedThCan2" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for Canny edge detector higher threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.changedThHou">
<tt class="descname">changedThHou</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.changedThHou"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.changedThHou" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for probabilistic Hough transform threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.changedThI">
<tt class="descname">changedThI</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.changedThI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.changedThI" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for image threshold slider.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.clearLine">
<tt class="descname">clearLine</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.clearLine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.clearLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove line from screen for current frame.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.detectLine">
<tt class="descname">detectLine</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.detectLine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.detectLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically detect the line.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.detectPoints">
<tt class="descname">detectPoints</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.detectPoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.detectPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect points on the line using the constraints.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.showData">
<tt class="descname">showData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.showData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.showData" title="Permalink to this definition">¶</a></dt>
<dd><p>Refresh the screen with line the points for current frame.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.showLine">
<tt class="descname">showLine</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.showLine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.showLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Show line on screen for current frame.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsHoughUI.updateData">
<tt class="descname">updateData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsHoughUI.updateData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsHoughUI.updateData" title="Permalink to this definition">¶</a></dt>
<dd><p>Redetect automatically line and points.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.segment.OptsPointsUI">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">OptsPointsUI</tt><big>(</big><em>viewer</em>, <em>Npoints</em>, <em>data</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Class adding manual points extraction capabilities to class <tt class="docutils literal"><span class="pre">ViewerUI</span></tt> or a derivate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>viewer</strong> : ViewerUI</p>
<blockquote>
<div><p>Instance of class <tt class="docutils literal"><span class="pre">ViewerUI</span></tt> or a derivate.</p>
</div></blockquote>
<p><strong>Npoints</strong> : int</p>
<blockquote>
<div><p>Number of point features per image to be extracted.</p>
</div></blockquote>
<p><strong>data</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary when keys a frame values and values are list of tuples. Each tuple represents coordinates for a single point in the image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsUI.clearPoints">
<tt class="descname">clearPoints</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsUI.clearPoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsUI.clearPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove points from screen for current frame.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsUI.click">
<tt class="descname">click</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsUI.click"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsUI.click" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow to click on <tt class="docutils literal"><span class="pre">Npoints</span></tt> points manually in the current image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsUI.fileLoad">
<tt class="descname">fileLoad</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsUI.fileLoad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsUI.fileLoad" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow to load points data from file, by a user dialog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsUI.fileSave">
<tt class="descname">fileSave</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsUI.fileSave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsUI.fileSave" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow to save points data to file, by a user dialog.</p>
<dl class="docutils">
<dt>event <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib.backend_bases.MouseEvent</span></dt>
<dd>Event thrown when clicking on connected button.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsUI.getData">
<tt class="descname">getData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsUI.getData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsUI.getData" title="Permalink to this definition">¶</a></dt>
<dd><p>Return points data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>Points data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsUI.reset">
<tt class="descname">reset</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsUI.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsUI.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the number of clicked points for the current image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsUI.showData">
<tt class="descname">showData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsUI.showData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsUI.showData" title="Permalink to this definition">¶</a></dt>
<dd><p>Refresh the screen with the points for current frame.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.OptsPointsUI.showPoints">
<tt class="descname">showPoints</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#OptsPointsUI.showPoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.OptsPointsUI.showPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Show points on screen for current frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.segment.SegmentPointsHoughUI">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">SegmentPointsHoughUI</tt><big>(</big><em>Npoints</em>, <em>autoSegParams</em>, <em>dataConstr</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentPointsHoughUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentPointsHoughUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for visualization of 2D image frames and automatically segmentable points lying on a line.
The images are supposed to have two areas of diffrent grays levels, divided by a single line.
For the details on the automatic line detection algorithm, see function <tt class="docutils literal"><span class="pre">detectHoughLongestLine()</span></tt>.
Automatically detected points can be manually adjusted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Npoints</strong> : int</p>
<blockquote>
<div><p>Number of point features per image to be extracted.</p>
</div></blockquote>
<p><strong>autoSegParams</strong> : dict</p>
<blockquote>
<div><p>Dictionary where keys are parameter names for function <tt class="docutils literal"><span class="pre">detectHoughLongestLine()</span></tt>.</p>
</div></blockquote>
<p><strong>dataConstr</strong> : list</p>
<blockquote>
<div><p>List of constraints for each point. Each element is a dictionary that can contain the follwing fields:</p>
<ul class="simple">
<li>&#8216;xPct&#8217;: this imposes the x coordinate of the point to be a perecentage of the image width.</li>
</ul>
</div></blockquote>
<p><strong>data</strong> : dict</p>
<blockquote>
<div><p>Dictionary when keys a frame values and values are list of tuples. Each tuple represents coordinates for a single point in the image.</p>
</div></blockquote>
<p><strong>*args:</strong></p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">ViewerWithFeaturesUI.__init__()</span></tt>.</p>
</div></blockquote>
<p><strong>**kwargs:</strong></p>
<blockquote class="last">
<div><ul class="simple">
<li>&#8216;title&#8217;: window title.</li>
<li>&#8216;saveDataPath&#8217;: existing folder path where to save automatically segmented images.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.segment.SegmentPointsUI">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">SegmentPointsUI</tt><big>(</big><em>Npoints</em>, <em>data</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentPointsUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentPointsUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for visualization of 2D image frames and manually segmentable points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Npoints</strong> : int</p>
<blockquote>
<div><p>Number of point features per image to be extracted.</p>
</div></blockquote>
<p><strong>data</strong> : dict</p>
<blockquote>
<div><p>Dictionary when keys a frame values and values are list of tuples. Each tuple represents coordinates for a single point in the image.</p>
</div></blockquote>
<p><strong>*args</strong></p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">ViewerWithFeaturesUI.__init__()</span></tt>.</p>
</div></blockquote>
<p><strong>**kwargs:</strong></p>
<blockquote class="last">
<div><ul class="simple">
<li>&#8216;title&#8217;: window title.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.segment.SegmentUI">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">SegmentUI</tt><big>(</big><em>I</em>, <em>data={}</em>, <em>Nclicks=1</em>, <em>block=True</em>, <em>title=''</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentUI" title="Permalink to this definition">¶</a></dt>
<dd><p><em>(deprecated)</em> Class for performing manual point feature extraction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>I</strong> : np.array</p>
<blockquote>
<div><p>Nf x Nr x Nc (frames number x image row size x image column size) array containing grey levels data.</p>
</div></blockquote>
<p><strong>data</strong> : dict</p>
<blockquote>
<div><p>Dictionary when keys are frame values and values are list of tuples. Each tuple represents coordinates for a single point in the image.</p>
</div></blockquote>
<p><strong>Nclicks</strong> : int</p>
<blockquote>
<div><p>Number of point features to be extracted.</p>
</div></blockquote>
<p><strong>block</strong> : bool</p>
<blockquote>
<div><p>If to block the window or not.
In interactive Python shell mode, if True, it shows the main window and disables buttons usage. These have to be called
manually from command line. If False, program flow is interrupted until the main window is closed, and buttons usage is enabled.
In script mode, if True, it has the same behaviour as interactive shell. In this mondality, False value has no meaning since no
window is shown.</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote class="last">
<div><p>Window title</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="Py3DFreeHandUS.segment.SegmentUI.click">
<tt class="descname">click</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentUI.click"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentUI.click" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow to click on <tt class="docutils literal"><span class="pre">Nclicks</span></tt> manually in the current image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.SegmentUI.fileLoad">
<tt class="descname">fileLoad</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentUI.fileLoad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentUI.fileLoad" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow to load points data from file, by a user dialog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : param matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.SegmentUI.fileSave">
<tt class="descname">fileSave</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentUI.fileSave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentUI.fileSave" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow to save points data to file, by a user dialog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.SegmentUI.getData">
<tt class="descname">getData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentUI.getData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentUI.getData" title="Permalink to this definition">¶</a></dt>
<dd><p>Get clicked points data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>For the format, see <tt class="docutils literal"><span class="pre">data</span></tt> in the constructor method.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.SegmentUI.next">
<tt class="descname">next</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentUI.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentUI.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Show next image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.SegmentUI.prev">
<tt class="descname">prev</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentUI.prev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentUI.prev" title="Permalink to this definition">¶</a></dt>
<dd><p>Show previous image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.SegmentUI.reset">
<tt class="descname">reset</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#SegmentUI.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.SegmentUI.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the number of clicked points for the current image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.segment.ViewerUI">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">ViewerUI</tt><big>(</big><em>I</em>, <em>title=''</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for visualization of 2D image frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>I</strong> : np.array</p>
<blockquote>
<div><p>Nf x Nr x Nc (frames number x image row size x image column size) array containing grey levels data.</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote class="last">
<div><p>Window title</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerUI.changedInd">
<tt class="descname">changedInd</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerUI.changedInd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerUI.changedInd" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for frame index slider.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Current slider value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerUI.closeViewer">
<tt class="descname">closeViewer</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerUI.closeViewer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerUI.closeViewer" title="Permalink to this definition">¶</a></dt>
<dd><p>Close viewer.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerUI.next">
<tt class="descname">next</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerUI.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerUI.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Show next image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : param matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerUI.prev">
<tt class="descname">prev</tt><big>(</big><em>event</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerUI.prev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerUI.prev" title="Permalink to this definition">¶</a></dt>
<dd><p>Show previous image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event</strong> : param matplotlib.backend_bases.MouseEvent</p>
<blockquote class="last">
<div><p>Event thrown when clicking on connected button.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerUI.showCurrentIdx">
<tt class="descname">showCurrentIdx</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerUI.showCurrentIdx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerUI.showCurrentIdx" title="Permalink to this definition">¶</a></dt>
<dd><p>Show current frame number.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerUI.showImage">
<tt class="descname">showImage</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerUI.showImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerUI.showImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Show image for current frame.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerUI.showViewer">
<tt class="descname">showViewer</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerUI.showViewer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerUI.showViewer" title="Permalink to this definition">¶</a></dt>
<dd><p>Show viewer.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerUI.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerUI.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerUI.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Show image and frame number.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.segment.ViewerWithFeaturesUI">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">ViewerWithFeaturesUI</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerWithFeaturesUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerWithFeaturesUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for visualization of 2D image frames and image features.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>*args</strong></p>
<blockquote>
<div><p>See <tt class="docutils literal"><span class="pre">ViewerUI.__init__()</span></tt>.</p>
</div></blockquote>
<p><strong>**kwargs</strong></p>
<blockquote class="last">
<div><p>See <tt class="docutils literal"><span class="pre">ViewerUI.__init__()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerWithFeaturesUI.changedInd">
<tt class="descname">changedInd</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerWithFeaturesUI.changedInd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerWithFeaturesUI.changedInd" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for frame index slider. See class <tt class="docutils literal"><span class="pre">ViewerUI.changedInd()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerWithFeaturesUI.getData">
<tt class="descname">getData</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerWithFeaturesUI.getData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerWithFeaturesUI.getData" title="Permalink to this definition">¶</a></dt>
<dd><p>Return points data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>Points data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerWithFeaturesUI.next">
<tt class="descname">next</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerWithFeaturesUI.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerWithFeaturesUI.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Show next image and features. See method <tt class="docutils literal"><span class="pre">ViewerUI.next()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.segment.ViewerWithFeaturesUI.prev">
<tt class="descname">prev</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#ViewerWithFeaturesUI.prev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.ViewerWithFeaturesUI.prev" title="Permalink to this definition">¶</a></dt>
<dd><p>Show previous image and features. See class <tt class="docutils literal"><span class="pre">ViewerUI.prev()</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.segment.detectHoughLongestLine">
<tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">detectHoughLongestLine</tt><big>(</big><em>I</em>, <em>thI=0.1</em>, <em>thCan1=50</em>, <em>thCan2=150</em>, <em>kerSizeCan=3</em>, <em>kerSizeDil=(3</em>, <em>3)</em>, <em>thHou=100</em>, <em>minLineLength=2</em>, <em>maxLineGap=10</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#detectHoughLongestLine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.detectHoughLongestLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a noisy gray-scale image containing 2 main blocks separated by a straight line, this function detects this line.
The algorithm performs the following steps:</p>
<ol class="arabic simple">
<li>Thresholding the input image</li>
<li>Canny edge detector</li>
<li>Dilation with a 1s-filled rectangular kernel</li>
<li>Probabilistic Hough transform</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>I</strong> : np.ndarray(uint8)</p>
<blockquote>
<div><p>The input image.</p>
</div></blockquote>
<p><strong>thI</strong> : float</p>
<blockquote>
<div><p>Threshold relative to the maximum representative gray level. 0 &lt; thI &lt; 1.</p>
</div></blockquote>
<p><strong>thCan1</strong> : int</p>
<blockquote>
<div><p>Canny edge detector lower threshold.</p>
</div></blockquote>
<p><strong>thCan2</strong> : int</p>
<blockquote>
<div><p>Canny edge detector higher threshold.</p>
</div></blockquote>
<p><strong>kerSizeCan</strong> : int</p>
<blockquote>
<div><p>Sobel kernel size for Canny edge detector. Either 3, 5, 7.</p>
</div></blockquote>
<p><strong>kerSizeDil</strong> : list</p>
<blockquote>
<div><p>Rectangular kernel size (height, width) for dilation.</p>
</div></blockquote>
<p><strong>thHou</strong> : int</p>
<blockquote>
<div><p>Threshold for Hough transform output matrix.</p>
</div></blockquote>
<p><strong>minLineLength</strong> : int</p>
<blockquote>
<div><p>Minimum line length for probabilistic Hough transform.</p>
</div></blockquote>
<p><strong>maxLineGap</strong> : int</p>
<blockquote>
<div><p>Maximum line gap for probabilistic Hough transform.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>a, b</strong> : float</p>
<blockquote>
<div><p>Slope and intercept of the line. If no line is detected, these are np.nan.</p>
</div></blockquote>
<p><strong>bw</strong> : np.ndarray</p>
<blockquote>
<div><p>Image as result of point 1.</p>
</div></blockquote>
<p><strong>edges</strong> : np.ndarray</p>
<blockquote>
<div><p>Image as result of point 2.</p>
</div></blockquote>
<p><strong>dilate</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Image as result of point 3.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.segment.readFeaturesFile">
<tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">readFeaturesFile</tt><big>(</big><em>filePath</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#readFeaturesFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.readFeaturesFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read feature file data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filePath</strong> : str</p>
<blockquote>
<div><p>Full file path for the features file.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>dictionary when keys are frame values and values contain features data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.segment.singlePointFeaturesTo3DPointsMatrix">
<tt class="descclassname">Py3DFreeHandUS.segment.</tt><tt class="descname">singlePointFeaturesTo3DPointsMatrix</tt><big>(</big><em>fea</em>, <em>u</em>, <em>v</em>, <em>idx=None</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/segment.html#singlePointFeaturesTo3DPointsMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.segment.singlePointFeaturesTo3DPointsMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a single points features structures to matrix containing 3D
points data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fea</strong> : dict</p>
<blockquote>
<div><p>Dictionary containing features data (see <tt class="docutils literal"><span class="pre">SegmentUI.__init__()</span></tt>).</p>
</div></blockquote>
<p><strong>u, v</strong> : float</p>
<blockquote>
<div><p>mm-to-pixel conversion factors (in <em>mm/pixel</em>) for horizontal and vertical coordinates.</p>
</div></blockquote>
<p><strong>idx</strong> : list</p>
<blockquote>
<div><p>List of image frames number to be used. If None, all the available frames will be used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>Np x 4 matrix, where Np is the number of pointt features used</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.converters">
<span id="converters"></span><h2><tt class="docutils literal"><span class="pre">converters</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.converters" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-converters"></span><dl class="function">
<dt id="Py3DFreeHandUS.converters.arr2aviMPY">
<tt class="descclassname">Py3DFreeHandUS.converters.</tt><tt class="descname">arr2aviMPY</tt><big>(</big><em>fileName</em>, <em>M</em>, <em>fps</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/converters.html#arr2aviMPY"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.converters.arr2aviMPY" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert gray-scale Numpy 3D image array to AVI file (use moviepy).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>Path for output AVI file.</p>
</div></blockquote>
<p><strong>M</strong> : np.ndarray(uint8)</p>
<blockquote>
<div><p>F x H x W 3D array, representing a sequence of F images, each H x W.</p>
</div></blockquote>
<p><strong>fps</strong> : int</p>
<blockquote class="last">
<div><p>frame rate for the output file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.converters.arr2aviOCV">
<tt class="descclassname">Py3DFreeHandUS.converters.</tt><tt class="descname">arr2aviOCV</tt><big>(</big><em>fileName</em>, <em>M</em>, <em>fps</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/converters.html#arr2aviOCV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.converters.arr2aviOCV" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert gray-scale Numpy 3D image array to AVI file (use OpenCV).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>Path for output AVI file.</p>
</div></blockquote>
<p><strong>M</strong> : np.ndarray(uint8)</p>
<blockquote>
<div><p>F x H x W 3D array, representing a sequence of F images, each H x W.</p>
</div></blockquote>
<p><strong>fps</strong> : int</p>
<blockquote class="last">
<div><p>frame rate for the output file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.converters.arr2dcm">
<tt class="descclassname">Py3DFreeHandUS.converters.</tt><tt class="descname">arr2dcm</tt><big>(</big><em>I</em>, <em>fileOut</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/converters.html#arr2dcm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.converters.arr2dcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert gray-scale Numpy 3D image array to gray-scale image-sequence DICOM file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>I</strong> : np.ndarray</p>
<blockquote>
<div><p>F x H x W 3D array, representing a sequence of F images, each H x W.</p>
</div></blockquote>
<p><strong>fileOut</strong> : str</p>
<blockquote class="last">
<div><p>Path for output DICOM file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.converters.arr2seqFile">
<tt class="descclassname">Py3DFreeHandUS.converters.</tt><tt class="descname">arr2seqFile</tt><big>(</big><em>fileName</em>, <em>M</em>, <em>fps</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/converters.html#arr2seqFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.converters.arr2seqFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert gray-scale Numpy 3D image array to image sequence file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileName</strong> : str</p>
<blockquote>
<div><p>Path for output file. Possible extensions:
- &#8216;avi&#8217;: <tt class="docutils literal"><span class="pre">arr2aviMPY()</span></tt> is called.</p>
</div></blockquote>
<p><strong>M</strong> : np.ndarray(uint8)</p>
<blockquote>
<div><p>F x H x W 3D array, representing a sequence of F images, each H x W.</p>
</div></blockquote>
<p><strong>fps</strong> : int</p>
<blockquote class="last">
<div><p>frame rate for the output file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.converters.avi2dcm">
<tt class="descclassname">Py3DFreeHandUS.converters.</tt><tt class="descname">avi2dcm</tt><big>(</big><em>fileIn</em>, <em>fileOut</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/converters.html#avi2dcm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.converters.avi2dcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert gray-scale AVI file to gray-scale image-sequence DICOM file.
Frame rate is <em>not</em> added as <em>CineRate</em> tag in the DICOM file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileIn</strong> : str</p>
<blockquote>
<div><p>Path for input AVI file.</p>
</div></blockquote>
<p><strong>fileOut</strong> : str</p>
<blockquote class="last">
<div><p>Path for output DICOM file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.converters.vti2mat">
<tt class="descclassname">Py3DFreeHandUS.converters.</tt><tt class="descname">vti2mat</tt><big>(</big><em>fileIn</em>, <em>fileOut</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/converters.html#vti2mat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.converters.vti2mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert voxel-array from VTI to MAT (MATLAB(R)) format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileIn</strong> : str</p>
<blockquote>
<div><p>Path for input VTI file.</p>
</div></blockquote>
<p><strong>fileOut</strong> : str</p>
<blockquote class="last">
<div><p>Path for output MAT file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.muscles_analysis">
<span id="muscles-analysis"></span><h2><tt class="docutils literal"><span class="pre">muscles_analysis</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.muscles_analysis" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-muscles_analysis"></span><dl class="function">
<dt id="Py3DFreeHandUS.muscles_analysis.MTJlengths">
<tt class="descclassname">Py3DFreeHandUS.muscles_analysis.</tt><tt class="descname">MTJlengths</tt><big>(</big><em>P1</em>, <em>P2</em>, <em>P3</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/muscles_analysis.html#MTJlengths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.muscles_analysis.MTJlengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate muscle-tendon junction (MJT) lengths based on insterion and MJT position.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>P1</strong> : np.ndarray</p>
<blockquote>
<div><p>3-elements array containing 3D coordinates for muscle insertion.</p>
</div></blockquote>
<p><strong>P2</strong> : np.ndarray</p>
<blockquote>
<div><p>3-elements array containing 3D coordinates for tendon insertion.</p>
</div></blockquote>
<p><strong>P3</strong> : np.ndarray</p>
<blockquote>
<div><p>3-elements array containing 3D coordinates for MJT.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>Dictionary with the following keys:</p>
<ul class="simple">
<li>&#8216;Dmuscle&#8217;: distance between P1 and P3</li>
<li>&#8216;Dtendon&#8217;: distance between P2 and P3</li>
<li>&#8216;Dcomplex&#8217;: distance between P1 and P2</li>
<li>&#8216;DmusclePct&#8217;: ratio between Dmuscle and Dmuscle + Dtendon</li>
<li>&#8216;DtendonPct&#8217;: ratio between Dtendon and Dmuscle + Dtendon</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.tracking">
<span id="tracking"></span><h2><tt class="docutils literal"><span class="pre">tracking</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.tracking" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-tracking"></span><dl class="function">
<dt id="Py3DFreeHandUS.tracking.calcVelocityLee2008">
<tt class="descclassname">Py3DFreeHandUS.tracking.</tt><tt class="descname">calcVelocityLee2008</tt><big>(</big><em>allDx</em>, <em>allDy</em>, <em>pctEx</em>, <em>pctIn</em>, <em>direction='max_avg_vel'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/tracking.html#calcVelocityLee2008"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.tracking.calcVelocityLee2008" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the method described in the article of Lee et al 2008
for calculating the muscle-tendon junction (MTJ) velocity vector (u, v) 
between a frame and the next one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>allDx, allDy</strong> : np.ndarray</p>
<blockquote>
<div><p>X and Y component for velocities from for pixel in the rectangle mask.</p>
</div></blockquote>
<p><strong>pctEx</strong> : float</p>
<blockquote>
<div><p>Number (between 0 and 1) indicating the percentage of velocities, in the
beginning and end of sorted lists, to exclude. In the original article,
this value was 0.1.</p>
</div></blockquote>
<p><strong>pctIn</strong> : float</p>
<blockquote>
<div><p>Number (between 0 and 1) indicating the percentage of velocities, in the
beginning and end of remaining sorted lists, to use for the average. 
In the original article, this value was 0.05.</p>
</div></blockquote>
<p><strong>direction</strong> : string</p>
<blockquote>
<div><p>It defines which of the 2 average velocities (beginning and end of list)
to use as final velocity.
If &#8216;max_avg_vel&#8217;, the choice is determined by the absolute magnitude of 
the average velocity (as in the original article by Lee).
If &#8216;pct_sign&#8217;, the choice is determined by the dominant number of 
velocitied concording in sign. If there is an equal number of positive
and negative velocities, then the algorithm proceeds as for &#8216;max_avg_vel&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple</p>
<blockquote class="last">
<div><p>Velocity vector (u, v) for the MTJ.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.tracking.enhanceMTJForTracking">
<tt class="descclassname">Py3DFreeHandUS.tracking.</tt><tt class="descname">enhanceMTJForTracking</tt><big>(</big><em>img</em>, <em>method</em>, <em>enhanceArgs</em>, <em>enhanceKwargs</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/tracking.html#enhanceMTJForTracking"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.tracking.enhanceMTJForTracking" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for enhancing the image containing muscle-tendon junction (MTJ)
for tracking purpose. Two characteristics can be enhanced:</p>
<ul class="simple">
<li>contrast (by histogram equalization)</li>
<li>signal-to-noise ratio (by smoothing)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : np.ndarray</p>
<blockquote>
<div><p>Image to be enhanced.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>Method for enhancing the image:</p>
<ul class="simple">
<li>&#8216;histeq&#8217;: histogram equalization.</li>
<li>&#8216;clahe&#8217;: Contrast-Limited Adaptive Histogram Equalization
(see <tt class="docutils literal"><span class="pre">cv2.createCLAHE()</span></tt>). It uses <tt class="docutils literal"><span class="pre">enhanceKwargs</span></tt>.</li>
<li>&#8216;smooth&#8217;: smoothing with Gaussian kernel
(see <tt class="docutils literal"><span class="pre">cv2.GaussianBlur()</span></tt>). It uses <tt class="docutils literal"><span class="pre">enhanceArgs</span></tt>.</li>
</ul>
<p>There are other methods, where &#8216;_opt&#8217; is happended, that do not need
further (further) arguments. Here, we are experimenting optimal settings.</p>
</div></blockquote>
<p><strong>enhanceArgs</strong> : tuple</p>
<blockquote>
<div><p>List of arguments that can be needed by the enhancing functions.</p>
</div></blockquote>
<p><strong>enhanceKwargs</strong> : dict</p>
<blockquote>
<div><p>List of keyword arguments that can be needed by the enhancing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray</p>
<blockquote class="last">
<div><p>Enhance image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.tracking.showImageQualityStatsPreOF">
<tt class="descclassname">Py3DFreeHandUS.tracking.</tt><tt class="descname">showImageQualityStatsPreOF</tt><big>(</big><em>I</em>, <em>show=True</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/tracking.html#showImageQualityStatsPreOF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.tracking.showImageQualityStatsPreOF" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates quality indices for before optical flow computation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>These considerations are important:</p>
<ul class="last simple">
<li>Better to use a greyscale images, so that the eye does not focus on the 
type of color but only on the value;</li>
<li>For Shi-Tomasi corner response, better to use a logarithmic scale to 
smooth the left/right border effect (high values). Moreover, some image 
types (e.g. US) might have artificial symbols on it, bringing intrinsic
high corner response;</li>
<li>For the sake of function generality, min and max for each image are not 
normalized to fixed values, since these may depend on the input type.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>I</strong> : np.ndarray</p>
<blockquote>
<div><p>2D grey-scale image.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote class="last">
<div><p>Plot results window or not.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.tracking.trackMTJ">
<tt class="descclassname">Py3DFreeHandUS.tracking.</tt><tt class="descname">trackMTJ</tt><big>(</big><em>img, plotRawInputImage=False, f1=None, f2=None, y1=None, y2=None, x1=None, x2=None, enhanceImage=False, enhancePars=[('smooth_opt',)], lowpassFilterTime=False, lowpassFilterTimePars=(4, 0.25), cx=None, cy=None, h=71, w=131, adjustManuallyCxy=False, cxyHelp={}, adjustManuallyCxyOnTracking=False, adjustManuallyCxyOnTrackingCond=['optical_flow', 'stdU&gt;th', 1.0], cxOffset=0, cyOffset=0, adjustManuallyCxyOffset=False, stepFramesN=1, technique='optical_flow', techniquePars=('lk_opt', 'new_centered_mask', 'feature_opt', 'kmeans_Lee2008', 3, False, 0.1, 0.05), plotImageInTracking=True, winName='', timePerImage='auto', plotTrackedFeatures=False, plotCircle='last', plotTechniqueRes=False, plotTechniqueResAddData={}, saveTechniqueResTo=None, outFiles=[]</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/tracking.html#trackMTJ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.tracking.trackMTJ" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for tracking muscle-tendon junction (MTJ) (semi)automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : mixed</p>
<blockquote>
<div><p>Full path to the 3D sequence file to open, or list containing 3D sequence
data and metadata. See <tt class="docutils literal"><span class="pre">image_utils.readImage()</span></tt> for more details.</p>
</div></blockquote>
<p><strong>plotRawInputImage</strong> : bool</p>
<blockquote>
<div><p>If True, 3D sequence will be shown. ImageJ is required in this case.</p>
</div></blockquote>
<p><strong>f1, f2</strong> : mixed</p>
<blockquote>
<div><p>If positive integer, the 3D sequence will be cut between frame f1 and f2.
If f1 of f2 are None, respectively the beginning or end will not be cut.</p>
</div></blockquote>
<p><strong>y1, y2</strong> : mixed</p>
<blockquote>
<div><p>If positive integer, the 3D sequence will be cut between coordinates
y1 and y2, in height. Image origin (0, 0) is at the top-left corner.
If y1 of y2 are None, respectively the beginning or end will not be cut.</p>
</div></blockquote>
<p><strong>x1, x2</strong> : mixed</p>
<blockquote>
<div><p>If positive integer, the 3D sequence will be cut between coordinates
x1 and x2, in width.
If x1 of x2 are None, respectively the beginning or end will not be cut.</p>
</div></blockquote>
<p><strong>enhanceImage</strong> : bool</p>
<blockquote>
<div><p>If True, each 2D image will be enhanced for tracking, using parameters 
specified by <tt class="docutils literal"><span class="pre">enhancePars</span></tt>.</p>
</div></blockquote>
<p><strong>enhancePars</strong> : list</p>
<blockquote>
<div><p>List of tuples, each representing a step in the 2D images enhancing 
process. Each tuple contains second, third and fourth arguments for
the function <tt class="docutils literal"><span class="pre">enhanceMTJForTracking()</span></tt>.</p>
</div></blockquote>
<p><strong>lowpassFilterTime</strong> : bool</p>
<blockquote>
<div><p>If True, each 2D image pixel will be low-pass filtered in time, using
parameters specified by <tt class="docutils literal"><span class="pre">lowpassFilterTimePars</span></tt>.</p>
</div></blockquote>
<p><strong>lowpassFilterTimePars</strong> : tuple</p>
<blockquote>
<div><p>List of parameters indicating the parameter for the Butterworth digital
low-pass filter. The first one is the filter order, the second one the
cut-off frequency.</p>
</div></blockquote>
<p><strong>cx, cy</strong> : int</p>
<blockquote>
<div><p>Rectangular mask center position for frame <tt class="docutils literal"><span class="pre">f1</span></tt> (or 0). This mask is 
used by the tracking algorithm (see details). If None, they will be set
to the center of the frame.</p>
</div></blockquote>
<p><strong>h, w</strong> : int</p>
<blockquote>
<div><p>Mask height and width.</p>
</div></blockquote>
<p><strong>adjustManuallyCxy</strong> : bool</p>
<blockquote>
<div><p>If True, the process will stop and allow the user to select manually
the center of the mask, on the image <tt class="docutils literal"><span class="pre">f1</span></tt> (or 0). The window has to
be close manually for proceeding.</p>
</div></blockquote>
<p><strong>adjustManuallyCxyOnTracking</strong> : bool</p>
<blockquote>
<div><p>If True, the process will stop and allow the user to select manually
the center of the mask during tracking, if some warning condition is 
met (see <tt class="docutils literal"><span class="pre">adjustManuallyCxyOnTrackingCond</span></tt>). The window has to be 
close manually for proceeding.</p>
</div></blockquote>
<p><strong>adjustManuallyCxyOnTrackingCond</strong> : list</p>
<blockquote>
<div><p>Condition on which the manual adjustment during tracking is prompted.
This list must contain the following items:</p>
<blockquote>
<div><ol class="arabic simple" start="0">
<li>The tracking technique (see <tt class="docutils literal"><span class="pre">technique</span></tt>).</li>
<li>A string representing the condition to verify:<ul>
<li>&#8216;stdU&gt;th&#8217; (&#8216;optical_flow&#8217; only): standard deviation of
horizontal velocities profile must be greater than a threshold.</li>
</ul>
</li>
<li>From here down, list of parameters relative to point 1:<ul>
<li>for &#8216;stdU&gt;th&#8217;: threshold value to overcome.</li>
</ul>
</li>
</ol>
</div></blockquote>
</div></blockquote>
<p><strong>cxyHelp</strong> : dict</p>
<blockquote>
<div><p>Dictionary where keys are time frame indices and values are tuples
containing x and y values for the rectangular mask center.
If provided, the mask center will be set to this value, ignoring what
the tracking algorithm found.</p>
</div></blockquote>
<p><strong>cxOffset, cyOffset</strong> : int</p>
<blockquote>
<div><p>It represents the offset between the mask center and the MTJ point.</p>
</div></blockquote>
<p><strong>adjustManuallyCxyOffset</strong> : bool</p>
<blockquote>
<div><p>If True, the process will stop and allow the user to select manually
the MTJ location, on the image <tt class="docutils literal"><span class="pre">f1</span></tt> (or 0). The window has to
be close manually for proceeding.</p>
</div></blockquote>
<p><strong>stepFramesN</strong> : int</p>
<blockquote>
<div><p>It represents the number of frames to jump ahead after is performed
for current image. If equal or greater than 2, (stepFramesN-1) frames
will be skipped.
It can be increased to simulate lower acquisition frequencies for the 
input file, or larger motion velocities.</p>
</div></blockquote>
<p><strong>technique</strong> : str</p>
<blockquote>
<div><p>String indicating the technique used (see parameter <tt class="docutils literal"><span class="pre">techniquePars</span></tt>
for details). Possible values are: &#8216;optical_flow&#8217;, &#8216;template_match&#8217;.</p>
</div></blockquote>
<p><strong>techniquePars</strong> : tuple</p>
<blockquote>
<div><p>List of parameters used by the tracking algorithm.
If <tt class="docutils literal"><span class="pre">technique</span></tt> is &#8216;optical_flow&#8217;:</p>
<blockquote>
<div><ol class="arabic" start="0">
<li><p class="first">Lukas-Kanade parameters for optical field calculation.
If dictionary, see keyword parameters for <tt class="docutils literal"><span class="pre">cv2.calcOpticalFlowPyrLK()</span></tt>.
If &#8216;lk_opt&#8217;, the optimal parameters will be used.</p>
</li>
<li><p class="first">Features to be tracked.
If &#8216;new_centered_mask&#8217;, a new mask will be created around the 
detected MTJ, and all the points contained in the mask will be 
tracked.
If &#8216;good_features&#8217;, only the features detected as the trackable
and tracked (<strong>good features</strong>) will be tracked.
If &#8216;corners_in_centered_mask&#8217;, only the the Shi-Tomasi corners in
a mask centered around the the detected MTJ will be tracked.
If &#8216;append_corners_to_new_good_features_in_centered_mask&#8217;, 
Shi-Tomasi corners in the new form will be appended to the good 
features detected. This full list of features will be tracked.</p>
</li>
<li><p class="first">Parameters for finding corners by using the Shi-Tomasi algorithm.
If dictionary, see keyword parameters for <tt class="docutils literal"><span class="pre">cv2.goodFeaturesToTrack()</span></tt>.
If &#8216;feature_opt&#8217;, the optimal parameters will be used.</p>
</li>
<li><p class="first">Algorithm for processing optical flow results.
If &#8216;Lee2008&#8217;, the method described by Lee at all 2008 is applied
(see <tt class="docutils literal"><span class="pre">calcVelocityLee2008(...,</span> <span class="pre">direction='max_avg_vel')</span></tt>).
If &#8216;Lee2008_v2&#8217;, the method described by Lee at all 2008 is
applied, with some small modifications
(see <tt class="docutils literal"><span class="pre">calcVelocityLee2008(...,</span> <span class="pre">direction='max_avg_vel')</span></tt>).
If &#8216;avg_good_features&#8217;, an average of the position of the good 
features detected is calculated.
If &#8216;lrmost_x_good_features&#8217;, these further parameters are used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">uTh</span> <span class="o">=</span> <span class="n">techniquePars</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">nKeep</span> <span class="o">=</span> <span class="n">techniquePars</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>For the good features, it calculates the median of the velocities 
in the x direction. If the velocity is bigger in module than <tt class="docutils literal"><span class="pre">uTh</span></tt>,
then there is a condition of motion. In this case, only the rightmost
or leftmost (depending if the motion is going respectively to the 
right or left) <tt class="docutils literal"><span class="pre">nKeep</span></tt> good features are retained. And for these,
the median position is calculated, this being the new MTJ position. 
The other features are deleted from the list of good features. 
If the velocity is smaller in module than <tt class="docutils literal"><span class="pre">uTh</span></tt>, then there is a
condition of rest. The median position for all the good features is 
calculated.
&#8216;lrmost_x_good_features_adv&#8217; is similar to &#8216;lrmost_x_good_features&#8217;,
but with an auto-recovery procedure added in motion state. If
the three previous velocites are, in average, in motion state
as well but with opposite direction, then the point is not being
properly tracked. In this case, the new MTJ position is set to the 
current one, but the mask is enlarged (50% in both dimensions), to 
ensure a bigger search zone for the next iteration.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Algorithms &#8216;lrmost_x_good_features&#8217; and &#8216;lrmost_x_good_features_adv&#8217;
were developed for the specific motion of the MTJ, that is:</p>
<ul class="last simple">
<li>mostly horizontal in the images, some vertical motion is allowed as well.</li>
<li>cyclic, from left to right or vice-versa.</li>
</ul>
</div>
<p>If &#8216;kmeans_Lee2008&#8217;, these further parameters are used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nClusters</span> <span class="o">=</span> <span class="n">techniquePars</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">clusterOnlyVelocity</span> <span class="o">=</span> <span class="n">techniquePars</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="n">pctEx</span> <span class="o">=</span> <span class="n">techniquePars</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="n">pctIn</span> <span class="o">=</span> <span class="n">techniquePars</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>Firstly, the a k-means clustering is performed on the good features, 
on both velocity and position, or velocity only, depending on the
parameter <tt class="docutils literal"><span class="pre">clusterOnlyVelocity</span></tt>. This last flag would allow the 
user to have cluster that are separated in space. The number of 
clusters must be specified manually, by <tt class="docutils literal"><span class="pre">nClusters</span></tt>.
Secondly, the cluster with the biggest number of points is selected.
Lastly, the algorithm by Lee et al 2008 is applied on these points
(see <tt class="docutils literal"><span class="pre">calcVelocityLee2008()</span></tt>). <tt class="docutils literal"><span class="pre">pctEx</span></tt> and <tt class="docutils literal"><span class="pre">pctIn</span></tt> will be
used.</p>
</li>
<li><p class="first">From here down, these are parameters for the algorithm at point 3.</p>
</li>
</ol>
</div></blockquote>
<p>If <tt class="docutils literal"><span class="pre">technique</span></tt> is &#8216;template_match&#8217;:</p>
<blockquote>
<div><ol class="arabic simple" start="0">
<li>Allowed motion (in pixels) of the template in horizontal.</li>
<li>Allowed motion (in pixels) of the template in vertical.</li>
<li>A tuple cointaining the kind of similarity measure and an 
optional dict  of addictional parameters (see parameters 
<tt class="docutils literal"><span class="pre">meas</span></tt> and <tt class="docutils literal"><span class="pre">**kwargs</span></tt> for <tt class="docutils literal"><span class="pre">image_utils.matchTemplate()</span></tt>).</li>
</ol>
</div></blockquote>
<p>If <tt class="docutils literal"><span class="pre">technique</span></tt> is &#8216;particle_filter&#8217;:</p>
<blockquote>
<div><ol class="arabic simple" start="0">
<li>Probability models.
This is a list containing state transition model, observation 
model, state estimation from weights only, a-posteriori 
probability model (see <tt class="docutils literal"><span class="pre">particle_filter</span></tt> module).</li>
<li>Particles parameters.
This is list containing the number of particles and a particle
initializer.</li>
<li>The initial state.
This is a list of state variable values for the initial frame.
First 2 state variable must be the positional part of the state
(x and y position, <tt class="docutils literal"><span class="pre">cxy</span></tt>). If <tt class="docutils literal"><span class="pre">adjustManuallyCxy</span></tt> is True, 
positional part is overwritten. State construction depends on
the models that will use it.</li>
<li>Weights parameters.
This is a list where the first parameter is a string indicating
how to calculate particle weigths in case of re-initialization 
of those (e.g. first frame or point set manually). 
If &#8216;from_observ_model&#8217;, weights will be calculated by the
observation model.
If &#8216;uniform&#8217;, all weights will be given the same value.</li>
<li>Resample parameters.
This is a list where the first parameter is a string indicating
the particles resampling method (see method 
<tt class="docutils literal"><span class="pre">particle_filter.ParticleFilter.resample()</span></tt>).
The second parameter is a string indicating when perform the
resampling.
If &#8216;always&#8217;, resamplingis performed at each iteration.
If &#8216;below_th&#8217;, resampling is performed only when the effective
number of particle goes below one third of the total number of
particles.</li>
</ol>
</div></blockquote>
</div></blockquote>
<p><strong>plotImageInTracking</strong> : bool</p>
<blockquote>
<div><p>If True, each 2D image is shown on screen during the tracking process.</p>
</div></blockquote>
<p><strong>winName</strong> : str</p>
<blockquote>
<div><p>Name of the window showing sequence.</p>
</div></blockquote>
<p><strong>timePerImage</strong> : mixed</p>
<blockquote>
<div><p>Time for which each 2D image is shown on screen.
If &#8216;auto&#8217;, it is automatically calculated from the meta-data in
<tt class="docutils literal"><span class="pre">img</span></tt>. If not available here, an exception will thrown.
If float, it must be indicated in milliseconds.
If <tt class="docutils literal"><span class="pre">plotImageInTracking</span></tt> is False, this parameter is ignored.</p>
</div></blockquote>
<p><strong>plotTrackedFeatures</strong> : bool</p>
<blockquote>
<div><p>If True, plot the features tracked by the optical flow algorithm.
If <tt class="docutils literal"><span class="pre">technique</span></tt> is not &#8216;optical_flow&#8217; or if <tt class="docutils literal"><span class="pre">plotImageInTracking</span></tt> is
False, this parameter is ignored.</p>
</div></blockquote>
<p><strong>plotCircle</strong> : str</p>
<blockquote>
<div><p>MTJ point is represented as the center of a circle.
If &#8216;all&#8217;, image <em>i</em> contains the circles from image 0 to <em>i</em>.
If &#8216;last&#8217;, only the circle in the current image is plotted.
If <tt class="docutils literal"><span class="pre">plotImageInTracking</span></tt> is False, this parameter is ignored.</p>
</div></blockquote>
<p><strong>plotTechniqueRes</strong> : bool</p>
<blockquote>
<div><p>If True, plot additional data produced during the tracking stage.
Execution of the program <em>is interrupted</em> until the results windows
are manually closed.
If <tt class="docutils literal"><span class="pre">technique</span></tt> is &#8216;optical_flow&#8217;, the optical flow is plotted, where
arrows represent the current (u, v) velocity vector field for the points
inside the rectangle. Around the center of the rectangle, a blue arrow 
is plotted, indicating the velocity of the MTJ towards the next image.
Arrows lengths and directions have the same scale of the x-y axis.
If the algorithm used is &#8216;kmeans_Lee2008&#8217;, arrows will be coloured 
differently for different clusters. The biggest cluster is coloured in
blue. For any other algorithm, velocities for good features are coloured
in green, otherwise in red.
If <tt class="docutils literal"><span class="pre">technique</span></tt> is &#8216;template_match&#8217;, template on the previous image
(smaller rectangle), search window (bigger rectangle), matching indices
(in greyscale), point with best match and its value are saved for each
time frame.</p>
</div></blockquote>
<p><strong>plotTechniqueResAddData</strong> : dict</p>
<blockquote>
<div><p>Additional custom data to be used in plots generated if either
<tt class="docutils literal"><span class="pre">plotTechniqueRes</span></tt> is True or <tt class="docutils literal"><span class="pre">saveTechniqueResTo</span></tt> is not None.
If <tt class="docutils literal"><span class="pre">technique</span></tt> is &#8216;optical_flow&#8217;, the dictionary must contain the
following keys:</p>
<ul class="simple">
<li>&#8216;OF_std_u_th&#8217;, &#8216;OF_std_v_th&#8217;: list of values representing standard
deviations from horizontal and vertical velocities calculated by the
optical flow technique. It can be used as a value to check the 
horizontal and vertical deformation of the feature tracked.</li>
</ul>
</div></blockquote>
<p><strong>saveTechniqueResTo</strong> : mixed</p>
<blockquote>
<div><p>Path for saving technique results. If None, no data will be saved.
If str, it must specify the full folder path.
If <tt class="docutils literal"><span class="pre">technique</span></tt> is &#8216;optical_flow&#8217;, the figures created by using the
flag <tt class="docutils literal"><span class="pre">plotTechniqueRes</span></tt> are saved. Plus, numeric data about the
velocities is saved as text files.
If <tt class="docutils literal"><span class="pre">technique</span></tt> is &#8216;template_match&#8217;, the figures created by using the
flag <tt class="docutils literal"><span class="pre">plotTechniqueRes</span></tt> are saved.</p>
</div></blockquote>
<p><strong>outFiles</strong> : list</p>
<blockquote>
<div><p>List of tuples, where each tuple represents an output video to be saved.
The first element is the full path of the file to be saved. Supported
formats: avi (Microsoft Video 1 (MSVC) codec).
The second element is the frame rate. If &#8216;auto&#8217;, the frame rate of the
input file. Otherwise, it must be a float number.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple</p>
<blockquote class="last">
<div><p>cx, cy, horizontal and vertical position of the MTJ. Values are relative
to the (0, 0) image corner. These Numpy vectors contain as many frames as
the original input image. Frames outside the range (f1, f2) are set as
np.nan.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.tracking.trackMTJMultiTrackers">
<tt class="descclassname">Py3DFreeHandUS.tracking.</tt><tt class="descname">trackMTJMultiTrackers</tt><big>(</big><em>img</em>, <em>trackersN</em>, <em>trackersPars=None</em>, <em>f1=None</em>, <em>f2=None</em>, <em>y1=None</em>, <em>y2=None</em>, <em>x1=None</em>, <em>x2=None</em>, <em>plotImageInTracking=True</em>, <em>timePerImage='auto'</em>, <em>plotTrackedFeatures=True</em>, <em>plotTechniqueRes=False</em>, <em>saveTechniqueResTo=None</em>, <em>outFiles=[]</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/tracking.html#trackMTJMultiTrackers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.tracking.trackMTJMultiTrackers" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for tracking muscle-tendon junction (MTJ) (semi)automatically,
by using N different trackers. Only one tracker at a time is run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : mixed</p>
<blockquote>
<div><p>Full path to the 3D sequence file to open, or list containing 3D sequence
data and metadata. See <tt class="docutils literal"><span class="pre">image_utils.readImage()</span></tt> for more details.</p>
</div></blockquote>
<p><strong>trackersN</strong> : int</p>
<blockquote>
<div><p>Number of trackers.</p>
</div></blockquote>
<p><strong>trackersPars</strong> : list</p>
<blockquote>
<div><p>List where each element is a dict where keys are keyword elements of
for function <tt class="docutils literal"><span class="pre">trackMTJ()</span></tt>, and values are the respective parameters.
Only the first <tt class="docutils literal"><span class="pre">trackersN</span></tt> will be used.</p>
</div></blockquote>
<p><strong>f1, f2</strong> : mixed</p>
<blockquote>
<div><p>If positive integer, the 3D sequence will be cut between frame f1 and f2.
If f1 of f2 are None, respectively the beginning or end will not be cut.
This parameter is only used for multi-track image display and video
creation.</p>
</div></blockquote>
<p><strong>y1, y2</strong> : mixed</p>
<blockquote>
<div><p>If positive integer, the 3D sequence will be cut between coordinates
y1 and y2, in height. Image origin (0, 0) is at the top-left corner.
If y1 of y2 are None, respectively the beginning or end will not be cut.
This parameter is only used for multi-track image display and video
creation.</p>
</div></blockquote>
<p><strong>x1, x2</strong> : mixed</p>
<blockquote>
<div><p>If positive integer, the 3D sequence will be cut between coordinates
x1 and x2, in width.
If x1 of x2 are None, respectively the beginning or end will not be cut.
This parameter is only used for multi-track image display and video
creation.</p>
</div></blockquote>
<p><strong>plotImageInTracking</strong> : bool</p>
<blockquote>
<div><p>If True, each 2D image is shown on screen during the tracking process.</p>
</div></blockquote>
<p><strong>timePerImage</strong> : mixed</p>
<blockquote>
<div><p>Time for which each 2D image is shown on screen.
If &#8216;auto&#8217;, it is automatically calculated from the meta-data in
<tt class="docutils literal"><span class="pre">img</span></tt>. If not available here, an exception will thrown.
If float, it must be indicated in milliseconds.
If <tt class="docutils literal"><span class="pre">plotImageInTracking</span></tt> is False, this parameter is ignored.</p>
</div></blockquote>
<p><strong>plotTrackedFeatures</strong> : bool</p>
<blockquote>
<div><p>If True, plot the result of each tracker with a circle and the number
of the tracker (starting from 0). Trackers order follow the order in
<tt class="docutils literal"><span class="pre">trackersPars</span></tt>.</p>
</div></blockquote>
<p><strong>outFiles</strong> : list</p>
<blockquote>
<div><p>List of tuples, where each tuple represents an output video to be saved.
The first element is the full path of the file to be saved. Supported
formats: avi (Microsoft Video 1 (MSVC) codec).
The second element is the frame rate. If &#8216;auto&#8217;, the frame rate of the
input file. Otherwise, it must be a float number.
The video contains data as shown with <tt class="docutils literal"><span class="pre">plotTrackedFeatures</span></tt> set to 
true, the original raw sequence otherwise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple</p>
<blockquote class="last">
<div><p>cx, cy, horizontal and vertical position of the MTJ. Values are relative
to the (0, 0) image corner. These Numpy tables vectors contain as many 
rows as the number of time frames in the original input image, and as
many columns as the number of trackers. Columns orders follows the 
order of <tt class="docutils literal"><span class="pre">trackersPars</span></tt>. Frames outside the range (f1, f2) are set as
np.nan.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.particle_filter">
<span id="particle-filter"></span><h2><tt class="docutils literal"><span class="pre">particle_filter</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.particle_filter" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-particle_filter"></span><dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.E">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">E</tt><big>(</big><em>x</em>, <em>w</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#E"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.E" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Weighted average (expectation estimator) of samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : np.ndarray (nS x nP)</p>
<blockquote>
<div><p>Matrix where each column represents a sample.</p>
</div></blockquote>
<p><strong>w</strong> : np.ndarray (nP)</p>
<blockquote>
<div><p>Probability (weight) for each sample.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS)</p>
<blockquote class="last">
<div><p>Estimated vector.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.ML">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">ML</tt><big>(</big><em>x</em>, <em>w</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ML"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ML" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate maximum likelihood estimation from samples (i.e. the sample
with the higher weight).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : np.ndarray (nS x nP)</p>
<blockquote>
<div><p>Matrix where each column represents a sample.</p>
</div></blockquote>
<p><strong>w</strong> : np.ndarray (nP)</p>
<blockquote>
<div><p>Probability (weight) for each sample.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS)</p>
<blockquote class="last">
<div><p>Estimated vector.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter">
<em class="property">class </em><tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">ParticleFilter</tt><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Particle filter implementation.</p>
<p>These are the name conventions for variables:</p>
<ul class="simple">
<li>nS: number of state variables.</li>
<li>nI: number of iterations performed.</li>
<li>nP: number of particles.</li>
<li>x: np.ndarray (nS x nP). Matrix containing data for each particle,
for current iteration. Each row is a state variable.</li>
<li>xNext: np.ndarray (nS x nP). Matrix containing data for each particle, 
for next iteration. Each row is a state variable.</li>
<li>xNextFromWeights: np.ndarray (nS). Vector containing state estimation
for next iteration, only by using weights.</li>
<li>xNextEst: np.ndarray (nS). Vector containing state estimation for next
iteration.</li>
<li>xEst: np.ndarray (nS x nI). Matrix containing history of estimated states, 
in columns.</li>
<li>w: np.ndarray (nP). Vector of particle weights for current iteration.</li>
<li>wNext: np.ndarray (nP). Vector of particle weights for next iteration.</li>
<li>wNextNorm: np.ndarray (nP). wNext normalized on their sum.</li>
<li>addData: mixed. See method <tt class="docutils literal"><span class="pre">setAdditionalData()</span></tt>.</li>
</ul>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.estimateNextState">
<tt class="descname">estimateNextState</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.estimateNextState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.estimateNextState" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate and return state for next iteration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS)</p>
<blockquote class="last">
<div><p>See xNextEst.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.estimateStateFromWeights">
<tt class="descname">estimateStateFromWeights</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.estimateStateFromWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.estimateStateFromWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate state for next iteration, from particle weights only.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.getEffectParticlesNumber">
<tt class="descname">getEffectParticlesNumber</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.getEffectParticlesNumber"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.getEffectParticlesNumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of effective particles, calculated by the inverse
of the sum of squared normalized weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">int</p>
<blockquote class="last">
<div><p>Number of effective particles.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.getEstimatedStateFromWeights">
<tt class="descname">getEstimatedStateFromWeights</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.getEstimatedStateFromWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.getEstimatedStateFromWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Get state for next iteration, from particle weights only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS)</p>
<blockquote class="last">
<div><p>See xNextFromWeights.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.getPredictedParticles">
<tt class="descname">getPredictedParticles</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.getPredictedParticles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.getPredictedParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get predicted particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS x nP)</p>
<blockquote class="last">
<div><p>See xNext.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.getUpdatedParticleWeights">
<tt class="descname">getUpdatedParticleWeights</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.getUpdatedParticleWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.getUpdatedParticleWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Get weights for updated particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nP)</p>
<blockquote class="last">
<div><p>See wNextNorm.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.predict">
<tt class="descname">predict</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the prediction step.</p>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.resample">
<tt class="descname">resample</tt><big>(</big><em>mode='inverse_transform'</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.resample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the resampling step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mode</strong> : str</p>
<blockquote>
<div><p>Resampling method.
If &#8216;inverse_transform&#8217;, the algorithm used is the inverse transform
resampling.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS x nP)</p>
<blockquote class="last">
<div><p>Matrix of the same size of x, but containing only particles with 
heeavier weights.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.setAdditionalData">
<tt class="descname">setAdditionalData</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.setAdditionalData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.setAdditionalData" title="Permalink to this definition">¶</a></dt>
<dd><p>Set additional data, to be passed to and used by model functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : mixed</p>
<blockquote class="last">
<div><p>This can be any kind of data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.setParticleWeights">
<tt class="descname">setParticleWeights</tt><big>(</big><em>w</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.setParticleWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.setParticleWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Set particles weights for current interation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>w</strong> : np.ndarray (nP)</p>
<blockquote class="last">
<div><p>See w.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.setParticles">
<tt class="descname">setParticles</tt><big>(</big><em>x</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.setParticles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.setParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Set particles data for current iteration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : np.ndarray (nS x nP)</p>
<blockquote class="last">
<div><p>See x.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.setProbEstimModel">
<tt class="descname">setProbEstimModel</tt><big>(</big><em>model</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.setProbEstimModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.setProbEstimModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the a-posteriori probability model (i.e. p(x|Y))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : fun</p>
<blockquote class="last">
<div><p>Function defining the observation model. The function must have
these inputs: xEst, xNext, wNextNorm, xNextFromWeights, addData.
It must return xNextEst.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.setProbObservModel">
<tt class="descname">setProbObservModel</tt><big>(</big><em>model</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.setProbObservModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.setProbObservModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the observation model (i.e. p(y|x))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : fun</p>
<blockquote class="last">
<div><p>Function defining the observation model. The function must have
these inputs: xNext, xEst, w, addData.
It must return wNext.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.setProbTransModel">
<tt class="descname">setProbTransModel</tt><big>(</big><em>model</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.setProbTransModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.setProbTransModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the probability/state transition model (i.e. p(x+1|x))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : fun</p>
<blockquote class="last">
<div><p>Function defining the transition model. The function must have
these inputs: x, xEst (normally not necessary here), addData.
It must return xNext.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.setState">
<tt class="descname">setState</tt><big>(</big><em>xEst</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.setState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.setState" title="Permalink to this definition">¶</a></dt>
<dd><p>Set estimated states history.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xEst</strong> : np.ndarray (nS x nI)</p>
<blockquote class="last">
<div><p>See xEst.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.setStateEstimatorFromWeightsFun">
<tt class="descname">setStateEstimatorFromWeightsFun</tt><big>(</big><em>model</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.setStateEstimatorFromWeightsFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.setStateEstimatorFromWeightsFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the model for state estimation from weights 
(e.g. maximum likelyhood, expectation, etc.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : fun</p>
<blockquote class="last">
<div><p>Function defining the state estimation model from weights. 
The function must have these inputs: xNext, wNextNorm.
It must return xNextFromWeights.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Py3DFreeHandUS.particle_filter.ParticleFilter.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#ParticleFilter.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.ParticleFilter.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the update (and weights normalization) step.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.RNCCObsFun">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">RNCCObsFun</tt><big>(</big><em>xNext</em>, <em>xEst</em>, <em>w</em>, <em>addData</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#RNCCObsFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.RNCCObsFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement a rectified NCC-based observation model for image tracking. 
Rectified NCC (RNCC) is the same as NCC, but truncated to 0 when NCC is 
lower than 0.
The probability distribution is directly expressed as the RNCC value
(0 &lt;= RNCC &lt;= 1) between a target patch and patches centered around the 
positional part of particles.
The first 2 state variables must be x and y position of the patch center
under tracking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xNext</strong> : np.ndarray (nS x nP)</p>
<blockquote>
<div><p>See xNext.</p>
</div></blockquote>
<p><strong>xEst</strong> : np.ndarray (nS x nI)</p>
<blockquote>
<div><p>See xEst.</p>
</div></blockquote>
<p><strong>w</strong> : np.ndarray (nS).</p>
<blockquote>
<div><p>See w.</p>
</div></blockquote>
<p><strong>addData</strong> : dict</p>
<blockquote>
<div><p>See addData.
It may contain the key &#8216;otherPars&#8217; containing the following keys:</p>
<ul class="simple">
<li>&#8216;verbose&#8217;: if True, more data is shown during computation.</li>
</ul>
<p>It must contain the following keys:</p>
<ul class="simple">
<li>&#8216;I&#8217;: current image (only needed if posManuallySet is True or nI is 1)</li>
<li>&#8216;boxSize&#8217;: tuple containing image size (width, height)</li>
<li>&#8216;posManuallySet&#8217;: flag indicating if the target position is manually
set for the current iteration.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS)</p>
<blockquote class="last">
<div><p>See wNext.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.adaptiveHistEstFun">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">adaptiveHistEstFun</tt><big>(</big><em>xEst</em>, <em>xNext</em>, <em>wNextNorm</em>, <em>xNextFromWeights</em>, <em>addData</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#adaptiveHistEstFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.adaptiveHistEstFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a-posteriori probability model described in <tt class="docutils literal"><span class="pre">arm01ConstVelEstFun()</span></tt>
and perform target template histogram update with a certain learning rate, 
for image tracking purpose. This function has to be used in combination with
any histogram-distance-based observation model (e.g. <tt class="docutils literal"><span class="pre">bhattDistObsFun()</span></tt>).
The first 2 state variables must be x and y position of the patch center
under tracking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xEst</strong> : np.ndarray (nS x nI)</p>
<blockquote>
<div><p>See xEst.</p>
</div></blockquote>
<p><strong>xNext</strong> : np.ndarray (nS x nP)</p>
<blockquote>
<div><p>See xNext.</p>
</div></blockquote>
<p><strong>wNextNorm</strong> : np.ndarray (nP)</p>
<blockquote>
<div><p>See wNextNorm.</p>
</div></blockquote>
<p><strong>xNextFromWeights</strong> : np.ndarray (nS).</p>
<blockquote>
<div><p>See xNextFromWeights.</p>
</div></blockquote>
<p><strong>addData</strong> : dict</p>
<blockquote>
<div><p>See addData.
It must contain the key &#8216;otherPars&#8217; containing the following keys:</p>
<ul class="simple">
<li>&#8216;alfaLearnHist&#8217;: learning rate for target template.</li>
<li>keys required by <tt class="docutils literal"><span class="pre">arm01ConstVelEstFun()</span></tt>.</li>
</ul>
<p>It must contain the following keys:</p>
<ul class="simple">
<li>&#8216;I&#8217;: current image (only needed if posManuallySet is True)</li>
<li>&#8216;boxSize&#8217;: tuple containing image size (width, height)</li>
<li>&#8216;posManuallySet&#8217;: flag indicating if the target position is manually
set for the current iteration.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS)</p>
<blockquote class="last">
<div><p>See xNextEst.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.adaptiveTemplateEstFun">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">adaptiveTemplateEstFun</tt><big>(</big><em>xEst</em>, <em>xNext</em>, <em>wNextNorm</em>, <em>xNextFromWeights</em>, <em>addData</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#adaptiveTemplateEstFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.adaptiveTemplateEstFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a-posteriori probability model described in <tt class="docutils literal"><span class="pre">arm01ConstVelEstFun()</span></tt>
and perform target template update with a certain learning rate, for image 
tracking purpose. This function has to be used in combination with any 
template-match-based observation model (e.g. <tt class="docutils literal"><span class="pre">RNCCObsFun()</span></tt>).
The first 2 state variables must be x and y position of the patch center
under tracking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xEst</strong> : np.ndarray (nS x nI)</p>
<blockquote>
<div><p>See xEst.</p>
</div></blockquote>
<p><strong>xNext</strong> : np.ndarray (nS x nP)</p>
<blockquote>
<div><p>See xNext.</p>
</div></blockquote>
<p><strong>wNextNorm</strong> : np.ndarray (nP)</p>
<blockquote>
<div><p>See wNextNorm.</p>
</div></blockquote>
<p><strong>xNextFromWeights</strong> : np.ndarray (nS).</p>
<blockquote>
<div><p>See xNextFromWeights.</p>
</div></blockquote>
<p><strong>addData</strong> : dict</p>
<blockquote>
<div><p>See addData.
It must contain the key &#8216;otherPars&#8217; containing the following keys:</p>
<ul class="simple">
<li>&#8216;alfaLearnTemplate&#8217;: learning rate for target template.</li>
<li>keys required by <tt class="docutils literal"><span class="pre">arm01ConstVelEstFun()</span></tt>.</li>
</ul>
<p>It must contain the following keys:</p>
<ul class="simple">
<li>&#8216;I&#8217;: current image (only needed if posManuallySet is True)</li>
<li>&#8216;boxSize&#8217;: tuple containing image size (width, height)</li>
<li>&#8216;posManuallySet&#8217;: flag indicating if the target position is manually
set for the current iteration.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS)</p>
<blockquote class="last">
<div><p>See xNextEst.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.arm01ConstVelEstFun">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">arm01ConstVelEstFun</tt><big>(</big><em>xEst</em>, <em>xFromWeights</em>, <em>pars</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#arm01ConstVelEstFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.arm01ConstVelEstFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement a-posteriori probability model, with adaptive state, for 
first-oder autoregressive model (constant velocity) for a 2D point 
(see <tt class="docutils literal"><span class="pre">arm01ConstVelFun()</span></tt>). The estimated state is a weighted average 
between xNextFromWeights and the last estimated state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xEst</strong> : np.ndarray (nS x nI)</p>
<blockquote>
<div><p>See xEst.</p>
</div></blockquote>
<p><strong>xFromWeights</strong> : np.ndarray (nS).</p>
<blockquote>
<div><p>See xNextFromWeights.</p>
</div></blockquote>
<p><strong>pars</strong> : dict</p>
<blockquote>
<div><p>Dictionary of parameters. It must contain the following keys:</p>
<ul class="simple">
<li>&#8216;alfaLearnPos&#8217;: 2-elem vector containing weights for the position 
part (x and y) of xNextFromWeights.</li>
<li>&#8216;alfaLearnVel&#8217;: 2-elem vector containing weights for the velocity 
part (x and y) of xNextFromWeights.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS)</p>
<blockquote class="last">
<div><p>See xNextEst.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.arm01ConstVelFun">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">arm01ConstVelFun</tt><big>(</big><em>x</em>, <em>xEst</em>, <em>addData</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#arm01ConstVelFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.arm01ConstVelFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement first-oder autoregressive model (constant velocity) for a 
2D point. State vector is composed by x and y position, followed by x and
y velocity. Gaussian noise is added to both position and velocity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : np.ndarray (nS x nP)</p>
<blockquote>
<div><p>See x.</p>
</div></blockquote>
<p><strong>xEst</strong> : np.ndarray (nS x nI)</p>
<blockquote>
<div><p>See xEst.</p>
</div></blockquote>
<p><strong>addData</strong> : dict</p>
<blockquote>
<div><p>See addData.
It must contain the key &#8216;otherPars&#8217;containing the following keys:</p>
<ul class="simple">
<li>&#8216;sigmaPos&#8217;: 2-elem vector containing standard deviation for the 
position noise (x and y)</li>
<li>&#8216;sigmaVel&#8217;: 2-elem vector containing standard deviation for the 
velocity noise (x and y)</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS x nP)</p>
<blockquote class="last">
<div><p>See xNext.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.bhattDistObsFun">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">bhattDistObsFun</tt><big>(</big><em>xNext</em>, <em>xEst</em>, <em>w</em>, <em>addData</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#bhattDistObsFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.bhattDistObsFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement a Bhattacharyya distance-based observation model for image
tracking.
The probability distribution is modelled as a Gaussian distribution of the
Bhattacharyya histogram distance between a target patch and patches centered 
around the positional part of particles.
The first 2 state variables must be x and y position of the patch center
under tracking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xNext</strong> : np.ndarray (nS x nP)</p>
<blockquote>
<div><p>See xNext.</p>
</div></blockquote>
<p><strong>xEst</strong> : np.ndarray (nS x nI)</p>
<blockquote>
<div><p>See xEst.</p>
</div></blockquote>
<p><strong>w</strong> : np.ndarray (nS).</p>
<blockquote>
<div><p>See w.</p>
</div></blockquote>
<p><strong>addData</strong> : dict</p>
<blockquote>
<div><p>See addData.
It must contain the key &#8216;otherPars&#8217; containing the following keys:</p>
<ul class="simple">
<li>&#8216;nBins&#8217;: number of histogram bins for Bhattacharyya distance calculation.</li>
<li>&#8216;sigmaBhatta&#8217;: sigma for Gaussian distance distribution.</li>
</ul>
<p>It must contain the following keys:</p>
<ul class="simple">
<li>&#8216;I&#8217;: current image (only needed if posManuallySet is True or nI is 1)</li>
<li>&#8216;boxSize&#8217;: tuple containing image size (width, height)</li>
<li>&#8216;posManuallySet&#8217;: flag indicating if the target position is manually
set for the current iteration.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS)</p>
<blockquote class="last">
<div><p>See wNext.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.initRandParticlesInBoxFun">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">initRandParticlesInBoxFun</tt><big>(</big><em>nParticles</em>, <em>xEst</em>, <em>addData</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#initRandParticlesInBoxFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.initRandParticlesInBoxFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Create particles inside a bounded box in case bounding box center is
given manually or there are no estimated states yet.
The first 2 state variables must be x and y position of the box point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nParticles</strong> : int</p>
<blockquote>
<div><p>Number of particles to create.</p>
</div></blockquote>
<p><strong>xEst</strong> : np.ndarray (nS x nI)</p>
<blockquote>
<div><p>See xEst.</p>
</div></blockquote>
<p><strong>addData</strong> : dict</p>
<blockquote>
<div><p>See addData.
It must contain the following keys:</p>
<ul class="simple">
<li>&#8216;boxSize&#8217;: tuple containing image size (width, height)</li>
<li>&#8216;posManuallySet&#8217;: flag indicating if the position position is manually
set for the current iteration.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>xParticles</strong> : np.ndarray (nS x nP)</p>
<blockquote class="last">
<div><p>See x. Velocity components are set to 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.particle_filter.inverseTransformSampling">
<tt class="descclassname">Py3DFreeHandUS.particle_filter.</tt><tt class="descname">inverseTransformSampling</tt><big>(</big><em>x</em>, <em>pdf</em>, <em>nSamples</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/particle_filter.html#inverseTransformSampling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.particle_filter.inverseTransformSampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform data resampling based on inverse transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : np.ndarray (nS x nP)</p>
<blockquote>
<div><p>Matrix where each column represents a sample.</p>
</div></blockquote>
<p><strong>pdf</strong> : np.ndarray (nP)</p>
<blockquote>
<div><p>Probability for each sample.</p>
</div></blockquote>
<p><strong>nSamples</strong> : int</p>
<blockquote>
<div><p>Number of samples to be resampled.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">np.ndarray (nS x nP)</p>
<blockquote class="last">
<div><p>Matrix of the same size of x, but containing only particles with 
heavier weights.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Py3DFreeHandUS.math_utils">
<span id="math-utils"></span><h2><tt class="docutils literal"><span class="pre">math_utils</span></tt><a class="headerlink" href="#module-Py3DFreeHandUS.math_utils" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-math_utils"></span><dl class="function">
<dt id="Py3DFreeHandUS.math_utils.lcm">
<tt class="descclassname">Py3DFreeHandUS.math_utils.</tt><tt class="descname">lcm</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/math_utils.html#lcm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.math_utils.lcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate least common multiple (LCM) between 2 numbers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a, b</strong> : int</p>
<blockquote>
<div><p>Numbers.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">int</p>
<blockquote class="last">
<div><p>LCM</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Py3DFreeHandUS.math_utils.lcmm">
<tt class="descclassname">Py3DFreeHandUS.math_utils.</tt><tt class="descname">lcmm</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="../_modules/Py3DFreeHandUS/math_utils.html#lcmm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Py3DFreeHandUS.math_utils.lcmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate least common multiple (LCM) between N numbers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>*args</strong></p>
<blockquote>
<div><p>Numbers.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">int</p>
<blockquote class="last">
<div><p>LCM</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API</a><ul>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.process"><tt class="docutils literal"><span class="pre">process</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.calib"><tt class="docutils literal"><span class="pre">calib</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.image_utils"><tt class="docutils literal"><span class="pre">image_utils</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.voxel_array_utils"><tt class="docutils literal"><span class="pre">voxel_array_utils</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.kine"><tt class="docutils literal"><span class="pre">kine</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.segment"><tt class="docutils literal"><span class="pre">segment</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.converters"><tt class="docutils literal"><span class="pre">converters</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.muscles_analysis"><tt class="docutils literal"><span class="pre">muscles_analysis</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.tracking"><tt class="docutils literal"><span class="pre">tracking</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.particle_filter"><tt class="docutils literal"><span class="pre">particle_filter</span></tt></a></li>
<li><a class="reference internal" href="#module-Py3DFreeHandUS.math_utils"><tt class="docutils literal"><span class="pre">math_utils</span></tt></a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../tutorial/when_mem_error.html"
                        title="previous chapter">In case of <tt class="docutils literal"><span class="pre">MemoryError</span></tt></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../license.html"
                        title="next chapter">License</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/api.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../license.html" title="License"
             >next</a> |</li>
        <li class="right" >
          <a href="../tutorial/when_mem_error.html" title="In case of MemoryError"
             >previous</a> |</li>
        <li><a href="../index.html">Py3DFreeHandUS 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Davide Monari.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>